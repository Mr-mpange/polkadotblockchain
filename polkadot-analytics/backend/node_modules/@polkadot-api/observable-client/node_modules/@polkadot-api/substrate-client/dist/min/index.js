"use strict";var W=Object.defineProperty;var re=Object.getOwnPropertyDescriptor;var te=Object.getOwnPropertyNames;var ne=Object.prototype.hasOwnProperty;var oe=(r,e,t)=>e in r?W(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var ie=(r,e)=>{for(var t in e)W(r,t,{get:e[t],enumerable:!0})},se=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of te(e))!ne.call(r,n)&&n!==t&&W(r,n,{get:()=>e[n],enumerable:!(o=re(e,n))||o.enumerable});return r};var ae=r=>se(W({},"__esModule",{value:!0}),r);var B=(r,e,t)=>(oe(r,typeof e!="symbol"?e+"":e,t),t);var me={};ie(me,{DestroyedError:()=>S,DisjointError:()=>w,OperationError:()=>x,OperationInaccessibleError:()=>O,OperationLimitError:()=>C,RpcError:()=>I,StopError:()=>P,createClient:()=>ue});module.exports=ae(me);var H=require("@polkadot-api/utils"),v=r=>(...e)=>new Promise((t,o)=>{let n=H.noop,[s,m]=e[e.length-1]instanceof AbortSignal?[e.slice(0,e.length-1),e[e.length-1]]:[e],u=()=>{n(),o(new H.AbortError)};m?.addEventListener("abort",u,{once:!0});let R=f=>p=>{n=H.noop,m?.removeEventListener("abort",u),f(p)};n=r(R(t),R(o),...s)});function z(){let r=()=>{},e=()=>{};return{promise:new Promise((o,n)=>{r=o,e=n}),res:r,rej:e}}var y=()=>{};var k=()=>{let r=new Map;return{has:r.has.bind(r),subscribe(e,t){r.set(e,t)},unsubscribe(e){r.delete(e)},next(e,t){r.get(e)?.next(t)},error(e,t){let o=r.get(e);o&&(r.delete(e),o.error(t))},errorAll(e){let t=[...r.values()];r.clear(),t.forEach(o=>{o.error(e)})}}};var b={body:"",call:"",continue:"",follow:"",header:"",stopOperation:"",storage:"",unfollow:"",unpin:"",followEvent:""},F={chainName:"",genesisHash:"",properties:""},A={broadcast:"",stop:""},ce={submitAndWatch:"",unwatch:""};Object.entries({chainHead:b,chainSpec:F,transaction:A,transactionWatch:ce}).forEach(([r,e])=>{Object.keys(e).forEach(t=>{e[t]=`${r}_v1_${t}`})});var M=r=>(e,t)=>{let o=r(A.broadcast,[e],{onSuccess:n=>{o=n===null?y:()=>{r(A.stop,[n])},n===null&&t(new Error("Max # of broadcasted transactions has been reached"))},onError:t});return()=>{o()}};var P=class extends Error{constructor(){super("ChainHead stopped"),this.name="StopError"}},w=class extends Error{constructor(){super("ChainHead disjointed"),this.name="DisjointError"}},C=class extends Error{constructor(){super("ChainHead operations limit reached"),this.name="OperationLimitError"}},x=class extends Error{constructor(e){super(e),this.name="OperationError"}},O=class extends Error{constructor(){super("ChainHead operation inaccessible"),this.name="OperationInaccessibleError"}};var j=(r,e)=>t=>v((o,n,...s)=>{let m=!0,u=()=>{m=!1},[R,f]=e(...s);return t(r,R,{onSuccess:(p,l)=>{if(p.result==="limitReached")return n(new C);let{operationId:a}=p,c=()=>{t(b.stopOperation,[a])};if(!m)return c();let i=y,g=d=>{m=!1,i(),o(d)},h=d=>{m=!1,i(),n(d)};i=l(a,{next:d=>{let E=d;E.event==="operationError"?n(new x(E.error)):E.event==="operationInaccessible"?n(new O):f(d,g,h)},error:h}),u=()=>{m&&(i(),c())}},onError:n}),()=>{u()}});var N=j(b.body,r=>[[r],(e,t)=>{t(e.value)}]);var G=j(b.call,(r,e,t)=>[[r,e,t],(o,n)=>{n(o.output)}]);var K=r=>e=>new Promise((t,o)=>{r(b.header,[e],{onSuccess:t,onError:o})});var U=require("@polkadot-api/utils");var L=r=>(e,t,o,n,s,m,u)=>{if(t.length===0)return m(),U.noop;let R=!0,f=()=>{R=!1};return r(b.storage,[e,t,o],{onSuccess:(p,l)=>{if(p.result==="limitReached"||p.discardedItems===t.length)return s(new C);let{operationId:a}=p,c=()=>{r(b.stopOperation,[a])};if(!R)return c();let i=l(p.operationId,{next:d=>{switch(d.event){case"operationStorageItems":{n(d.items);break}case"operationStorageDone":{h();break}case"operationError":{g(new x(d.error));break}case"operationInaccessible":{g(new O);break}default:r(b.continue,[d.operationId])}},error:s});f=()=>{i(),r(b.stopOperation,[p.operationId])};let g=d=>{f=U.noop,i(),s(d)},h=()=>{f=U.noop,i(),m()};u(p.discardedItems)},onError:s}),()=>{f()}};var Q=r=>{let e=L(r);return v((t,o,n,s,m,u)=>{let R=s.startsWith("descendants"),f=R?[]:null,l=e(n,[{key:m,type:s}],u??null,R?a=>{f.push(a)}:a=>{f=a[0]?.[s]},o,()=>{try{t(R?f.flat():f)}catch(a){o(a)}},a=>{a>0&&(l(),o(new C))});return l})};var V=r=>e=>e.length>0?new Promise((t,o)=>{r(b.unpin,[e],{onSuccess(){t()},onError:o})}):Promise.resolve();var S=class extends Error{constructor(){super("Client destroyed"),this.name="DestroyedError"}};function pe(r){return r.operationId!==void 0}function $(r){return(e,t,o)=>{let n=k(),s=new Set,m=z(),u=m.promise,R=i=>{if(pe(i))return n.has(i.operationId)||console.warn("Uknown operationId on",i),n.next(i.operationId,i);if(i.event!=="stop"){if(i.event==="initialized")return t({type:i.event,finalizedBlockHashes:"finalizedBlockHash"in i?[i.finalizedBlockHash]:i.finalizedBlockHashes,finalizedBlockRuntime:i.finalizedBlockRuntime});let{event:g,...h}=i;return t({type:g,...h})}o(new P),a(!1)},f=i=>{o(i),a(!(i instanceof S))},p=(i,g)=>{let h=g(i,{next:R,error:f});a=(d=!0)=>{u=null,a=y,h(),d&&r(b.unfollow,[i]),n.errorAll(new w),s.forEach(E=>{E()}),s.clear()},u=i,m.res(i)},l=i=>{i instanceof S?a(!1):o(i),u=null,m.res(i)},a=r(b.follow,[e],{onSuccess:p,onError:l}),c=(i,g,h)=>{let d=()=>{h?.onError(new w)};if(u===null)return d(),y;let E=T=>{if(!h)return r(i,[T,...g]);s.add(d);let _=(q,J)=>u===null?(J.error(new w),y):(n.subscribe(q,J),()=>{n.unsubscribe(q)}),ee=r(i,[T,...g],{onSuccess:q=>{s.delete(d),h.onSuccess(q,_)},onError:q=>{s.delete(d),h.onError(q)}});return()=>{s.delete(d),ee()}};if(typeof u=="string")return E(u);let D=y;return u.then(T=>{if(T instanceof Error)return d();u&&(D=E(T))}),()=>{D()}};return{unfollow(){a(),u=null},body:N(c),call:G(c),header:K(c),storage:Q(c),storageSubscription:L(c),unpin:V(c),_request:c}}}var I=class extends Error{constructor(t){super(t.message);B(this,"code");B(this,"data");this.code=t.code,this.data=t.data,this.name="RpcError"}};var le=1,X=r=>{let e=le++,t=new Map,o=k(),n=null,s=(p,l,a)=>{n.send(JSON.stringify({jsonrpc:"2.0",id:p,method:l,params:a}))};function m(p){try{let l,a,c,i,g;if({id:l,result:a,error:c,params:i}=JSON.parse(p),l){let E=t.get(l);return E?(t.delete(l),c?E.onError(new I(c)):E.onSuccess(a,(D,T)=>{let _=D;return o.subscribe(_,T),()=>{o.unsubscribe(_)}})):void 0}if({subscription:g,result:a,error:c}=i,!g||!c&&!Object.hasOwn(i,"result"))throw 0;let d=g;c?o.error(d,new I(c)):o.next(d,a)}catch(l){console.warn("Error parsing incomming message: "+p),console.error(l)}}n=r(m);let u=()=>{n?.disconnect(),n=null,o.errorAll(new S),t.forEach(p=>p.onError(new S)),t.clear()},R=1;return{request:(p,l,a)=>{if(!n)throw new Error("Not connected");let c=`${e}-${R++}`;return a&&t.set(c,a),s(c,p,l),()=>{t.delete(c)}},disconnect:u}};var Y=r=>{let e=v((o,n,s,m)=>r(s,m,{onSuccess:o,onError:n})),t=null;return async()=>t||(t=Promise.all([e(F.chainName,[]),e(F.genesisHash,[]),e(F.properties,[])]).then(([o,n,s])=>({name:o,genesisHash:n,properties:s})))};var Z=(r,e)=>t=>{let o={},n=null;return(s,...m)=>{if(n)return n(s,...m);let u=!0,R=()=>{u=!1};return r.then(f=>{if(n=(l,...a)=>{let c=o[l]??l;return f.has(c)?e(c,...a):(a[1]?.onError(new Error(`Unsupported method ${c}`)),y)},f.has(s))return;let p=s.split("_");if(p[1]==="v1"){if(p[1]="unstable",f.has(p.join("_")))Object.values(t).forEach(l=>{o[l]=l.replace("_v1_","_unstable_")});else if(p[0]==="transaction"){let l,a,c=["transactionWatch","transaction"].find(i=>(a=["v1","unstable"].find(g=>f.has(l=`${i}_${g}_unwatch`)),!!a));c&&(o[t.broadcast]=`${c}_${a}_submitAndWatch`,o[t.stop]=l)}}}).then(()=>{u&&(R=n(s,...m))}),()=>{R()}}};var ue=r=>{let e=X(r),t=v((s,m,u,R)=>e.request(u,R,{onSuccess:s,onError:m})),o=t("rpc_methods",[]).then(s=>new Set(Array.isArray(s)?s:s.methods),()=>new Set),n=Z(o,e.request);return{chainHead:$(n(b)),transaction:M(n(A)),getChainSpecData:Y(n(F)),destroy:()=>{e.disconnect()},request:t,_request:e.request}};
//# sourceMappingURL=index.js.map
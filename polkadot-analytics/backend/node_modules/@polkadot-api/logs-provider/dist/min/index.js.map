{"version":3,"sources":["../../src/index.ts","../../src/queue.ts","../../src/types.ts","../../src/logs-provider.ts","../../src/with-logs-recorder.ts"],"sourcesContent":["export * from \"./logs-provider\"\nexport * from \"./with-logs-recorder\"\n","interface QueueNode<T> {\n  value: T\n  next?: QueueNode<T>\n}\n\nexport default class Queue<T> {\n  private first?: QueueNode<T>\n  private last?: QueueNode<T>\n\n  constructor(...vals: T[]) {\n    if (vals.length === 0) return\n    vals.forEach((val) => this.push(val))\n  }\n\n  push(value: T) {\n    const nextLast: QueueNode<T> = { value }\n    if (this.last === undefined) {\n      this.last = nextLast\n      this.first = this.last\n    } else {\n      this.last.next = nextLast\n      this.last = nextLast\n    }\n  }\n\n  pop() {\n    const result = this.first?.value\n    if (this.first) {\n      this.first = this.first.next\n      if (!this.first) {\n        this.last = undefined\n      }\n    }\n    return result\n  }\n\n  peek() {\n    return this.first?.value\n  }\n}\n","export type Out = \">>\"\nexport const OUT: Out = \">>\"\n\nexport type In = \"<<\"\nexport const IN: In = \"<<\"\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport Queue from \"./queue\"\nimport { In, OUT, Out } from \"./types\"\n\ninterface Log {\n  clientId: number\n  type: In | Out\n  msg: string\n  tick: number\n}\n\nconst rawLogsToLogs = (rawLogs: string[]): Map<number, Log[]> => {\n  const result = new Map<number, Log[]>()\n  let prevDate = \"\"\n  let tick = -1\n\n  for (let i = 0; i < rawLogs.length; i++) {\n    const [, clientIdRaw, dateRaw, type, msg] = rawLogs[i].match(\n      /^(\\d*)-(.{24})-(.{2})-(.*)$/,\n    )!\n    const clientId = Number(clientIdRaw)\n\n    tick += dateRaw === prevDate ? 0 : 1\n    prevDate = dateRaw\n\n    const logs = result.get(clientId) ?? []\n    result.set(clientId, logs)\n\n    logs.push({\n      clientId,\n      tick,\n      type: type as any,\n      msg,\n    })\n  }\n\n  return result\n}\n\nconst extractTx = (msg: string) => {\n  const startTxt = 'TaggedTransactionQueue_validate_transaction\",\"'\n  const start = msg.lastIndexOf(startTxt) + startTxt.length + 4\n  const end = msg.indexOf(`\"`, start + 1)\n  return msg.substring(start, end - 64)\n}\n\nexport const logsProvider = (rawLogs: Array<string>): JsonRpcProvider => {\n  let nextClientId = 1\n  const allLogs = rawLogsToLogs(\n    rawLogs[rawLogs.length - 1] ? rawLogs : rawLogs.slice(0, -1),\n  )\n\n  return (onMsg) => {\n    const clientId = nextClientId++\n    const logs = allLogs.get(clientId)!\n    const pending = new Queue<string>()\n    let idx = 0\n\n    let transactions = new Map<string, string>()\n    const checkForIncommingMessages = async () => {\n      if (!pending.peek()) return\n\n      while (idx < logs.length && token !== undefined) {\n        const expected = logs[idx]\n        transactions.forEach((value, key) => {\n          expected.msg = expected.msg.replace(key, value)\n        })\n        if (expected.type === OUT) {\n          if (!pending.peek()) {\n            token = setTimeout(checkForIncommingMessages, 100)\n            break\n          }\n\n          const received = pending.pop()\n\n          if (\n            expected.msg.includes(\n              \"TaggedTransactionQueue_validate_transaction\",\n            ) &&\n            received?.includes(\"TaggedTransactionQueue_validate_transaction\")\n          ) {\n            transactions.set(extractTx(expected.msg), extractTx(received))\n            transactions.forEach((value, key) => {\n              expected.msg = expected.msg.replace(key, value)\n            })\n          }\n\n          if (received !== expected.msg) {\n            console.log(`recieved: \"${received}\"`)\n            console.log(`expected: \"${expected.msg}\"`)\n            throw new Error(\"unexpected messaged was received\")\n          }\n        } else {\n          onMsg(expected.msg)\n          await Promise.resolve()\n        }\n        idx++\n      }\n    }\n\n    let token: undefined | number = setTimeout(checkForIncommingMessages, 200)\n\n    return {\n      send: (msg) => {\n        pending.push(msg)\n      },\n      disconnect: () => {\n        clearTimeout(token)\n        token = undefined\n      },\n    }\n  }\n}\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { IN, OUT } from \"./types\"\n\nexport const withLogsRecorder = (\n  persistLog: (log: string) => void,\n  input: JsonRpcProvider,\n): JsonRpcProvider => {\n  let nextId = 1\n  let token: any\n  let tickDate = \"\"\n  const setTickDate = () => {\n    tickDate = new Date().toISOString()\n    token = setTimeout(setTickDate, 0)\n  }\n\n  return (onMsg) => {\n    const clientId = nextId++\n\n    setTickDate()\n\n    const result = input((msg) => {\n      persistLog(`${clientId}-${tickDate}-${IN}-${msg}`)\n      onMsg(msg)\n    })\n\n    return {\n      ...result,\n      send: (msg) => {\n        persistLog(`${clientId}-${tickDate}-${OUT}-${msg}`)\n        result.send(msg)\n      },\n      disconnect() {\n        clearTimeout(token)\n        result.disconnect()\n      },\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","logsProvider","withLogsRecorder","__toCommonJS","Queue","vals","__publicField","val","value","nextLast","result","OUT","IN","rawLogsToLogs","rawLogs","result","prevDate","tick","i","clientIdRaw","dateRaw","type","msg","clientId","logs","extractTx","startTxt","start","end","logsProvider","nextClientId","allLogs","onMsg","pending","Queue","idx","transactions","checkForIncommingMessages","token","expected","value","key","OUT","received","withLogsRecorder","persistLog","input","nextId","token","tickDate","setTickDate","onMsg","clientId","result","msg","IN","OUT"]}
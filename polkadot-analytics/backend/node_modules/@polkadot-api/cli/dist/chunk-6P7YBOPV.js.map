{"version":3,"sources":["../src/cli.ts","../src/metadata.ts","../src/papiConfig.ts","../src/commands/add.ts","../src/commands/generate.ts","../src/commands/remove.ts","../src/commands/update.ts"],"sourcesContent":["import { Option, program } from \"@commander-js/extra-typings\"\nimport type { add, generate, remove, update } from \"./commands\"\nimport * as knownChains from \"@polkadot-api/known-chains\"\n\nexport type Commands = {\n  add: typeof add\n  generate: typeof generate\n  remove: typeof remove\n  update: typeof update\n}\n\nexport function getCli({ add, generate, remove, update }: Commands) {\n  program.name(\"polkadot-api\").description(\"Polkadot API CLI\")\n\n  const config = new Option(\"--config <filename>\", \"Source for the config file\")\n\n  program\n    .command(\"generate\", {\n      isDefault: true,\n    })\n    .description(\"Generate descriptor files\")\n    .addOption(config)\n    .option(\"-k, --key <key>\", \"Key of the descriptor to generate\")\n    .option(\n      \"--whitelist <filename>\",\n      \"Use whitelist file to reduce descriptor size\",\n    )\n    .action(generate)\n\n  program\n    .command(\"add\")\n    .description(\"Add a new chain spec to the list\")\n    .argument(\"<key>\", \"Key identifier for the chain spec\")\n    .addOption(config)\n    .option(\"-f, --file <filename>\", \"Source from metadata encoded file\")\n    .option(\"-w, --wsUrl <URL>\", \"Source from websocket url\")\n    .option(\"-c, --chainSpec <filename>\", \"Source from chain spec file\")\n    .addOption(\n      new Option(\"-n, --name <name>\", \"Source from a well-known chain\").choices(\n        Object.keys(knownChains),\n      ),\n    )\n    .option(\"--wasm <filename>\", \"Source from runtime wasm file\")\n    .option(\"--no-persist\", \"Do not persist the metadata as a file\")\n    .action(add)\n\n  program\n    .command(\"update\")\n    .description(\"Update the metadata files and generate descriptor files\")\n    .argument(\n      \"[keys]\",\n      \"Keys of the metadata files to update, separated by commas. Leave empty for all\",\n    )\n    .addOption(config)\n    .action(update)\n\n  program\n    .command(\"remove\")\n    .description(\"Remove a chain spec from the list\")\n    .argument(\"<key>\", \"Key identifier for the chain spec\")\n    .addOption(config)\n    .action(remove)\n\n  return program\n}\n","import { createClient } from \"@polkadot-api/substrate-client\"\nimport type { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport * as fs from \"node:fs/promises\"\nimport { V14, V15, metadata, v15 } from \"@polkadot-api/substrate-bindings\"\nimport { WebSocketProvider } from \"@polkadot-api/ws-provider/node\"\nimport { Worker } from \"node:worker_threads\"\nimport { getObservableClient } from \"@polkadot-api/observable-client\"\nimport { filter, firstValueFrom } from \"rxjs\"\nimport { EntryConfig } from \"./papiConfig\"\nimport { dirname } from \"path\"\nimport { fileURLToPath } from \"url\"\nimport * as knownChains from \"@polkadot-api/known-chains\"\nimport type {\n  MetadataWithRaw,\n  WorkerRequestMessage,\n  WorkerResponseMessage,\n} from \"./metadataWorker\"\n\nconst workerPath = fileURLToPath(import.meta.resolve(\"./metadataWorker.js\"))\n\nlet metadataWorker: Worker | null\nlet workerRefCount = 0\nasync function getMetadataWorker() {\n  if (!metadataWorker) {\n    metadataWorker = new Worker(workerPath, {\n      stdout: true,\n      stderr: true,\n    })\n    await new Promise((resolve) => {\n      metadataWorker?.once(\"message\", resolve)\n      metadataWorker?.postMessage(\"ready\")\n    })\n  }\n  return metadataWorker\n}\n\nconst getMetadataCall = async (provider: JsonRpcProvider) => {\n  const client = getObservableClient(createClient(provider))\n  const { runtime$, unfollow } = client.chainHead$()\n  const runtime = await firstValueFrom(runtime$.pipe(filter(Boolean)))\n\n  unfollow()\n  client.destroy()\n\n  return { metadata: runtime.metadata, metadataRaw: runtime.metadataRaw }\n}\n\nconst getWorkerMessage = (chain: string): Omit<WorkerRequestMessage, \"id\"> => {\n  if (!(chain in knownChains)) {\n    return {\n      potentialRelayChainSpecs: [],\n      chainSpec: chain,\n    }\n  }\n  const relayChainName = Object.keys(knownChains).find(\n    (c) => c !== chain && chain.startsWith(c),\n  )\n  const potentialRelayChainSpecs = relayChainName\n    ? [knownChains[relayChainName as keyof typeof knownChains]]\n    : []\n  const chainSpec = knownChains[chain as keyof typeof knownChains]\n\n  return {\n    potentialRelayChainSpecs,\n    chainSpec,\n  }\n}\n\nlet id = 0\nconst getMetadataFromSmoldot = async (chain: string) => {\n  workerRefCount++\n  try {\n    const reqId = id++\n    const metadataWorker = await getMetadataWorker()\n    const message: WorkerRequestMessage = {\n      ...getWorkerMessage(chain),\n      id: reqId,\n    }\n    const metadata = await new Promise<MetadataWithRaw>((resolve) => {\n      const listener = (data: WorkerResponseMessage) => {\n        if (data.id !== reqId) return\n        metadataWorker.off(\"message\", listener)\n        resolve(data.metadata)\n      }\n      metadataWorker.on(\"message\", listener)\n      metadataWorker.postMessage(message)\n    })\n    return metadata\n  } finally {\n    workerRefCount--\n    if (workerRefCount === 0) {\n      metadataWorker?.terminate()\n      metadataWorker = null\n    }\n  }\n}\n\nconst getMetadataFromWsURL = async (wsURL: string) =>\n  getMetadataCall(WebSocketProvider(wsURL))\n\nexport async function getMetadata(\n  entry: EntryConfig,\n): Promise<{ metadata: V15 | V14; metadataRaw: Uint8Array } | null> {\n  // metadata file always prevails over other entries.\n  // cli's update will update the metadata file when the user requests it.\n  if (entry.metadata) {\n    const data = await fs.readFile(entry.metadata)\n    const metadataRaw = new Uint8Array(data)\n\n    let meta: V14 | V15\n    try {\n      meta = metadata.dec(metadataRaw).metadata.value as V14 | V15\n    } catch (_) {\n      meta = v15.dec(metadataRaw)\n    }\n\n    return {\n      metadata: meta,\n      metadataRaw,\n    }\n  }\n\n  if (\"chain\" in entry) {\n    return getMetadataFromSmoldot(entry.chain)\n  }\n\n  if (\"chainSpec\" in entry) {\n    const chainSpec = await fs.readFile(entry.chainSpec, \"utf8\")\n    return getMetadataFromSmoldot(chainSpec)\n  }\n\n  if (\"wsUrl\" in entry) {\n    return getMetadataFromWsURL(entry.wsUrl)\n  }\n\n  return null\n}\n\nexport async function writeMetadataToDisk(\n  metadataRaw: Uint8Array,\n  outFile: string,\n) {\n  await fs.mkdir(dirname(outFile), { recursive: true })\n  await fs.writeFile(outFile, metadataRaw)\n}\n","import fsExists from \"fs.promises.exists\"\nimport { readPackage } from \"read-pkg\"\nimport { updatePackage } from \"write-package\"\nimport { readFile, writeFile } from \"node:fs/promises\"\n\nexport type EntryConfig =\n  | {\n      metadata: string\n    }\n  | {\n      chainSpec: string\n      metadata?: string\n    }\n  | {\n      wsUrl: string\n      metadata?: string\n    }\n  | {\n      chain: string\n      metadata?: string\n    }\nexport type PapiConfig = Record<string, EntryConfig>\n\nconst papiCfgDefaultFile = \"polkadot-api.json\"\nconst packageJsonKey = \"polkadot-api\"\n\nexport async function readPapiConfig(\n  configFile: string | undefined,\n): Promise<PapiConfig | null> {\n  if (configFile) return readFromFile(configFile)\n\n  const configFromDefaultFile = await readFromFile(papiCfgDefaultFile)\n  if (configFromDefaultFile) return configFromDefaultFile\n\n  return readFromFile(\"package.json\")\n}\n\n/**\n * Writes config to configFile. If configFile is not specified, it writes to the\n * default path, by this priority order:\n *\n * 1. Default config file (polkadot-api.json)\n * 2. Package.json If no pre-existing config exists, then it creates a\n * polkadot-api.json file.\n */\nexport async function writePapiConfig(\n  configFile: string | undefined,\n  config: PapiConfig,\n) {\n  if (configFile) return writeToFile(configFile, config)\n\n  const defaultCfgExists = await fsExists(papiCfgDefaultFile)\n  if (defaultCfgExists) return writeToFile(papiCfgDefaultFile, config)\n\n  const packageCfg = await readFromFile(\"package.json\")\n  if (packageCfg) {\n    return writeToFile(\"package.json\", config)\n  }\n\n  return writeToFile(papiCfgDefaultFile, config)\n}\n\nasync function readFromFile(file: string) {\n  const fileExists = await fsExists(file)\n  if (!fileExists) return null\n\n  if (file === \"package.json\") {\n    const packageJson = await readPackage()\n    return packageJson[packageJsonKey] ?? null\n  }\n  return JSON.parse(await readFile(file, \"utf8\"))\n}\n\nasync function writeToFile(file: string, config: PapiConfig) {\n  if (file === \"package.json\") {\n    // updatePackage preserves existing values, we have to clear them to make removes work.\n    await updatePackage({\n      [packageJsonKey]: null,\n    })\n    return updatePackage({\n      [packageJsonKey]: config,\n    })\n  }\n  return writeFile(file, JSON.stringify(config, null, 2))\n}\n","import { getMetadata, writeMetadataToDisk } from \"@/metadata\"\nimport { EntryConfig, readPapiConfig, writePapiConfig } from \"@/papiConfig\"\nimport { compactNumber } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport { getMetadataFromRuntime } from \"@polkadot-api/wasm-executor\"\nimport * as fs from \"node:fs/promises\"\nimport ora from \"ora\"\nimport { CommonOptions } from \"./commonOptions\"\n\nexport interface AddOptions extends CommonOptions {\n  file?: string\n  wsUrl?: string\n  chainSpec?: string\n  // well-known chains\n  name?: string\n  wasm?: string\n  noPersist?: boolean\n}\n\nexport async function add(key: string, options: AddOptions) {\n  const entries = (await readPapiConfig(options.config)) ?? {}\n  if (key in entries) {\n    console.warn(`Replacing existing ${key} config`)\n  }\n\n  if (options.file) {\n    entries[key] = {\n      metadata: options.file,\n    }\n  } else if (options.wasm) {\n    const spinner = ora(`Loading metadata from runtime`).start()\n    const metadataHex = (await fs.readFile(options.wasm)).toString(\"hex\")\n    const opaqueMeta = fromHex(getMetadataFromRuntime(`0x${metadataHex}`))\n\n    // metadata comes with compact length prepended\n    const metadataLen = compactNumber.dec(opaqueMeta)\n    const compactLen = compactNumber.enc(metadataLen).length\n    // verify we got all data\n    if (opaqueMeta.length - compactLen !== metadataLen)\n      throw new Error(\"Not able to retrieve runtime metadata\")\n\n    spinner.text = \"Writing metadata\"\n    const metadataRaw = opaqueMeta.slice(compactLen)\n    const filename = `${key}.scale`\n    await writeMetadataToDisk(metadataRaw, filename)\n    spinner.succeed(`Metadata saved as ${filename}`)\n\n    entries[key] = {\n      metadata: filename,\n    }\n  } else {\n    const entry = entryFromOptions(options)\n    entries[key] = entry\n\n    if (!options.noPersist) {\n      const spinner = ora(`Loading metadata`).start()\n      const { metadataRaw } = (await getMetadata(entry))!\n\n      spinner.text = \"Writing metadata\"\n      const filename = `${key}.scale`\n      await writeMetadataToDisk(metadataRaw, filename)\n\n      spinner.succeed(`Metadata saved as ${filename}`)\n      entry.metadata = filename\n    }\n  }\n\n  await writePapiConfig(options.config, entries)\n  return console.log(`Saved new spec \"${key}\"`)\n}\n\nconst entryFromOptions = (options: AddOptions): EntryConfig => {\n  if (options.wsUrl) {\n    return {\n      wsUrl: options.wsUrl,\n    }\n  }\n  if (options.chainSpec) {\n    return {\n      chainSpec: options.chainSpec,\n    }\n  }\n  if (options.name) {\n    return {\n      chain: options.name,\n    }\n  }\n\n  throw new Error(\n    \"add command needs one source, specified by options -f -w -c or -n\",\n  )\n}\n","import { getMetadata } from \"@/metadata\"\nimport { EntryConfig, readPapiConfig } from \"@/papiConfig\"\nimport { generateMultipleDescriptors } from \"@polkadot-api/codegen\"\nimport { V14, V15 } from \"@polkadot-api/substrate-bindings\"\nimport fs, { mkdtemp, rm } from \"fs/promises\"\nimport path, { join } from \"path\"\nimport process from \"process\"\nimport tsc from \"tsc-prog\"\nimport tsup, { build } from \"tsup\"\nimport { CommonOptions } from \"./commonOptions\"\nimport fsExists from \"fs.promises.exists\"\nimport { existsSync } from \"fs\"\nimport { tmpdir } from \"os\"\n\nexport interface GenerateOptions extends CommonOptions {\n  key?: string\n  clientLibrary?: string\n  whitelist?: string\n}\n\nexport async function generate(opts: GenerateOptions) {\n  const sources = await getSources(opts)\n\n  if (Object.keys(sources).length == 0) {\n    console.log(\"No chains defined in config file\")\n  }\n\n  console.log(`Reading metadata`)\n  const chains = await Promise.all(\n    Object.entries(sources).map(async ([key, source]) => ({\n      key,\n      metadata: (await getMetadata(source))!.metadata,\n      knownTypes: {},\n    })),\n  )\n\n  const descriptorsDir = join(\n    process.cwd(),\n    \"node_modules\",\n    \"@polkadot-api\",\n    \"descriptors\",\n  )\n\n  const clientPath = opts.clientLibrary ?? \"polkadot-api\"\n\n  if (existsSync(descriptorsDir))\n    await fs.rm(descriptorsDir, { recursive: true })\n\n  await fs.mkdir(descriptorsDir, { recursive: true })\n  await generatePackageJson(join(descriptorsDir, \"package.json\"))\n\n  const whitelist = opts.whitelist ? await readWhitelist(opts.whitelist) : null\n  await outputCodegen(\n    chains,\n    join(descriptorsDir, \"src\"),\n    clientPath,\n    whitelist,\n  )\n  await compileCodegen(descriptorsDir)\n  await fs.rm(join(descriptorsDir, \"src\"), { recursive: true })\n}\n\nasync function getSources(\n  opts: GenerateOptions,\n): Promise<Record<string, EntryConfig>> {\n  const config = await readPapiConfig(opts.config)\n  if (!config) {\n    throw new Error(\"Can't find the Polkadot-API configuration\")\n  }\n\n  if (opts.key) {\n    if (!config[opts.key]) {\n      throw new Error(`Key ${opts.key} not set in polkadot-api config`)\n    }\n    return {\n      [opts.key]: config[opts.key],\n    }\n  }\n\n  return config\n}\n\nasync function outputCodegen(\n  chains: Array<{\n    key: string\n    metadata: V14 | V15\n    knownTypes: Record<string, string>\n  }>,\n  outputFolder: string,\n  clientPath: string,\n  whitelist: string[] | null,\n) {\n  const {\n    descriptorsFileContent,\n    descriptorTypesFileContent,\n    checksums,\n    typesFileContent,\n    publicTypes,\n  } = generateMultipleDescriptors(\n    chains,\n    {\n      client: clientPath,\n      checksums: \"./checksums.json\",\n      types: \"./common-types\",\n      descriptorValues: \"./descriptors\",\n    },\n    {\n      whitelist: whitelist ?? undefined,\n    },\n  )\n\n  await fs.mkdir(outputFolder, { recursive: true })\n  await fs.writeFile(\n    path.join(outputFolder, \"checksums.json\"),\n    JSON.stringify(checksums),\n  )\n  await fs.writeFile(\n    path.join(outputFolder, \"descriptors.ts\"),\n    descriptorsFileContent,\n  )\n  await fs.writeFile(\n    path.join(outputFolder, \"common-types.ts\"),\n    typesFileContent,\n  )\n  await Promise.all(\n    chains.map((chain, i) =>\n      fs.writeFile(\n        join(outputFolder, `${chain.key}.ts`),\n        descriptorTypesFileContent[i],\n      ),\n    ),\n  )\n  await generateIndex(\n    outputFolder,\n    chains.map((chain) => chain.key),\n    publicTypes,\n  )\n}\n\nasync function compileCodegen(packageDir: string) {\n  const srcDir = join(packageDir, \"src\")\n  const outDir = join(packageDir, \"dist\")\n\n  if (await fsExists(outDir)) {\n    await fs.rm(outDir, { recursive: true })\n  }\n\n  await tsup.build({\n    format: [\"cjs\", \"esm\"],\n    entry: [path.join(srcDir, \"index.ts\")],\n    outDir,\n    outExtension: (ctx) => ({\n      js: ctx.format === \"esm\" ? \".mjs\" : \".js\",\n    }),\n  })\n\n  tsc.build({\n    basePath: srcDir,\n    compilerOptions: {\n      skipLibCheck: true,\n      declaration: true,\n      emitDeclarationOnly: true,\n      target: \"esnext\",\n      module: \"esnext\",\n      moduleResolution: \"node\",\n      resolveJsonModule: true,\n      allowSyntheticDefaultImports: true,\n      outDir,\n    },\n  })\n}\n\nconst generateIndex = async (\n  path: string,\n  keys: string[],\n  publicTypes: string[],\n) => {\n  const indexTs = [\n    ...keys.flatMap((key) => [\n      `export { default as ${key} } from \"./${key}\";`,\n      `export type * from \"./${key}\";`,\n    ]),\n    `export {`,\n    publicTypes.join(\", \"),\n    `} from './common-types';`,\n  ].join(\"\\n\")\n  await fs.writeFile(join(path, \"index.ts\"), indexTs)\n}\n\nconst generatePackageJson = async (path: string) => {\n  await fs.writeFile(\n    path,\n    `{\n      \"name\": \"@polkadot-api/descriptors\",\n      \"exports\": {\n        \".\": {\n          \"module\": \"./dist/index.mjs\",\n          \"import\": \"./dist/index.mjs\",\n          \"require\": \"./dist/index.js\",\n          \"default\": \"./dist/index.js\"\n        },\n        \"./package.json\": \"./package.json\"\n      },\n      \"main\": \"./dist/index.js\",\n      \"module\": \"./dist/index.mjs\",\n      \"browser\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\",\n      \"sideEffects\": false,\n      \"peerDependencies\": {\n        \"polkadot-api\": \"*\"\n      }\n    }`,\n  )\n}\n\nasync function readWhitelist(filename: string): Promise<string[] | null> {\n  if (!(await fsExists(filename))) {\n    throw new Error(\"Whitelist file not found: \" + filename)\n  }\n\n  const tmpDir = await mkdtemp(join(tmpdir(), \"papi-\"))\n  try {\n    await build({\n      format: \"esm\",\n      entry: {\n        index: filename,\n      },\n      outDir: tmpDir,\n      outExtension() {\n        return { js: \".mjs\" }\n      },\n      silent: true,\n    })\n    const { whitelist } = await import(join(tmpDir, \"index.mjs\"))\n    return whitelist\n  } finally {\n    await rm(tmpDir, { recursive: true }).catch(console.error)\n  }\n}\n","import { readPapiConfig, writePapiConfig } from \"@/papiConfig\"\nimport { CommonOptions } from \"./commonOptions\"\n\nexport async function remove(key: string, options: CommonOptions) {\n  const entries = (await readPapiConfig(options.config)) ?? {}\n\n  if (!(key in entries)) {\n    throw new Error(`Key ${key} not set in polkadot-api config`)\n  }\n\n  const entry = entries[key]\n  delete entries[key]\n\n  await writePapiConfig(options.config, entries)\n  console.log(`Removed chain \"${key}\" from config`)\n}\n","import { getMetadata, writeMetadataToDisk } from \"@/metadata\"\nimport { EntryConfig, readPapiConfig } from \"@/papiConfig\"\nimport ora from \"ora\"\nimport { CommonOptions } from \"./commonOptions\"\nimport { generate } from \"./generate\"\n\nexport async function update(\n  keysInput: string | undefined,\n  options: CommonOptions,\n) {\n  const entries = (await readPapiConfig(options.config)) ?? {}\n  const keys =\n    keysInput === undefined ? Object.keys(entries) : keysInput.split(\",\")\n\n  const updateByKey = async (key: string) => {\n    if (!(key in entries)) {\n      throw new Error(`Key ${key} not set in polkadot-api config`)\n    }\n\n    // Exclude metadata file from the entry, otherwise getMetadata would load from the file\n    const { metadata: filename, ...entry } = entries[key]\n    if (!filename) {\n      if (keysInput !== undefined) {\n        console.warn(`Key ${key} doesn't have a metadata file to update`)\n      }\n\n      return\n    }\n\n    const metadata = await getMetadata(entry as EntryConfig)\n    // For those without other sources than metadata file, we get a null.\n    if (!metadata) {\n      if (keysInput !== undefined) {\n        console.warn(\n          `Key ${key} doesn't have any external source to update from`,\n        )\n      }\n      return\n    }\n\n    spinner.text = `Writing ${key} metadata`\n    await writeMetadataToDisk(metadata.metadataRaw, filename)\n    spinner.succeed(`${key} metadata updated`)\n  }\n\n  const spinner = ora(`Updating`).start()\n  await Promise.all(keys.map(updateByKey))\n\n  console.log(`Updating descriptors`)\n  await generate({ config: options.config })\n\n  spinner.stop()\n}\n"],"mappings":"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","names":["add","generate","remove","update","knownChains","metadataWorker","metadata","readFile","writeFile","fs","fs","fsExists","path","ora","metadata","ora"]}
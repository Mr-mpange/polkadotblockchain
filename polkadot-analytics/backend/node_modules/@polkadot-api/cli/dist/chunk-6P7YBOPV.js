// src/cli.ts
import { Option, program } from "@commander-js/extra-typings";
import * as knownChains from "@polkadot-api/known-chains";
function getCli({ add: add2, generate: generate2, remove: remove2, update: update2 }) {
  program.name("polkadot-api").description("Polkadot API CLI");
  const config = new Option("--config <filename>", "Source for the config file");
  program.command("generate", {
    isDefault: true
  }).description("Generate descriptor files").addOption(config).option("-k, --key <key>", "Key of the descriptor to generate").option(
    "--whitelist <filename>",
    "Use whitelist file to reduce descriptor size"
  ).action(generate2);
  program.command("add").description("Add a new chain spec to the list").argument("<key>", "Key identifier for the chain spec").addOption(config).option("-f, --file <filename>", "Source from metadata encoded file").option("-w, --wsUrl <URL>", "Source from websocket url").option("-c, --chainSpec <filename>", "Source from chain spec file").addOption(
    new Option("-n, --name <name>", "Source from a well-known chain").choices(
      Object.keys(knownChains)
    )
  ).option("--wasm <filename>", "Source from runtime wasm file").option("--no-persist", "Do not persist the metadata as a file").action(add2);
  program.command("update").description("Update the metadata files and generate descriptor files").argument(
    "[keys]",
    "Keys of the metadata files to update, separated by commas. Leave empty for all"
  ).addOption(config).action(update2);
  program.command("remove").description("Remove a chain spec from the list").argument("<key>", "Key identifier for the chain spec").addOption(config).action(remove2);
  return program;
}

// src/metadata.ts
import { createClient } from "@polkadot-api/substrate-client";
import * as fs from "node:fs/promises";
import { metadata, v15 } from "@polkadot-api/substrate-bindings";
import { WebSocketProvider } from "@polkadot-api/ws-provider/node";
import { Worker } from "node:worker_threads";
import { getObservableClient } from "@polkadot-api/observable-client";
import { filter, firstValueFrom } from "rxjs";
import { dirname } from "path";
import { fileURLToPath } from "url";
import * as knownChains2 from "@polkadot-api/known-chains";
var workerPath = fileURLToPath(import.meta.resolve("./metadataWorker.js"));
var metadataWorker;
var workerRefCount = 0;
async function getMetadataWorker() {
  if (!metadataWorker) {
    metadataWorker = new Worker(workerPath, {
      stdout: true,
      stderr: true
    });
    await new Promise((resolve) => {
      metadataWorker?.once("message", resolve);
      metadataWorker?.postMessage("ready");
    });
  }
  return metadataWorker;
}
var getMetadataCall = async (provider) => {
  const client = getObservableClient(createClient(provider));
  const { runtime$, unfollow } = client.chainHead$();
  const runtime = await firstValueFrom(runtime$.pipe(filter(Boolean)));
  unfollow();
  client.destroy();
  return { metadata: runtime.metadata, metadataRaw: runtime.metadataRaw };
};
var getWorkerMessage = (chain) => {
  if (!(chain in knownChains2)) {
    return {
      potentialRelayChainSpecs: [],
      chainSpec: chain
    };
  }
  const relayChainName = Object.keys(knownChains2).find(
    (c) => c !== chain && chain.startsWith(c)
  );
  const potentialRelayChainSpecs = relayChainName ? [knownChains2[relayChainName]] : [];
  const chainSpec = knownChains2[chain];
  return {
    potentialRelayChainSpecs,
    chainSpec
  };
};
var id = 0;
var getMetadataFromSmoldot = async (chain) => {
  workerRefCount++;
  try {
    const reqId = id++;
    const metadataWorker2 = await getMetadataWorker();
    const message = {
      ...getWorkerMessage(chain),
      id: reqId
    };
    const metadata2 = await new Promise((resolve) => {
      const listener = (data) => {
        if (data.id !== reqId)
          return;
        metadataWorker2.off("message", listener);
        resolve(data.metadata);
      };
      metadataWorker2.on("message", listener);
      metadataWorker2.postMessage(message);
    });
    return metadata2;
  } finally {
    workerRefCount--;
    if (workerRefCount === 0) {
      metadataWorker?.terminate();
      metadataWorker = null;
    }
  }
};
var getMetadataFromWsURL = async (wsURL) => getMetadataCall(WebSocketProvider(wsURL));
async function getMetadata(entry) {
  if (entry.metadata) {
    const data = await fs.readFile(entry.metadata);
    const metadataRaw = new Uint8Array(data);
    let meta;
    try {
      meta = metadata.dec(metadataRaw).metadata.value;
    } catch (_) {
      meta = v15.dec(metadataRaw);
    }
    return {
      metadata: meta,
      metadataRaw
    };
  }
  if ("chain" in entry) {
    return getMetadataFromSmoldot(entry.chain);
  }
  if ("chainSpec" in entry) {
    const chainSpec = await fs.readFile(entry.chainSpec, "utf8");
    return getMetadataFromSmoldot(chainSpec);
  }
  if ("wsUrl" in entry) {
    return getMetadataFromWsURL(entry.wsUrl);
  }
  return null;
}
async function writeMetadataToDisk(metadataRaw, outFile) {
  await fs.mkdir(dirname(outFile), { recursive: true });
  await fs.writeFile(outFile, metadataRaw);
}

// src/papiConfig.ts
import fsExists from "fs.promises.exists";
import { readPackage } from "read-pkg";
import { updatePackage } from "write-package";
import { readFile as readFile2, writeFile as writeFile2 } from "node:fs/promises";
var papiCfgDefaultFile = "polkadot-api.json";
var packageJsonKey = "polkadot-api";
async function readPapiConfig(configFile) {
  if (configFile)
    return readFromFile(configFile);
  const configFromDefaultFile = await readFromFile(papiCfgDefaultFile);
  if (configFromDefaultFile)
    return configFromDefaultFile;
  return readFromFile("package.json");
}
async function writePapiConfig(configFile, config) {
  if (configFile)
    return writeToFile(configFile, config);
  const defaultCfgExists = await fsExists(papiCfgDefaultFile);
  if (defaultCfgExists)
    return writeToFile(papiCfgDefaultFile, config);
  const packageCfg = await readFromFile("package.json");
  if (packageCfg) {
    return writeToFile("package.json", config);
  }
  return writeToFile(papiCfgDefaultFile, config);
}
async function readFromFile(file) {
  const fileExists = await fsExists(file);
  if (!fileExists)
    return null;
  if (file === "package.json") {
    const packageJson = await readPackage();
    return packageJson[packageJsonKey] ?? null;
  }
  return JSON.parse(await readFile2(file, "utf8"));
}
async function writeToFile(file, config) {
  if (file === "package.json") {
    await updatePackage({
      [packageJsonKey]: null
    });
    return updatePackage({
      [packageJsonKey]: config
    });
  }
  return writeFile2(file, JSON.stringify(config, null, 2));
}

// src/commands/add.ts
import { compactNumber } from "@polkadot-api/substrate-bindings";
import { fromHex } from "@polkadot-api/utils";
import { getMetadataFromRuntime } from "@polkadot-api/wasm-executor";
import * as fs2 from "node:fs/promises";
import ora from "ora";
async function add(key, options) {
  const entries = await readPapiConfig(options.config) ?? {};
  if (key in entries) {
    console.warn(`Replacing existing ${key} config`);
  }
  if (options.file) {
    entries[key] = {
      metadata: options.file
    };
  } else if (options.wasm) {
    const spinner = ora(`Loading metadata from runtime`).start();
    const metadataHex = (await fs2.readFile(options.wasm)).toString("hex");
    const opaqueMeta = fromHex(getMetadataFromRuntime(`0x${metadataHex}`));
    const metadataLen = compactNumber.dec(opaqueMeta);
    const compactLen = compactNumber.enc(metadataLen).length;
    if (opaqueMeta.length - compactLen !== metadataLen)
      throw new Error("Not able to retrieve runtime metadata");
    spinner.text = "Writing metadata";
    const metadataRaw = opaqueMeta.slice(compactLen);
    const filename = `${key}.scale`;
    await writeMetadataToDisk(metadataRaw, filename);
    spinner.succeed(`Metadata saved as ${filename}`);
    entries[key] = {
      metadata: filename
    };
  } else {
    const entry = entryFromOptions(options);
    entries[key] = entry;
    if (!options.noPersist) {
      const spinner = ora(`Loading metadata`).start();
      const { metadataRaw } = await getMetadata(entry);
      spinner.text = "Writing metadata";
      const filename = `${key}.scale`;
      await writeMetadataToDisk(metadataRaw, filename);
      spinner.succeed(`Metadata saved as ${filename}`);
      entry.metadata = filename;
    }
  }
  await writePapiConfig(options.config, entries);
  return console.log(`Saved new spec "${key}"`);
}
var entryFromOptions = (options) => {
  if (options.wsUrl) {
    return {
      wsUrl: options.wsUrl
    };
  }
  if (options.chainSpec) {
    return {
      chainSpec: options.chainSpec
    };
  }
  if (options.name) {
    return {
      chain: options.name
    };
  }
  throw new Error(
    "add command needs one source, specified by options -f -w -c or -n"
  );
};

// src/commands/generate.ts
import { generateMultipleDescriptors } from "@polkadot-api/codegen";
import fs3, { mkdtemp, rm } from "fs/promises";
import path, { join } from "path";
import process from "process";
import tsc from "tsc-prog";
import tsup, { build } from "tsup";
import fsExists2 from "fs.promises.exists";
import { existsSync } from "fs";
import { tmpdir } from "os";
async function generate(opts) {
  const sources = await getSources(opts);
  if (Object.keys(sources).length == 0) {
    console.log("No chains defined in config file");
  }
  console.log(`Reading metadata`);
  const chains = await Promise.all(
    Object.entries(sources).map(async ([key, source]) => ({
      key,
      metadata: (await getMetadata(source)).metadata,
      knownTypes: {}
    }))
  );
  const descriptorsDir = join(
    process.cwd(),
    "node_modules",
    "@polkadot-api",
    "descriptors"
  );
  const clientPath = opts.clientLibrary ?? "polkadot-api";
  if (existsSync(descriptorsDir))
    await fs3.rm(descriptorsDir, { recursive: true });
  await fs3.mkdir(descriptorsDir, { recursive: true });
  await generatePackageJson(join(descriptorsDir, "package.json"));
  const whitelist = opts.whitelist ? await readWhitelist(opts.whitelist) : null;
  await outputCodegen(
    chains,
    join(descriptorsDir, "src"),
    clientPath,
    whitelist
  );
  await compileCodegen(descriptorsDir);
  await fs3.rm(join(descriptorsDir, "src"), { recursive: true });
}
async function getSources(opts) {
  const config = await readPapiConfig(opts.config);
  if (!config) {
    throw new Error("Can't find the Polkadot-API configuration");
  }
  if (opts.key) {
    if (!config[opts.key]) {
      throw new Error(`Key ${opts.key} not set in polkadot-api config`);
    }
    return {
      [opts.key]: config[opts.key]
    };
  }
  return config;
}
async function outputCodegen(chains, outputFolder, clientPath, whitelist) {
  const {
    descriptorsFileContent,
    descriptorTypesFileContent,
    checksums,
    typesFileContent,
    publicTypes
  } = generateMultipleDescriptors(
    chains,
    {
      client: clientPath,
      checksums: "./checksums.json",
      types: "./common-types",
      descriptorValues: "./descriptors"
    },
    {
      whitelist: whitelist ?? void 0
    }
  );
  await fs3.mkdir(outputFolder, { recursive: true });
  await fs3.writeFile(
    path.join(outputFolder, "checksums.json"),
    JSON.stringify(checksums)
  );
  await fs3.writeFile(
    path.join(outputFolder, "descriptors.ts"),
    descriptorsFileContent
  );
  await fs3.writeFile(
    path.join(outputFolder, "common-types.ts"),
    typesFileContent
  );
  await Promise.all(
    chains.map(
      (chain, i) => fs3.writeFile(
        join(outputFolder, `${chain.key}.ts`),
        descriptorTypesFileContent[i]
      )
    )
  );
  await generateIndex(
    outputFolder,
    chains.map((chain) => chain.key),
    publicTypes
  );
}
async function compileCodegen(packageDir) {
  const srcDir = join(packageDir, "src");
  const outDir = join(packageDir, "dist");
  if (await fsExists2(outDir)) {
    await fs3.rm(outDir, { recursive: true });
  }
  await tsup.build({
    format: ["cjs", "esm"],
    entry: [path.join(srcDir, "index.ts")],
    outDir,
    outExtension: (ctx) => ({
      js: ctx.format === "esm" ? ".mjs" : ".js"
    })
  });
  tsc.build({
    basePath: srcDir,
    compilerOptions: {
      skipLibCheck: true,
      declaration: true,
      emitDeclarationOnly: true,
      target: "esnext",
      module: "esnext",
      moduleResolution: "node",
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      outDir
    }
  });
}
var generateIndex = async (path2, keys, publicTypes) => {
  const indexTs = [
    ...keys.flatMap((key) => [
      `export { default as ${key} } from "./${key}";`,
      `export type * from "./${key}";`
    ]),
    `export {`,
    publicTypes.join(", "),
    `} from './common-types';`
  ].join("\n");
  await fs3.writeFile(join(path2, "index.ts"), indexTs);
};
var generatePackageJson = async (path2) => {
  await fs3.writeFile(
    path2,
    `{
      "name": "@polkadot-api/descriptors",
      "exports": {
        ".": {
          "module": "./dist/index.mjs",
          "import": "./dist/index.mjs",
          "require": "./dist/index.js",
          "default": "./dist/index.js"
        },
        "./package.json": "./package.json"
      },
      "main": "./dist/index.js",
      "module": "./dist/index.mjs",
      "browser": "./dist/index.mjs",
      "types": "./dist/index.d.ts",
      "sideEffects": false,
      "peerDependencies": {
        "polkadot-api": "*"
      }
    }`
  );
};
async function readWhitelist(filename) {
  if (!await fsExists2(filename)) {
    throw new Error("Whitelist file not found: " + filename);
  }
  const tmpDir = await mkdtemp(join(tmpdir(), "papi-"));
  try {
    await build({
      format: "esm",
      entry: {
        index: filename
      },
      outDir: tmpDir,
      outExtension() {
        return { js: ".mjs" };
      },
      silent: true
    });
    const { whitelist } = await import(join(tmpDir, "index.mjs"));
    return whitelist;
  } finally {
    await rm(tmpDir, { recursive: true }).catch(console.error);
  }
}

// src/commands/remove.ts
async function remove(key, options) {
  const entries = await readPapiConfig(options.config) ?? {};
  if (!(key in entries)) {
    throw new Error(`Key ${key} not set in polkadot-api config`);
  }
  const entry = entries[key];
  delete entries[key];
  await writePapiConfig(options.config, entries);
  console.log(`Removed chain "${key}" from config`);
}

// src/commands/update.ts
import ora2 from "ora";
async function update(keysInput, options) {
  const entries = await readPapiConfig(options.config) ?? {};
  const keys = keysInput === void 0 ? Object.keys(entries) : keysInput.split(",");
  const updateByKey = async (key) => {
    if (!(key in entries)) {
      throw new Error(`Key ${key} not set in polkadot-api config`);
    }
    const { metadata: filename, ...entry } = entries[key];
    if (!filename) {
      if (keysInput !== void 0) {
        console.warn(`Key ${key} doesn't have a metadata file to update`);
      }
      return;
    }
    const metadata2 = await getMetadata(entry);
    if (!metadata2) {
      if (keysInput !== void 0) {
        console.warn(
          `Key ${key} doesn't have any external source to update from`
        );
      }
      return;
    }
    spinner.text = `Writing ${key} metadata`;
    await writeMetadataToDisk(metadata2.metadataRaw, filename);
    spinner.succeed(`${key} metadata updated`);
  };
  const spinner = ora2(`Updating`).start();
  await Promise.all(keys.map(updateByKey));
  console.log(`Updating descriptors`);
  await generate({ config: options.config });
  spinner.stop();
}

export {
  getCli,
  add,
  generate,
  remove,
  update
};
//# sourceMappingURL=chunk-6P7YBOPV.js.map
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  connectInjectedExtension: () => connectInjectedExtension,
  getInjectedExtensions: () => getInjectedExtensions
});
module.exports = __toCommonJS(src_exports);

// src/injected-extensions.ts
var import_substrate_bindings3 = require("@polkadot-api/substrate-bindings");

// src/from-pjs-account.ts
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");
var import_utils2 = require("@polkadot-api/utils");
var import_metadata_builders = require("@polkadot-api/metadata-builders");

// src/pjs-signed-extensions-mappers.ts
var pjs_signed_extensions_mappers_exports = {};
__export(pjs_signed_extensions_mappers_exports, {
  ChargeAssetTxPayment: () => ChargeAssetTxPayment,
  ChargeTransactionPayment: () => ChargeTransactionPayment,
  CheckGenesis: () => CheckGenesis,
  CheckMetadataHash: () => CheckMetadataHash,
  CheckMortality: () => CheckMortality,
  CheckNonce: () => CheckNonce,
  CheckSpecVersion: () => CheckSpecVersion,
  CheckTxVersion: () => CheckTxVersion
});
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var import_utils = require("@polkadot-api/utils");
var toPjsHex = (value, minByteLen) => {
  let inner = value.toString(16);
  inner = (inner.length % 2 ? "0" : "") + inner;
  const nPaddedBytes = Math.max(0, (minByteLen || 0) - inner.length / 2);
  return "0x" + "00".repeat(nPaddedBytes) + inner;
};
var CheckGenesis = ({
  additionalSigned
}) => ({
  genesisHash: (0, import_utils.toHex)(additionalSigned)
});
var CheckNonce = ({
  value
}) => {
  return { nonce: toPjsHex(import_substrate_bindings.compact.dec(value), 4) };
};
var CheckTxVersion = ({
  additionalSigned
}) => {
  return { transactionVersion: toPjsHex(import_substrate_bindings.u32.dec(additionalSigned), 4) };
};
var assetTxPaymentDec = (0, import_substrate_bindings.Struct)({
  tip: import_substrate_bindings.compact,
  asset: (0, import_substrate_bindings.Option)((0, import_substrate_bindings.Bytes)(Infinity))
}).dec;
var ChargeAssetTxPayment = ({
  value
}) => {
  const { tip, asset } = assetTxPaymentDec(value);
  return {
    ...asset ? { assetId: (0, import_utils.toHex)(asset) } : {},
    tip: toPjsHex(tip, 16)
  };
};
var ChargeTransactionPayment = ({
  value
}) => ({
  tip: toPjsHex(import_substrate_bindings.compactBn.dec(value), 16)
  // u128 => 16 bytes
});
var CheckMortality = ({ value, additionalSigned }, blockNumber) => ({
  era: (0, import_utils.toHex)(value),
  blockHash: (0, import_utils.toHex)(additionalSigned),
  blockNumber: toPjsHex(blockNumber, 4)
});
var CheckSpecVersion = ({
  additionalSigned
}) => ({
  specVersion: toPjsHex(import_substrate_bindings.u32.dec(additionalSigned), 4)
});
var CheckMetadataHash = () => ({});

// src/from-pjs-account.ts
var getAddressFormat = (metadata) => {
  const dynamicBuilder = (0, import_metadata_builders.getDynamicBuilder)(metadata);
  const constant = metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "SS58Prefix");
  return dynamicBuilder.buildDefinition(constant.type).dec(constant.value);
};
var versionCodec = (0, import_substrate_bindings2.enhanceEncoder)(
  import_substrate_bindings2.u8.enc,
  (value) => +!!value.signed << 7 | value.version
);
function getPolkadotSignerFromPjs(publicKey, signPayload) {
  const sign = async (callData, signedExtensions, metadata, atBlockNumber, _ = import_substrate_bindings2.Blake2256) => {
    let decMeta;
    try {
      const tmpMeta = import_substrate_bindings2.metadata.dec(metadata);
      if (tmpMeta.metadata.tag !== "v15")
        throw null;
      decMeta = tmpMeta.metadata.value;
    } catch (_2) {
      throw new Error("Unsupported metadata version");
    }
    const pjs = {};
    pjs.signedExtensions = [];
    const { version } = decMeta.extrinsic;
    const extra = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed-extension`);
      extra.push(signedExtension.value);
      pjs.signedExtensions.push(identifier);
      if (!pjs_signed_extensions_mappers_exports[identifier]) {
        if (signedExtension.value.length === 0 && signedExtension.additionalSigned.length === 0)
          return;
        throw new Error(
          `PJS does not support this signed-extension: ${identifier}`
        );
      }
      Object.assign(
        pjs,
        pjs_signed_extensions_mappers_exports[identifier](
          signedExtension,
          atBlockNumber
        )
      );
    });
    pjs.address = (0, import_substrate_bindings2.AccountId)(getAddressFormat(decMeta)).dec(publicKey);
    pjs.method = (0, import_utils2.toHex)(callData);
    pjs.version = version;
    const result = await signPayload(pjs);
    const preResult = (0, import_utils2.mergeUint8)(
      versionCodec({ signed: true, version }),
      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
      new Uint8Array([0, ...publicKey]),
      (0, import_utils2.fromHex)(result.signature),
      ...extra,
      callData
    );
    return (0, import_utils2.mergeUint8)(import_substrate_bindings2.compact.enc(preResult.length), preResult);
  };
  return { publicKey, sign };
}

// src/injected-extensions.ts
var supportedAccountTypes = /* @__PURE__ */ new Set([
  "ed25519",
  "sr25519",
  "ecdsa"
]);
var getPublicKey = (0, import_substrate_bindings3.AccountId)().enc;
var connectInjectedExtension = async (name) => {
  let entry = window.injectedWeb3?.[name];
  if (!entry)
    throw new Error(`Unavailable extension: "${name}"`);
  const enabledExtension = await entry.enable();
  const signPayload = enabledExtension.signer.signPayload.bind(
    enabledExtension.signer
  );
  const toPolkadotInjected = (accounts) => accounts.filter(({ type }) => supportedAccountTypes.has(type)).map((x) => {
    const polkadotSigner = getPolkadotSignerFromPjs(
      getPublicKey(x.address),
      signPayload
    );
    return {
      ...x,
      polkadotSigner
    };
  });
  let currentAccounts = toPolkadotInjected(
    await enabledExtension.accounts.get()
  );
  const listeners = /* @__PURE__ */ new Set();
  const stop = enabledExtension.accounts.subscribe((x) => {
    currentAccounts = toPolkadotInjected(x);
    listeners.forEach((cb) => {
      cb(currentAccounts);
    });
  });
  return {
    name,
    getAccounts: () => currentAccounts,
    subscribe: (cb) => {
      listeners.add(cb);
      return () => {
        listeners.delete(cb);
      };
    },
    disconnect: () => {
      stop();
    }
  };
};
var getInjectedExtensions = () => {
  const { injectedWeb3 } = window;
  return injectedWeb3 ? Object.keys(injectedWeb3) : null;
};
//# sourceMappingURL=index.js.map
{"version":3,"sources":["../../src/index.ts","../../src/injected-extensions.ts","../../src/from-pjs-account.ts","../../src/pjs-signed-extensions-mappers.ts"],"sourcesContent":["export type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nexport * from \"./injected-extensions\"\n","import { AccountId } from \"@polkadot-api/substrate-bindings\"\nimport { getPolkadotSignerFromPjs } from \"./from-pjs-account\"\nimport type { SignerPayloadJSON } from \"./types\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\n\ndeclare global {\n  interface Window {\n    injectedWeb3?: InjectedWeb3\n  }\n}\nexport type InjectedWeb3 = Record<\n  string,\n  | {\n      enable: () => Promise<PjsInjectedExtension>\n    }\n  | undefined\n>\n\nexport type KeypairType = \"ed25519\" | \"sr25519\" | \"ecdsa\"\nconst supportedAccountTypes = new Set<KeypairType>([\n  \"ed25519\",\n  \"sr25519\",\n  \"ecdsa\",\n])\n\ninterface InjectedAccount {\n  address: string\n  genesisHash?: string | null\n  name?: string\n  type?: KeypairType\n}\n\nexport interface InjectedPolkadotAccount {\n  polkadotSigner: PolkadotSigner\n  address: string\n  genesisHash?: string | null\n  name?: string\n  type?: KeypairType\n}\n\ninterface PjsInjectedExtension {\n  signer: {\n    signPayload: (payload: SignerPayloadJSON) => Promise<{ signature: string }>\n  }\n  accounts: {\n    get: () => Promise<InjectedPolkadotAccount[]>\n    subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => () => void\n  }\n}\n\nconst getPublicKey = AccountId().enc\n\nexport interface InjectedExtension {\n  name: string\n  getAccounts: () => InjectedPolkadotAccount[]\n  subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => () => void\n  disconnect: () => void\n}\n\nexport const connectInjectedExtension = async (\n  name: string,\n): Promise<InjectedExtension> => {\n  let entry = window.injectedWeb3?.[name]\n\n  if (!entry) throw new Error(`Unavailable extension: \"${name}\"`)\n\n  const enabledExtension = await entry.enable()\n  const signPayload = enabledExtension.signer.signPayload.bind(\n    enabledExtension.signer,\n  )\n\n  const toPolkadotInjected = (\n    accounts: InjectedAccount[],\n  ): InjectedPolkadotAccount[] =>\n    accounts\n      .filter(({ type }) => supportedAccountTypes.has(type!))\n      .map((x) => {\n        const polkadotSigner = getPolkadotSignerFromPjs(\n          getPublicKey(x.address),\n          signPayload,\n        )\n        return {\n          ...x,\n          polkadotSigner,\n        }\n      })\n\n  let currentAccounts: InjectedPolkadotAccount[] = toPolkadotInjected(\n    await enabledExtension.accounts.get(),\n  )\n\n  const listeners = new Set<(accounts: InjectedPolkadotAccount[]) => void>()\n  const stop = enabledExtension.accounts.subscribe((x) => {\n    currentAccounts = toPolkadotInjected(x)\n    listeners.forEach((cb) => {\n      cb(currentAccounts)\n    })\n  })\n\n  return {\n    name,\n    getAccounts: () => currentAccounts,\n    subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => {\n      listeners.add(cb)\n      return () => {\n        listeners.delete(cb)\n      }\n    },\n    disconnect: () => {\n      stop()\n    },\n  }\n}\n\nexport const getInjectedExtensions = (): null | Array<string> => {\n  const { injectedWeb3 } = window\n  return injectedWeb3 ? Object.keys(injectedWeb3) : null\n}\n","import {\n  AccountId,\n  Blake2256,\n  V15,\n  compact,\n  enhanceEncoder,\n  metadata as metadataCodec,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getDynamicBuilder } from \"@polkadot-api/metadata-builders\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport * as signedExtensionMappers from \"./pjs-signed-extensions-mappers\"\nimport { SignerPayloadJSON } from \"./types\"\n\nexport const getAddressFormat = (metadata: V15): number => {\n  const dynamicBuilder = getDynamicBuilder(metadata)\n\n  const constant = metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"SS58Prefix\")!\n\n  return dynamicBuilder.buildDefinition(constant.type).dec(constant.value)\n}\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nexport function getPolkadotSignerFromPjs(\n  publicKey: Uint8Array,\n  signPayload: (payload: SignerPayloadJSON) => Promise<{ signature: string }>,\n): PolkadotSigner {\n  const sign = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    atBlockNumber: number,\n    _ = Blake2256,\n  ) => {\n    let decMeta: V15\n    try {\n      const tmpMeta = metadataCodec.dec(metadata)\n      if (tmpMeta.metadata.tag !== \"v15\") throw null\n      decMeta = tmpMeta.metadata.value\n    } catch (_) {\n      throw new Error(\"Unsupported metadata version\")\n    }\n\n    const pjs: Partial<SignerPayloadJSON> = {}\n    pjs.signedExtensions = []\n\n    const { version } = decMeta.extrinsic\n    const extra: Array<Uint8Array> = []\n\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed-extension`)\n      extra.push(signedExtension.value)\n\n      pjs.signedExtensions!.push(identifier)\n\n      if (!signedExtensionMappers[identifier as \"CheckMortality\"]) {\n        if (\n          signedExtension.value.length === 0 &&\n          signedExtension.additionalSigned.length === 0\n        )\n          return\n        throw new Error(\n          `PJS does not support this signed-extension: ${identifier}`,\n        )\n      }\n\n      Object.assign(\n        pjs,\n        signedExtensionMappers[identifier as \"CheckMortality\"](\n          signedExtension,\n          atBlockNumber,\n        ),\n      )\n    })\n\n    pjs.address = AccountId(getAddressFormat(decMeta)).dec(publicKey)\n    pjs.method = toHex(callData)\n    pjs.version = version\n\n    const result = await signPayload(pjs as SignerPayloadJSON)\n\n    const preResult = mergeUint8(\n      versionCodec({ signed: true, version }),\n      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n      new Uint8Array([0, ...publicKey]),\n      fromHex(result.signature),\n      ...extra,\n      callData,\n    )\n\n    return mergeUint8(compact.enc(preResult.length), preResult)\n  }\n\n  return { publicKey, sign }\n}\n","import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  Bytes,\n  Struct,\n  compact,\n  u32,\n  Option,\n  compactBn,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\n\ntype SignedExtension = {\n  value: Uint8Array\n  additionalSigned: Uint8Array\n}\n\nconst toPjsHex = (value: number | bigint, minByteLen?: number) => {\n  let inner = value.toString(16)\n  inner = (inner.length % 2 ? \"0\" : \"\") + inner\n  const nPaddedBytes = Math.max(0, (minByteLen || 0) - inner.length / 2)\n  return \"0x\" + \"00\".repeat(nPaddedBytes) + inner\n}\n\nexport const CheckGenesis = ({\n  additionalSigned,\n}: SignedExtension): { genesisHash: string } => ({\n  genesisHash: toHex(additionalSigned),\n})\n\nexport const CheckNonce = ({\n  value,\n}: SignedExtension): { nonce: HexString } => {\n  // nonce is a u32 in pjs => 4 bytes\n  return { nonce: toPjsHex(compact.dec(value), 4) }\n}\n\nexport const CheckTxVersion = ({\n  additionalSigned,\n}: SignedExtension): { transactionVersion: HexString } => {\n  return { transactionVersion: toPjsHex(u32.dec(additionalSigned), 4) }\n}\n\nconst assetTxPaymentDec = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n}).dec\n\nexport const ChargeAssetTxPayment = ({\n  value,\n}: SignedExtension): { aseetId?: string; tip?: string } => {\n  const { tip, asset } = assetTxPaymentDec(value)\n\n  return {\n    ...(asset ? { assetId: toHex(asset) } : {}),\n    tip: toPjsHex(tip, 16),\n  }\n}\n\nexport const ChargeTransactionPayment = ({\n  value,\n}: SignedExtension): { tip: HexString } => ({\n  tip: toPjsHex(compactBn.dec(value), 16), // u128 => 16 bytes\n})\n\nexport const CheckMortality = (\n  { value, additionalSigned }: SignedExtension,\n  blockNumber: number,\n): { era: HexString; blockHash: HexString; blockNumber: HexString } => ({\n  era: toHex(value),\n  blockHash: toHex(additionalSigned),\n  blockNumber: toPjsHex(blockNumber, 4),\n})\n\nexport const CheckSpecVersion = ({\n  additionalSigned,\n}: SignedExtension): { specVersion: HexString } => ({\n  specVersion: toPjsHex(u32.dec(additionalSigned), 4),\n})\n\n// we create the tx without metadata hash, it's optional for PJS\nexport const CheckMetadataHash = () => ({})\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,8BAAAE,EAAA,0BAAAC,IAAA,eAAAC,EAAAJ,GCAA,IAAAK,EAA0B,4CCA1B,IAAAC,EAQO,4CACPC,EAA2C,+BAC3CC,EAAkC,2CCVlC,IAAAC,EAAA,GAAAC,EAAAD,EAAA,0BAAAE,EAAA,6BAAAC,EAAA,iBAAAC,EAAA,sBAAAC,EAAA,mBAAAC,EAAA,eAAAC,EAAA,qBAAAC,EAAA,mBAAAC,IACA,IAAAC,EAOO,4CACPC,EAAsB,+BAOhBC,EAAW,CAACC,EAAwBC,IAAwB,CAChE,IAAIC,EAAQF,EAAM,SAAS,EAAE,EAC7BE,GAASA,EAAM,OAAS,EAAI,IAAM,IAAMA,EACxC,IAAMC,EAAe,KAAK,IAAI,GAAIF,GAAc,GAAKC,EAAM,OAAS,CAAC,EACrE,MAAO,KAAO,KAAK,OAAOC,CAAY,EAAID,CAC5C,EAEaX,EAAe,CAAC,CAC3B,iBAAAa,CACF,KAAiD,CAC/C,eAAa,SAAMA,CAAgB,CACrC,GAEaV,EAAa,CAAC,CACzB,MAAAM,CACF,KAES,CAAE,MAAOD,EAAS,UAAQ,IAAIC,CAAK,EAAG,CAAC,CAAE,GAGrCJ,EAAiB,CAAC,CAC7B,iBAAAQ,CACF,KACS,CAAE,mBAAoBL,EAAS,MAAI,IAAIK,CAAgB,EAAG,CAAC,CAAE,GAGhEC,KAAoB,UAAO,CAC/B,IAAK,UACL,SAAO,aAAO,SAAM,GAAQ,CAAC,CAC/B,CAAC,EAAE,IAEUhB,EAAuB,CAAC,CACnC,MAAAW,CACF,IAA2D,CACzD,GAAM,CAAE,IAAAM,EAAK,MAAAC,CAAM,EAAIF,EAAkBL,CAAK,EAE9C,MAAO,CACL,GAAIO,EAAQ,CAAE,WAAS,SAAMA,CAAK,CAAE,EAAI,CAAC,EACzC,IAAKR,EAASO,EAAK,EAAE,CACvB,CACF,EAEahB,EAA2B,CAAC,CACvC,MAAAU,CACF,KAA4C,CAC1C,IAAKD,EAAS,YAAU,IAAIC,CAAK,EAAG,EAAE,CACxC,GAEaP,EAAiB,CAC5B,CAAE,MAAAO,EAAO,iBAAAI,CAAiB,EAC1BI,KACsE,CACtE,OAAK,SAAMR,CAAK,EAChB,aAAW,SAAMI,CAAgB,EACjC,YAAaL,EAASS,EAAa,CAAC,CACtC,GAEab,EAAmB,CAAC,CAC/B,iBAAAS,CACF,KAAoD,CAClD,YAAaL,EAAS,MAAI,IAAIK,CAAgB,EAAG,CAAC,CACpD,GAGaZ,EAAoB,KAAO,CAAC,GDjElC,IAAMiB,EAAoBC,GAA0B,CACzD,IAAMC,KAAiB,qBAAkBD,CAAQ,EAE3CE,EAAWF,EAAS,QACvB,KAAMG,GAAMA,EAAE,OAAS,QAAQ,EAC/B,UAAW,KAAM,GAAM,EAAE,OAAS,YAAY,EAEjD,OAAOF,EAAe,gBAAgBC,EAAS,IAAI,EAAE,IAAIA,EAAS,KAAK,CACzE,EAEME,KAAe,kBACnB,KAAG,IACFC,GACE,CAAC,CAAC,CAACA,EAAM,QAAU,EAAKA,EAAM,OACnC,EAEO,SAASC,EACdC,EACAC,EACgB,CA4EhB,MAAO,CAAE,UAAAD,EAAW,KA3EP,MACXE,EACAC,EAQAV,EACAW,EACAC,EAAI,cACD,CACH,IAAIC,EACJ,GAAI,CACF,IAAMC,EAAU,EAAAC,SAAc,IAAIf,CAAQ,EAC1C,GAAIc,EAAQ,SAAS,MAAQ,MAAO,MAAM,KAC1CD,EAAUC,EAAQ,SAAS,KAC7B,MAAY,CACV,MAAM,IAAI,MAAM,8BAA8B,CAChD,CAEA,IAAME,EAAkC,CAAC,EACzCA,EAAI,iBAAmB,CAAC,EAExB,GAAM,CAAE,QAAAC,CAAQ,EAAIJ,EAAQ,UACtBK,EAA2B,CAAC,EAElCL,EAAQ,UAAU,iBAAiB,IAAI,CAAC,CAAE,WAAAM,CAAW,IAAM,CACzD,IAAMC,EAAkBV,EAAiBS,CAAU,EACnD,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,WAAWD,CAAU,mBAAmB,EAK1D,GAJAD,EAAM,KAAKE,EAAgB,KAAK,EAEhCJ,EAAI,iBAAkB,KAAKG,CAAU,EAEjC,CAACE,EAAuBF,CAA8B,EAAG,CAC3D,GACEC,EAAgB,MAAM,SAAW,GACjCA,EAAgB,iBAAiB,SAAW,EAE5C,OACF,MAAM,IAAI,MACR,+CAA+CD,CAAU,EAC3D,CACF,CAEA,OAAO,OACLH,EACAK,EAAuBF,CAA8B,EACnDC,EACAT,CACF,CACF,CACF,CAAC,EAEDK,EAAI,WAAU,aAAUjB,EAAiBc,CAAO,CAAC,EAAE,IAAIN,CAAS,EAChES,EAAI,UAAS,SAAMP,CAAQ,EAC3BO,EAAI,QAAUC,EAEd,IAAMK,EAAS,MAAMd,EAAYQ,CAAwB,EAEnDO,KAAY,cAChBnB,EAAa,CAAE,OAAQ,GAAM,QAAAa,CAAQ,CAAC,EAEtC,IAAI,WAAW,CAAC,EAAG,GAAGV,CAAS,CAAC,KAChC,WAAQe,EAAO,SAAS,EACxB,GAAGJ,EACHT,CACF,EAEA,SAAO,cAAW,UAAQ,IAAIc,EAAU,MAAM,EAAGA,CAAS,CAC5D,CAEyB,CAC3B,CD5FA,IAAMC,EAAwB,IAAI,IAAiB,CACjD,UACA,UACA,OACF,CAAC,EA2BKC,KAAe,aAAU,EAAE,IASpBC,EAA2B,MACtCC,GAC+B,CAC/B,IAAIC,EAAQ,OAAO,eAAeD,CAAI,EAEtC,GAAI,CAACC,EAAO,MAAM,IAAI,MAAM,2BAA2BD,CAAI,GAAG,EAE9D,IAAME,EAAmB,MAAMD,EAAM,OAAO,EACtCE,EAAcD,EAAiB,OAAO,YAAY,KACtDA,EAAiB,MACnB,EAEME,EACJC,GAEAA,EACG,OAAO,CAAC,CAAE,KAAAC,CAAK,IAAMT,EAAsB,IAAIS,CAAK,CAAC,EACrD,IAAKC,GAAM,CACV,IAAMC,EAAiBC,EACrBX,EAAaS,EAAE,OAAO,EACtBJ,CACF,EACA,MAAO,CACL,GAAGI,EACH,eAAAC,CACF,CACF,CAAC,EAEDE,EAA6CN,EAC/C,MAAMF,EAAiB,SAAS,IAAI,CACtC,EAEMS,EAAY,IAAI,IAChBC,EAAOV,EAAiB,SAAS,UAAWK,GAAM,CACtDG,EAAkBN,EAAmBG,CAAC,EACtCI,EAAU,QAASE,GAAO,CACxBA,EAAGH,CAAe,CACpB,CAAC,CACH,CAAC,EAED,MAAO,CACL,KAAAV,EACA,YAAa,IAAMU,EACnB,UAAYG,IACVF,EAAU,IAAIE,CAAE,EACT,IAAM,CACXF,EAAU,OAAOE,CAAE,CACrB,GAEF,WAAY,IAAM,CAChBD,EAAK,CACP,CACF,CACF,EAEaE,EAAwB,IAA4B,CAC/D,GAAM,CAAE,aAAAC,CAAa,EAAI,OACzB,OAAOA,EAAe,OAAO,KAAKA,CAAY,EAAI,IACpD","names":["src_exports","__export","connectInjectedExtension","getInjectedExtensions","__toCommonJS","import_substrate_bindings","import_substrate_bindings","import_utils","import_metadata_builders","pjs_signed_extensions_mappers_exports","__export","ChargeAssetTxPayment","ChargeTransactionPayment","CheckGenesis","CheckMetadataHash","CheckMortality","CheckNonce","CheckSpecVersion","CheckTxVersion","import_substrate_bindings","import_utils","toPjsHex","value","minByteLen","inner","nPaddedBytes","additionalSigned","assetTxPaymentDec","tip","asset","blockNumber","getAddressFormat","metadata","dynamicBuilder","constant","x","versionCodec","value","getPolkadotSignerFromPjs","publicKey","signPayload","callData","signedExtensions","atBlockNumber","_","decMeta","tmpMeta","metadataCodec","pjs","version","extra","identifier","signedExtension","pjs_signed_extensions_mappers_exports","result","preResult","supportedAccountTypes","getPublicKey","connectInjectedExtension","name","entry","enabledExtension","signPayload","toPolkadotInjected","accounts","type","x","polkadotSigner","getPolkadotSignerFromPjs","currentAccounts","listeners","stop","cb","getInjectedExtensions","injectedWeb3"]}
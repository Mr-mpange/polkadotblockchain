{"version":3,"sources":["../src/index.ts","../src/injected-extensions.ts","../src/from-pjs-account.ts","../src/pjs-signed-extensions-mappers.ts"],"sourcesContent":["export type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nexport * from \"./injected-extensions\"\n","import { AccountId } from \"@polkadot-api/substrate-bindings\"\nimport { getPolkadotSignerFromPjs } from \"./from-pjs-account\"\nimport type { SignerPayloadJSON } from \"./types\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\n\ndeclare global {\n  interface Window {\n    injectedWeb3?: InjectedWeb3\n  }\n}\nexport type InjectedWeb3 = Record<\n  string,\n  | {\n      enable: () => Promise<PjsInjectedExtension>\n    }\n  | undefined\n>\n\nexport type KeypairType = \"ed25519\" | \"sr25519\" | \"ecdsa\"\nconst supportedAccountTypes = new Set<KeypairType>([\n  \"ed25519\",\n  \"sr25519\",\n  \"ecdsa\",\n])\n\ninterface InjectedAccount {\n  address: string\n  genesisHash?: string | null\n  name?: string\n  type?: KeypairType\n}\n\nexport interface InjectedPolkadotAccount {\n  polkadotSigner: PolkadotSigner\n  address: string\n  genesisHash?: string | null\n  name?: string\n  type?: KeypairType\n}\n\ninterface PjsInjectedExtension {\n  signer: {\n    signPayload: (payload: SignerPayloadJSON) => Promise<{ signature: string }>\n  }\n  accounts: {\n    get: () => Promise<InjectedPolkadotAccount[]>\n    subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => () => void\n  }\n}\n\nconst getPublicKey = AccountId().enc\n\nexport interface InjectedExtension {\n  name: string\n  getAccounts: () => InjectedPolkadotAccount[]\n  subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => () => void\n  disconnect: () => void\n}\n\nexport const connectInjectedExtension = async (\n  name: string,\n): Promise<InjectedExtension> => {\n  let entry = window.injectedWeb3?.[name]\n\n  if (!entry) throw new Error(`Unavailable extension: \"${name}\"`)\n\n  const enabledExtension = await entry.enable()\n  const signPayload = enabledExtension.signer.signPayload.bind(\n    enabledExtension.signer,\n  )\n\n  const toPolkadotInjected = (\n    accounts: InjectedAccount[],\n  ): InjectedPolkadotAccount[] =>\n    accounts\n      .filter(({ type }) => supportedAccountTypes.has(type!))\n      .map((x) => {\n        const polkadotSigner = getPolkadotSignerFromPjs(\n          getPublicKey(x.address),\n          signPayload,\n        )\n        return {\n          ...x,\n          polkadotSigner,\n        }\n      })\n\n  let currentAccounts: InjectedPolkadotAccount[] = toPolkadotInjected(\n    await enabledExtension.accounts.get(),\n  )\n\n  const listeners = new Set<(accounts: InjectedPolkadotAccount[]) => void>()\n  const stop = enabledExtension.accounts.subscribe((x) => {\n    currentAccounts = toPolkadotInjected(x)\n    listeners.forEach((cb) => {\n      cb(currentAccounts)\n    })\n  })\n\n  return {\n    name,\n    getAccounts: () => currentAccounts,\n    subscribe: (cb: (accounts: InjectedPolkadotAccount[]) => void) => {\n      listeners.add(cb)\n      return () => {\n        listeners.delete(cb)\n      }\n    },\n    disconnect: () => {\n      stop()\n    },\n  }\n}\n\nexport const getInjectedExtensions = (): null | Array<string> => {\n  const { injectedWeb3 } = window\n  return injectedWeb3 ? Object.keys(injectedWeb3) : null\n}\n","import {\n  AccountId,\n  Blake2256,\n  V15,\n  compact,\n  enhanceEncoder,\n  metadata as metadataCodec,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport { getDynamicBuilder } from \"@polkadot-api/metadata-builders\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport * as signedExtensionMappers from \"./pjs-signed-extensions-mappers\"\nimport { SignerPayloadJSON } from \"./types\"\n\nexport const getAddressFormat = (metadata: V15): number => {\n  const dynamicBuilder = getDynamicBuilder(metadata)\n\n  const constant = metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"SS58Prefix\")!\n\n  return dynamicBuilder.buildDefinition(constant.type).dec(constant.value)\n}\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nexport function getPolkadotSignerFromPjs(\n  publicKey: Uint8Array,\n  signPayload: (payload: SignerPayloadJSON) => Promise<{ signature: string }>,\n): PolkadotSigner {\n  const sign = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    atBlockNumber: number,\n    _ = Blake2256,\n  ) => {\n    let decMeta: V15\n    try {\n      const tmpMeta = metadataCodec.dec(metadata)\n      if (tmpMeta.metadata.tag !== \"v15\") throw null\n      decMeta = tmpMeta.metadata.value\n    } catch (_) {\n      throw new Error(\"Unsupported metadata version\")\n    }\n\n    const pjs: Partial<SignerPayloadJSON> = {}\n    pjs.signedExtensions = []\n\n    const { version } = decMeta.extrinsic\n    const extra: Array<Uint8Array> = []\n\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed-extension`)\n      extra.push(signedExtension.value)\n\n      pjs.signedExtensions!.push(identifier)\n\n      if (!signedExtensionMappers[identifier as \"CheckMortality\"]) {\n        if (\n          signedExtension.value.length === 0 &&\n          signedExtension.additionalSigned.length === 0\n        )\n          return\n        throw new Error(\n          `PJS does not support this signed-extension: ${identifier}`,\n        )\n      }\n\n      Object.assign(\n        pjs,\n        signedExtensionMappers[identifier as \"CheckMortality\"](\n          signedExtension,\n          atBlockNumber,\n        ),\n      )\n    })\n\n    pjs.address = AccountId(getAddressFormat(decMeta)).dec(publicKey)\n    pjs.method = toHex(callData)\n    pjs.version = version\n\n    const result = await signPayload(pjs as SignerPayloadJSON)\n\n    const preResult = mergeUint8(\n      versionCodec({ signed: true, version }),\n      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n      new Uint8Array([0, ...publicKey]),\n      fromHex(result.signature),\n      ...extra,\n      callData,\n    )\n\n    return mergeUint8(compact.enc(preResult.length), preResult)\n  }\n\n  return { publicKey, sign }\n}\n","import { HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  Bytes,\n  Struct,\n  compact,\n  u32,\n  Option,\n  compactBn,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\n\ntype SignedExtension = {\n  value: Uint8Array\n  additionalSigned: Uint8Array\n}\n\nconst toPjsHex = (value: number | bigint, minByteLen?: number) => {\n  let inner = value.toString(16)\n  inner = (inner.length % 2 ? \"0\" : \"\") + inner\n  const nPaddedBytes = Math.max(0, (minByteLen || 0) - inner.length / 2)\n  return \"0x\" + \"00\".repeat(nPaddedBytes) + inner\n}\n\nexport const CheckGenesis = ({\n  additionalSigned,\n}: SignedExtension): { genesisHash: string } => ({\n  genesisHash: toHex(additionalSigned),\n})\n\nexport const CheckNonce = ({\n  value,\n}: SignedExtension): { nonce: HexString } => {\n  // nonce is a u32 in pjs => 4 bytes\n  return { nonce: toPjsHex(compact.dec(value), 4) }\n}\n\nexport const CheckTxVersion = ({\n  additionalSigned,\n}: SignedExtension): { transactionVersion: HexString } => {\n  return { transactionVersion: toPjsHex(u32.dec(additionalSigned), 4) }\n}\n\nconst assetTxPaymentDec = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n}).dec\n\nexport const ChargeAssetTxPayment = ({\n  value,\n}: SignedExtension): { aseetId?: string; tip?: string } => {\n  const { tip, asset } = assetTxPaymentDec(value)\n\n  return {\n    ...(asset ? { assetId: toHex(asset) } : {}),\n    tip: toPjsHex(tip, 16),\n  }\n}\n\nexport const ChargeTransactionPayment = ({\n  value,\n}: SignedExtension): { tip: HexString } => ({\n  tip: toPjsHex(compactBn.dec(value), 16), // u128 => 16 bytes\n})\n\nexport const CheckMortality = (\n  { value, additionalSigned }: SignedExtension,\n  blockNumber: number,\n): { era: HexString; blockHash: HexString; blockNumber: HexString } => ({\n  era: toHex(value),\n  blockHash: toHex(additionalSigned),\n  blockNumber: toPjsHex(blockNumber, 4),\n})\n\nexport const CheckSpecVersion = ({\n  additionalSigned,\n}: SignedExtension): { specVersion: HexString } => ({\n  specVersion: toPjsHex(u32.dec(additionalSigned), 4),\n})\n\n// we create the tx without metadata hash, it's optional for PJS\nexport const CheckMetadataHash = () => ({})\n"],"mappings":"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","names":["import_substrate_bindings","import_substrate_bindings","import_utils","metadataCodec","_"]}
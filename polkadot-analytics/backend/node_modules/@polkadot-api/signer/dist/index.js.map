{"version":3,"sources":["../src/index.ts","../src/from-raw-signer.ts"],"sourcesContent":["export * from \"./from-raw-signer\"\n","import {\n  Blake2256,\n  V15,\n  compact,\n  enhanceEncoder,\n  metadata as metadataCodec,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nconst signingTypeId: Record<\"Ecdsa\" | \"Ed25519\" | \"Sr25519\", number> = {\n  Ed25519: 0,\n  Sr25519: 1,\n  Ecdsa: 2,\n}\n\nexport function getPolkadotSigner(\n  publicKey: Uint8Array,\n  signingType: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n  sign: (input: Uint8Array) => Promise<Uint8Array> | Uint8Array,\n): PolkadotSigner {\n  const polkadotSign = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    _: number,\n    hasher = Blake2256,\n  ) => {\n    let decMeta: V15\n    try {\n      const tmpMeta = metadataCodec.dec(metadata)\n      if (tmpMeta.metadata.tag !== \"v15\") throw null\n      decMeta = tmpMeta.metadata.value\n    } catch (_) {\n      throw new Error(\"Unsupported metadata version\")\n    }\n\n    const { version } = decMeta.extrinsic\n    const extra: Array<Uint8Array> = []\n    const additionalSigned: Array<Uint8Array> = []\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed extension`)\n      extra.push(signedExtension.value)\n      additionalSigned.push(signedExtension.additionalSigned)\n    })\n\n    const toSign = mergeUint8(callData, ...extra, ...additionalSigned)\n\n    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign)\n\n    const preResult = mergeUint8(\n      versionCodec({ signed: true, version }),\n      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n      new Uint8Array([0, ...publicKey]),\n      new Uint8Array([signingTypeId[signingType], ...signed]),\n      ...extra,\n      callData,\n    )\n\n    return mergeUint8(compact.enc(preResult.length), preResult)\n  }\n\n  return { publicKey, sign: polkadotSign }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,gCAOO;AACP,mBAA2B;AAG3B,IAAM,mBAAe;AAAA,EACnB,6BAAG;AAAA,EACH,CAAC,UACE,CAAC,CAAC,CAAC,MAAM,UAAU,IAAK,MAAM;AACnC;AAEA,IAAM,gBAAiE;AAAA,EACrE,SAAS;AAAA,EACT,SAAS;AAAA,EACT,OAAO;AACT;AAEO,SAAS,kBACd,WACA,aACA,MACgB;AAChB,QAAM,eAAe,OACnB,UACA,kBAQA,UACA,GACA,SAAS,wCACN;AACH,QAAI;AACJ,QAAI;AACF,YAAM,UAAU,0BAAAA,SAAc,IAAI,QAAQ;AAC1C,UAAI,QAAQ,SAAS,QAAQ;AAAO,cAAM;AAC1C,gBAAU,QAAQ,SAAS;AAAA,IAC7B,SAASC,IAAG;AACV,YAAM,IAAI,MAAM,8BAA8B;AAAA,IAChD;AAEA,UAAM,EAAE,QAAQ,IAAI,QAAQ;AAC5B,UAAM,QAA2B,CAAC;AAClC,UAAM,mBAAsC,CAAC;AAC7C,YAAQ,UAAU,iBAAiB,IAAI,CAAC,EAAE,WAAW,MAAM;AACzD,YAAM,kBAAkB,iBAAiB,UAAU;AACnD,UAAI,CAAC;AACH,cAAM,IAAI,MAAM,WAAW,UAAU,mBAAmB;AAC1D,YAAM,KAAK,gBAAgB,KAAK;AAChC,uBAAiB,KAAK,gBAAgB,gBAAgB;AAAA,IACxD,CAAC;AAED,UAAM,aAAS,yBAAW,UAAU,GAAG,OAAO,GAAG,gBAAgB;AAEjE,UAAM,SAAS,MAAM,KAAK,OAAO,SAAS,MAAM,OAAO,MAAM,IAAI,MAAM;AAEvE,UAAM,gBAAY;AAAA,MAChB,aAAa,EAAE,QAAQ,MAAM,QAAQ,CAAC;AAAA;AAAA,MAEtC,IAAI,WAAW,CAAC,GAAG,GAAG,SAAS,CAAC;AAAA,MAChC,IAAI,WAAW,CAAC,cAAc,WAAW,GAAG,GAAG,MAAM,CAAC;AAAA,MACtD,GAAG;AAAA,MACH;AAAA,IACF;AAEA,eAAO,yBAAW,kCAAQ,IAAI,UAAU,MAAM,GAAG,SAAS;AAAA,EAC5D;AAEA,SAAO,EAAE,WAAW,MAAM,aAAa;AACzC;","names":["metadataCodec","_"]}
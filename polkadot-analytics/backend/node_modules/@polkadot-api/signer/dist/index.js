"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  getPolkadotSigner: () => getPolkadotSigner
});
module.exports = __toCommonJS(src_exports);

// src/from-raw-signer.ts
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var import_utils = require("@polkadot-api/utils");
var versionCodec = (0, import_substrate_bindings.enhanceEncoder)(
  import_substrate_bindings.u8.enc,
  (value) => +!!value.signed << 7 | value.version
);
var signingTypeId = {
  Ed25519: 0,
  Sr25519: 1,
  Ecdsa: 2
};
function getPolkadotSigner(publicKey, signingType, sign) {
  const polkadotSign = async (callData, signedExtensions, metadata, _, hasher = import_substrate_bindings.Blake2256) => {
    let decMeta;
    try {
      const tmpMeta = import_substrate_bindings.metadata.dec(metadata);
      if (tmpMeta.metadata.tag !== "v15")
        throw null;
      decMeta = tmpMeta.metadata.value;
    } catch (_2) {
      throw new Error("Unsupported metadata version");
    }
    const { version } = decMeta.extrinsic;
    const extra = [];
    const additionalSigned = [];
    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {
      const signedExtension = signedExtensions[identifier];
      if (!signedExtension)
        throw new Error(`Missing ${identifier} signed extension`);
      extra.push(signedExtension.value);
      additionalSigned.push(signedExtension.additionalSigned);
    });
    const toSign = (0, import_utils.mergeUint8)(callData, ...extra, ...additionalSigned);
    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign);
    const preResult = (0, import_utils.mergeUint8)(
      versionCodec({ signed: true, version }),
      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`
      new Uint8Array([0, ...publicKey]),
      new Uint8Array([signingTypeId[signingType], ...signed]),
      ...extra,
      callData
    );
    return (0, import_utils.mergeUint8)(import_substrate_bindings.compact.enc(preResult.length), preResult);
  };
  return { publicKey, sign: polkadotSign };
}
//# sourceMappingURL=index.js.map
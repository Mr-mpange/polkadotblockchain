{"version":3,"sources":["../../src/index.ts","../../src/from-raw-signer.ts"],"sourcesContent":["export * from \"./from-raw-signer\"\n","import {\n  Blake2256,\n  V15,\n  compact,\n  enhanceEncoder,\n  metadata as metadataCodec,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { mergeUint8 } from \"@polkadot-api/utils\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\n\nconst versionCodec = enhanceEncoder(\n  u8.enc,\n  (value: { signed: boolean; version: number }) =>\n    (+!!value.signed << 7) | value.version,\n)\n\nconst signingTypeId: Record<\"Ecdsa\" | \"Ed25519\" | \"Sr25519\", number> = {\n  Ed25519: 0,\n  Sr25519: 1,\n  Ecdsa: 2,\n}\n\nexport function getPolkadotSigner(\n  publicKey: Uint8Array,\n  signingType: \"Ecdsa\" | \"Ed25519\" | \"Sr25519\",\n  sign: (input: Uint8Array) => Promise<Uint8Array> | Uint8Array,\n): PolkadotSigner {\n  const polkadotSign = async (\n    callData: Uint8Array,\n    signedExtensions: Record<\n      string,\n      {\n        identifier: string\n        value: Uint8Array\n        additionalSigned: Uint8Array\n      }\n    >,\n    metadata: Uint8Array,\n    _: number,\n    hasher = Blake2256,\n  ) => {\n    let decMeta: V15\n    try {\n      const tmpMeta = metadataCodec.dec(metadata)\n      if (tmpMeta.metadata.tag !== \"v15\") throw null\n      decMeta = tmpMeta.metadata.value\n    } catch (_) {\n      throw new Error(\"Unsupported metadata version\")\n    }\n\n    const { version } = decMeta.extrinsic\n    const extra: Array<Uint8Array> = []\n    const additionalSigned: Array<Uint8Array> = []\n    decMeta.extrinsic.signedExtensions.map(({ identifier }) => {\n      const signedExtension = signedExtensions[identifier]\n      if (!signedExtension)\n        throw new Error(`Missing ${identifier} signed extension`)\n      extra.push(signedExtension.value)\n      additionalSigned.push(signedExtension.additionalSigned)\n    })\n\n    const toSign = mergeUint8(callData, ...extra, ...additionalSigned)\n\n    const signed = await sign(toSign.length > 256 ? hasher(toSign) : toSign)\n\n    const preResult = mergeUint8(\n      versionCodec({ signed: true, version }),\n      // converting it to a `MultiAddress` enum, where the index 0 is `Id(AccountId)`\n      new Uint8Array([0, ...publicKey]),\n      new Uint8Array([signingTypeId[signingType], ...signed]),\n      ...extra,\n      callData,\n    )\n\n    return mergeUint8(compact.enc(preResult.length), preResult)\n  }\n\n  return { publicKey, sign: polkadotSign }\n}\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,uBAAAE,IAAA,eAAAC,EAAAH,GCAA,IAAAI,EAOO,4CACPC,EAA2B,+BAGrBC,KAAe,kBACnB,KAAG,IACFC,GACE,CAAC,CAAC,CAACA,EAAM,QAAU,EAAKA,EAAM,OACnC,EAEMC,EAAiE,CACrE,QAAS,EACT,QAAS,EACT,MAAO,CACT,EAEO,SAASC,EACdC,EACAC,EACAC,EACgB,CAmDhB,MAAO,CAAE,UAAAF,EAAW,KAlDC,MACnBG,EACAC,EAQAC,EACAC,EACAC,EAAS,cACN,CACH,IAAIC,EACJ,GAAI,CACF,IAAMC,EAAU,EAAAC,SAAc,IAAIL,CAAQ,EAC1C,GAAII,EAAQ,SAAS,MAAQ,MAAO,MAAM,KAC1CD,EAAUC,EAAQ,SAAS,KAC7B,MAAY,CACV,MAAM,IAAI,MAAM,8BAA8B,CAChD,CAEA,GAAM,CAAE,QAAAE,CAAQ,EAAIH,EAAQ,UACtBI,EAA2B,CAAC,EAC5BC,EAAsC,CAAC,EAC7CL,EAAQ,UAAU,iBAAiB,IAAI,CAAC,CAAE,WAAAM,CAAW,IAAM,CACzD,IAAMC,EAAkBX,EAAiBU,CAAU,EACnD,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,WAAWD,CAAU,mBAAmB,EAC1DF,EAAM,KAAKG,EAAgB,KAAK,EAChCF,EAAiB,KAAKE,EAAgB,gBAAgB,CACxD,CAAC,EAED,IAAMC,KAAS,cAAWb,EAAU,GAAGS,EAAO,GAAGC,CAAgB,EAE3DI,EAAS,MAAMf,EAAKc,EAAO,OAAS,IAAMT,EAAOS,CAAM,EAAIA,CAAM,EAEjEE,KAAY,cAChBtB,EAAa,CAAE,OAAQ,GAAM,QAAAe,CAAQ,CAAC,EAEtC,IAAI,WAAW,CAAC,EAAG,GAAGX,CAAS,CAAC,EAChC,IAAI,WAAW,CAACF,EAAcG,CAAW,EAAG,GAAGgB,CAAM,CAAC,EACtD,GAAGL,EACHT,CACF,EAEA,SAAO,cAAW,UAAQ,IAAIe,EAAU,MAAM,EAAGA,CAAS,CAC5D,CAEuC,CACzC","names":["src_exports","__export","getPolkadotSigner","__toCommonJS","import_substrate_bindings","import_utils","versionCodec","value","signingTypeId","getPolkadotSigner","publicKey","signingType","sign","callData","signedExtensions","metadata","_","hasher","decMeta","tmpMeta","metadataCodec","version","extra","additionalSigned","identifier","signedExtension","toSign","signed","preResult"]}
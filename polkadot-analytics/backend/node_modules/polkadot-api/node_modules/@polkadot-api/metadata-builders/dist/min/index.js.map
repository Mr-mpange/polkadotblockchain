{"version":3,"sources":["../../src/index.ts","../../src/lookups.ts","../../src/dynamic-builder.ts","../../src/with-cache.ts","../../src/checksum-builder.ts","../../src/lookup-graph.ts"],"sourcesContent":["export * from \"./lookups\"\nexport * from \"./dynamic-builder\"\nexport * from \"./checksum-builder\"\n","import type { StringRecord, V14Lookup } from \"@polkadot-api/substrate-bindings\"\n\nexport type MetadataPrimitives =\n  | \"bool\"\n  | \"char\"\n  | \"str\"\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"u128\"\n  | \"u256\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"i128\"\n  | \"i256\"\n\nexport type PrimitiveVar = {\n  type: \"primitive\"\n  value: MetadataPrimitives\n}\n\nexport type VoidVar = { type: \"void\" }\nexport type CompactVar = { type: \"compact\"; isBig: boolean | null }\nexport type BitSequenceVar = { type: \"bitSequence\" }\nexport type AccountId32 = { type: \"AccountId32\" }\nexport type AccountId20 = { type: \"AccountId20\" }\nexport type TerminalVar =\n  | PrimitiveVar\n  | VoidVar\n  | CompactVar\n  | BitSequenceVar\n  | AccountId32\n  | AccountId20\n\n/* Array-like vars:\n * - TupleVar: Mixed types, fixed length\n * - Sequence: One type, arbitrary length\n * - Array: One type, fixed length\n */\nexport type TupleVar = {\n  type: \"tuple\"\n  value: LookupEntry[]\n  innerDocs: Array<string[]>\n}\nexport type StructVar = {\n  type: \"struct\"\n  value: StringRecord<LookupEntry>\n  innerDocs: StringRecord<string[]>\n}\nexport type EnumVar = {\n  type: \"enum\"\n  value: StringRecord<\n    (\n      | { type: \"lookupEntry\"; value: LookupEntry }\n      | VoidVar\n      | TupleVar\n      | StructVar\n      | ArrayVar\n    ) & { idx: number }\n  >\n  innerDocs: StringRecord<string[]>\n}\nexport type OptionVar = {\n  type: \"option\"\n  value: LookupEntry\n}\nexport type ResultVar = {\n  type: \"result\"\n  value: { ok: LookupEntry; ko: LookupEntry }\n}\nexport type SequenceVar = {\n  type: \"sequence\"\n  value: LookupEntry\n}\nexport type ArrayVar = {\n  type: \"array\"\n  value: LookupEntry\n  len: number\n}\n\nexport type ComposedVar =\n  | TupleVar\n  | StructVar\n  | SequenceVar\n  | ArrayVar\n  | OptionVar\n  | ResultVar\n  | EnumVar\n\nexport type Var = TerminalVar | ComposedVar\n\nexport type LookupEntry = {\n  id: number\n} & Var\n\nconst isBytes = (value: LookupEntry, nBytes: number) =>\n  value.type === \"array\" &&\n  value.len === nBytes &&\n  value.value.type === \"primitive\" &&\n  value.value.value === \"u8\"\n\nexport const getLookupFn = (lookupData: V14Lookup) => {\n  const lookups = new Map<number, LookupEntry>()\n  const from = new Set<number>()\n\n  const withCache = (\n    fn: (id: number) => Var,\n  ): ((id: number) => LookupEntry) => {\n    return (id) => {\n      let entry = lookups.get(id)\n\n      if (entry) return entry\n\n      if (from.has(id)) {\n        const entry = {\n          id,\n        } as LookupEntry\n\n        lookups.set(id, entry)\n        return entry\n      }\n\n      from.add(id)\n      const value = fn(id)\n      entry = lookups.get(id)\n\n      if (entry) {\n        Object.assign(entry, value)\n      } else {\n        entry = {\n          id,\n          ...value,\n        }\n        lookups.set(id, entry!)\n      }\n      from.delete(id)\n      return entry\n    }\n  }\n\n  let isAccountId32SearchOn = true\n  let isAccountId20SearchOn = true\n  const getLookupEntryDef = withCache((id): Var => {\n    const { def, path, params } = lookupData[id]\n\n    if (def.tag === \"composite\") {\n      if (def.value.length === 0) return { type: \"void\" }\n\n      // used to be a \"pointer\"\n      if (def.value.length === 1) {\n        const inner = getLookupEntryDef(def.value[0].type as number)\n\n        if (\n          isAccountId32SearchOn &&\n          path.at(-1) === \"AccountId32\" &&\n          isBytes(inner, 32)\n        ) {\n          isAccountId32SearchOn = false\n          return { type: \"AccountId32\" }\n        }\n\n        if (\n          isAccountId20SearchOn &&\n          path.at(-1) === \"AccountId20\" &&\n          isBytes(inner, 20)\n        ) {\n          isAccountId20SearchOn = false\n          return { type: \"AccountId20\" }\n        }\n\n        return inner\n      }\n\n      let allKey = true\n\n      const values: Record<string | number, LookupEntry> = {}\n      const innerDocs: Record<string | number, string[]> = {}\n      def.value.forEach((x, idx) => {\n        allKey = allKey && !!x.name\n        const key = x.name || idx\n        values[key] = getLookupEntryDef(x.type)\n        innerDocs[key] = x.docs\n      })\n\n      return allKey\n        ? {\n            type: \"struct\",\n            value: values as StringRecord<LookupEntry>,\n            innerDocs: innerDocs as StringRecord<string[]>,\n          }\n        : {\n            type: \"tuple\",\n            value: Object.values(values),\n            innerDocs: Object.values(innerDocs),\n          }\n    }\n\n    if (def.tag === \"variant\") {\n      if (\n        path.length === 1 &&\n        path[0] === \"Option\" &&\n        params.length === 1 &&\n        params[0].name === \"T\"\n      ) {\n        const value = getLookupEntryDef(params[0].type!)\n        return value.type === \"void\"\n          ? // Option<void> would return a Codec<undefined> which makes no sense\n            // Therefore, we better treat it as a bool\n            { type: \"primitive\", value: \"bool\" }\n          : {\n              type: \"option\",\n              value,\n            }\n      }\n\n      if (\n        path.length === 1 &&\n        path[0] === \"Result\" &&\n        params.length === 2 &&\n        params[0].name === \"T\" &&\n        params[1].name === \"E\"\n      ) {\n        return {\n          type: \"result\",\n          value: {\n            ok: getLookupEntryDef(params[0].type as number),\n            ko: getLookupEntryDef(params[1].type as number),\n          },\n        }\n      }\n      if (def.value.length === 0) return { type: \"void\" }\n\n      const enumValue: StringRecord<EnumVar[\"value\"][keyof EnumVar[\"value\"]]> =\n        {}\n      const enumDocs: StringRecord<string[]> = {}\n\n      def.value.forEach((x) => {\n        const key = x.name\n        enumDocs[key] = x.docs\n\n        if (x.fields.length === 0) {\n          enumValue[key] = { type: \"void\", idx: x.index }\n          return\n        }\n\n        if (x.fields.length === 1 && !x.fields[0].name) {\n          enumValue[key] = {\n            type: \"lookupEntry\",\n            value: getLookupEntryDef(x.fields[0].type),\n            idx: x.index,\n          }\n          return\n        }\n\n        let allKey = true\n\n        const values: Record<string | number, LookupEntry> = {}\n        const innerDocs: Record<string | number, string[]> = {}\n\n        x.fields.forEach((x, idx) => {\n          allKey = allKey && !!x.name\n          const key = x.name || idx\n          values[key] = getLookupEntryDef(x.type as number)\n          innerDocs[key] = x.docs\n        })\n\n        if (allKey) {\n          enumValue[key] = {\n            type: \"struct\",\n            value: values as StringRecord<LookupEntry>,\n            innerDocs: innerDocs as StringRecord<string[]>,\n            idx: x.index,\n          }\n        } else {\n          const valuesArr = Object.values(values)\n          const innerDocsArr = Object.values(innerDocs)\n          const areAllSame = valuesArr.every((v) => v.id === valuesArr[0].id)\n          enumValue[key] =\n            areAllSame && innerDocsArr.every((doc) => doc.length === 0)\n              ? {\n                  type: \"array\",\n                  value: valuesArr[0],\n                  len: valuesArr.length,\n                  idx: x.index,\n                }\n              : {\n                  type: \"tuple\",\n                  value: valuesArr,\n                  innerDocs: innerDocsArr,\n                  idx: x.index,\n                }\n        }\n      })\n\n      return {\n        type: \"enum\",\n        value: enumValue,\n        innerDocs: enumDocs,\n      }\n    }\n\n    if (def.tag === \"sequence\") {\n      const value = getLookupEntryDef(def.value as number)\n      return {\n        type: \"sequence\",\n        value,\n      }\n    }\n\n    if (def.tag === \"array\") {\n      const { len } = def.value\n      const value = getLookupEntryDef(def.value.type)\n\n      if (len === 0) return { type: \"void\" }\n      if (len === 1) return value\n\n      return {\n        type: \"array\",\n        value,\n        len: def.value.len,\n      }\n    }\n\n    if (def.tag === \"tuple\") {\n      if (def.value.length === 0) return { type: \"void\" }\n\n      // use to be a \"pointer\"\n      if (def.value.length === 1)\n        return getLookupEntryDef(def.value[0] as number)\n\n      const value = def.value.map((x) => getLookupEntryDef(x as number))\n      const innerDocs = def.value.map((x) => lookupData[x].docs)\n\n      const areAllSame = value.every((v) => v.id === value[0].id)\n      if (areAllSame && innerDocs.every((doc) => doc.length === 0)) {\n        return {\n          type: \"array\",\n          value: value[0],\n          len: value.length,\n        }\n      }\n\n      return {\n        type: \"tuple\",\n        value,\n        innerDocs,\n      }\n    }\n\n    if (def.tag === \"primitive\") {\n      return {\n        type: \"primitive\",\n        value: def.value.tag,\n      }\n    }\n\n    if (def.tag === \"compact\") {\n      const translated = getLookupEntryDef(def.value) as PrimitiveVar | VoidVar\n      if (translated.type === \"void\") return { type: \"compact\", isBig: null }\n\n      const isBig = Number(translated.value.slice(1)) > 32\n\n      return {\n        type: \"compact\",\n        isBig,\n      }\n    }\n\n    // bitSequence\n    return {\n      type: def.tag,\n    }\n  })\n\n  return getLookupEntryDef\n}\n","import type {\n  Codec,\n  StringRecord,\n  V15,\n  V14,\n} from \"@polkadot-api/substrate-bindings\"\nimport type { EnumVar, LookupEntry, TupleVar } from \"./lookups\"\nimport { getLookupFn } from \"./lookups\"\nimport * as scale from \"@polkadot-api/substrate-bindings\"\nimport { withCache } from \"./with-cache\"\nimport { mapObject } from \"@polkadot-api/utils\"\n\nconst _bytes = scale.Bin()\n\nconst _buildCodec = (\n  input: LookupEntry,\n  cache: Map<number, Codec<any>>,\n  stack: Set<number>,\n  _accountId: Codec<scale.SS58String>,\n): Codec<any> => {\n  if (input.type === \"primitive\") return scale[input.value]\n  if (input.type === \"void\") return scale._void\n  if (input.type === \"AccountId32\") return _accountId\n  if (input.type === \"AccountId20\") return scale.ethAccount\n  if (input.type === \"compact\") return scale.compact\n  if (input.type === \"bitSequence\") return scale.bitSequence\n\n  const buildNextCodec = (nextInput: LookupEntry): Codec<any> =>\n    buildCodec(nextInput, cache, stack, _accountId)\n\n  const buildVector = (inner: LookupEntry, len?: number) => {\n    const innerCodec = buildNextCodec(inner)\n    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec)\n  }\n\n  const buildTuple = (value: LookupEntry[]) =>\n    scale.Tuple(...value.map(buildNextCodec))\n\n  const buildStruct = (value: StringRecord<LookupEntry>) => {\n    const inner = Object.fromEntries(\n      Object.entries(value).map(([key, value]) => [key, buildNextCodec(value)]),\n    ) as StringRecord<Codec<any>>\n    return scale.Struct(inner)\n  }\n\n  if (\n    input.type === \"sequence\" &&\n    input.value.type === \"primitive\" &&\n    input.value.value === \"u8\"\n  ) {\n    return _bytes\n  }\n\n  if (input.type === \"array\") {\n    // Bytes case\n    if (input.value.type === \"primitive\" && input.value.value === \"u8\")\n      return scale.Bin(input.len)\n\n    return buildVector(input.value, input.len)\n  }\n\n  if (input.type === \"sequence\") return buildVector(input.value)\n  if (input.type === \"tuple\") return buildTuple(input.value)\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\") return scale.Option(buildNextCodec(input.value))\n\n  if (input.type === \"result\")\n    return scale.Result(\n      buildNextCodec(input.value.ok),\n      buildNextCodec(input.value.ko),\n    )\n\n  // it has to be an enum by now\n  const dependencies = Object.values(input.value).map((v) => {\n    switch (v.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildNextCodec(v.value)\n      case \"tuple\":\n        return buildTuple(v.value)\n      case \"struct\":\n        return buildStruct(v.value)\n      case \"array\":\n        return buildVector(v.value, v.len)\n    }\n  })\n\n  const inner = Object.fromEntries(\n    Object.keys(input.value).map((key, idx) => {\n      return [key, dependencies[idx]]\n    }),\n  ) as StringRecord<Codec<any>>\n\n  const indexes = Object.values(input.value).map((x) => x.idx)\n  const areIndexesSorted = indexes.every((idx, i) => idx === i)\n\n  return areIndexesSorted\n    ? scale.Variant(inner)\n    : scale.Variant(inner, indexes as any)\n}\nconst buildCodec = withCache(_buildCodec, scale.Self, (res) => res)\n\nexport const getDynamicBuilder = (metadata: V14 | V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  let _accountId = scale.AccountId()\n\n  const cache = new Map()\n  const buildDefinition = (id: number): Codec<any> =>\n    buildCodec(getLookupEntryDef(id), cache, new Set(), _accountId)\n\n  const prefix = metadata.pallets\n    .find((x) => x.name === \"System\")\n    ?.constants.find((x) => x.name === \"SS58Prefix\")\n\n  let ss58Prefix: number | undefined\n  if (prefix) {\n    try {\n      const prefixVal = buildDefinition(prefix.type).dec(prefix.value)\n      if (typeof prefixVal === \"number\") {\n        ss58Prefix = prefixVal\n        _accountId = scale.AccountId(prefixVal)\n      }\n    } catch (_) {}\n  }\n\n  const storagePallets = new Map<string, ReturnType<typeof scale.Storage>>()\n\n  const buildStorage = (pallet: string, entry: string) => {\n    let storagePallet = storagePallets.get(pallet)\n    if (!storagePallet)\n      storagePallets.set(pallet, (storagePallet = scale.Storage(pallet)))\n\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .storage!.items.find((s) => s.name === entry)!\n\n    const storageWithFallback = (\n      len: number,\n      ...args: Parameters<ReturnType<typeof scale.Storage>>\n    ) => {\n      const result = storagePallet!(...args)\n      return {\n        ...result,\n        len,\n        fallback:\n          storageEntry.modifier === 1\n            ? result.dec(storageEntry.fallback)\n            : undefined,\n      }\n    }\n\n    if (storageEntry.type.tag === \"plain\")\n      return storageWithFallback(\n        0,\n        entry,\n        buildDefinition(storageEntry.type.value).dec,\n      )\n\n    const { key, value, hashers } = storageEntry.type.value\n    const val = buildDefinition(value)\n    const hashes = hashers.map((x) => scale[x.tag])\n\n    const hashArgs: Array<scale.EncoderWithHash<any>> =\n      hashes.length === 1\n        ? [[buildDefinition(key), hashes[0]]]\n        : (getLookupEntryDef(key) as TupleVar).value.map(\n            (x, idx): scale.EncoderWithHash<any> => [\n              buildDefinition(x.id),\n              hashes[idx],\n            ],\n          )\n    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs)\n  }\n\n  const buildEnumEntry = (\n    entry: EnumVar[\"value\"][keyof EnumVar[\"value\"]],\n  ): Codec<any> => {\n    switch (entry.type) {\n      case \"void\":\n        return scale._void\n      case \"lookupEntry\":\n        return buildDefinition(entry.value.id)\n      case \"tuple\":\n        return scale.Tuple(\n          ...Object.values(entry.value).map((l) => buildDefinition(l.id)),\n        )\n      case \"struct\":\n        return scale.Struct(\n          mapObject(entry.value, (x) => buildDefinition(x.id)) as StringRecord<\n            Codec<any>\n          >,\n        )\n      case \"array\":\n        return scale.Vector(buildDefinition(entry.value.id), entry.len)\n    }\n  }\n\n  const buildConstant = (pallet: string, constantName: string) => {\n    const storageEntry = metadata.pallets\n      .find((x) => x.name === pallet)!\n      .constants!.find((s) => s.name === constantName)!\n\n    return buildDefinition(storageEntry.type as number)\n  }\n\n  const buildVariant =\n    (type: \"errors\" | \"events\" | \"calls\") =>\n    (\n      pallet: string,\n      name: string,\n    ): {\n      codec: Codec<any>\n      location: [number, number]\n    } => {\n      const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n      const lookup = getLookupEntryDef(palletEntry[type]!)\n      if (lookup.type !== \"enum\") throw null\n      const entry = lookup.value[name]\n\n      return {\n        location: [palletEntry.index, entry.idx],\n        codec: buildEnumEntry(lookup.value[name]),\n      }\n    }\n\n  const buildRuntimeCall = (api: string, method: string) => {\n    const entry = metadata.apis\n      .find((x) => x.name === api)\n      ?.methods.find((x) => x.name === method)\n    if (!entry) throw null\n\n    return {\n      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),\n      value: buildDefinition(entry.output),\n    }\n  }\n\n  return {\n    buildDefinition,\n    buildStorage,\n    buildEvent: buildVariant(\"events\"),\n    buildError: buildVariant(\"errors\"),\n    buildRuntimeCall,\n    buildCall: buildVariant(\"calls\"),\n    buildConstant,\n    ss58Prefix,\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\ntype FnWithStack<Other extends Array<any>, T> = (\n  input: LookupEntry,\n  cache: Map<number, T>,\n  stack: Set<number>,\n  ...rest: Other\n) => T\n\nexport const withCache =\n  <Other extends Array<any>, T>(\n    fn: FnWithStack<Other, T>,\n    onEnterCircular: (\n      cacheGetter: () => T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n    onExitCircular: (\n      outter: T,\n      inner: T,\n      circular: LookupEntry,\n      ...rest: Other\n    ) => T,\n  ): FnWithStack<Other, T> =>\n  (input, cache, stack, ...rest) => {\n    const { id } = input\n    if (cache.has(id)) return cache.get(id)!\n\n    if (stack.has(id)) {\n      const res = onEnterCircular(() => cache.get(id)!, input, ...rest)\n      cache.set(id, res)\n      return res\n    }\n\n    stack.add(id)\n    let result = fn(input, cache, stack, ...rest)\n    stack.delete(id)\n\n    if (cache.has(id))\n      result = onExitCircular(result, cache.get(id)!, input, ...rest)\n\n    cache.set(id, result)\n    return result\n  }\n","import type { StringRecord, V14, V15 } from \"@polkadot-api/substrate-bindings\"\nimport { h64 } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ArrayVar,\n  LookupEntry,\n  MetadataPrimitives,\n  StructVar,\n  TupleVar,\n  VoidVar,\n  getLookupFn,\n} from \"./lookups\"\nimport {\n  LookupGraph,\n  buildLookupGraph,\n  getStronglyConnectedComponents,\n  getSubgraph,\n  mergeSCCsWithCommonNodes,\n} from \"./lookup-graph\"\n\nconst textEncoder = new TextEncoder()\nconst encodeText = textEncoder.encode.bind(textEncoder)\n\nconst getChecksum = (values: Array<bigint>) => {\n  const res = new Uint8Array(values.length * 8)\n  const dv = new DataView(res.buffer)\n\n  for (let i = 0; i < values.length; i++) dv.setBigUint64(i * 8, values[i])\n\n  return h64(res)\n}\nconst getStringChecksum = (values: Array<string>) =>\n  getChecksum(values.map((v) => h64(encodeText(v))))\n\ntype Shape =\n  | \"primitive\"\n  | \"void\"\n  | \"vector\"\n  | \"tuple\"\n  | \"struct\"\n  | \"option\"\n  | \"result\"\n  | \"enum\"\nconst shapeIds: Record<Shape, bigint> = {\n  primitive: 0n,\n  vector: 1n,\n  tuple: 2n,\n  struct: 3n,\n  option: 4n,\n  result: 5n,\n  enum: 6n,\n  void: 7n,\n}\n\ntype RuntimePrimitives =\n  | \"undefined\"\n  | \"number\"\n  | \"string\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"bitSequence\"\n  | \"byteSequence\"\n  | \"accountId32\"\n  | \"accountId20\"\n\nconst runtimePrimitiveIds: Record<RuntimePrimitives, bigint> = {\n  undefined: 0n,\n  number: 1n,\n  string: 2n,\n  bigint: 3n,\n  boolean: 4n,\n  bitSequence: 5n, // {bitsLen: number, bytes: Uint8Array}\n  byteSequence: 6n, // Binary\n  accountId32: 7n, // SS58String\n  accountId20: 8n, // EthAccount\n}\n\nconst metadataPrimitiveIds: Record<MetadataPrimitives, bigint> = {\n  bool: runtimePrimitiveIds.boolean,\n  char: runtimePrimitiveIds.string,\n  str: runtimePrimitiveIds.string,\n  u8: runtimePrimitiveIds.number,\n  u16: runtimePrimitiveIds.number,\n  u32: runtimePrimitiveIds.number,\n  u64: runtimePrimitiveIds.bigint,\n  u128: runtimePrimitiveIds.bigint,\n  u256: runtimePrimitiveIds.bigint,\n  i8: runtimePrimitiveIds.number,\n  i16: runtimePrimitiveIds.number,\n  i32: runtimePrimitiveIds.number,\n  i64: runtimePrimitiveIds.bigint,\n  i128: runtimePrimitiveIds.bigint,\n  i256: runtimePrimitiveIds.bigint,\n}\n\nconst structLikeBuilder = <T>(\n  shapeId: bigint,\n  input: StringRecord<T>,\n  innerChecksum: (value: T) => bigint,\n) => {\n  const sortedEntries = Object.entries(input).sort(([a], [b]) =>\n    a.localeCompare(b),\n  )\n  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key))\n  const valuesChecksum = getChecksum(\n    sortedEntries.map(([, entry]) => innerChecksum(entry)),\n  )\n\n  return getChecksum([shapeId, keysChecksum, valuesChecksum])\n}\n\nconst _buildChecksum = (\n  input: LookupEntry,\n  buildNextChecksum: (entry: LookupEntry) => bigint,\n): bigint => {\n  if (input.type === \"primitive\")\n    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]])\n\n  if (input.type === \"void\") return getChecksum([shapeIds.void])\n\n  if (input.type === \"compact\")\n    return getChecksum([\n      shapeIds.primitive,\n      runtimePrimitiveIds[\n        input.isBig || input.isBig === null ? \"bigint\" : \"number\"\n      ],\n    ])\n\n  if (input.type === \"bitSequence\")\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence])\n\n  if (input.type === \"AccountId32\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId32])\n  }\n\n  if (input.type === \"AccountId20\") {\n    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId20])\n  }\n\n  const buildVector = (entry: LookupEntry, length?: number) => {\n    const innerChecksum = buildNextChecksum(entry)\n    return getChecksum(\n      length !== undefined\n        ? [shapeIds.vector, innerChecksum, BigInt(length)]\n        : [shapeIds.vector, innerChecksum],\n    )\n  }\n\n  if (input.type === \"array\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([\n        shapeIds.primitive,\n        runtimePrimitiveIds.byteSequence,\n        BigInt(input.len),\n      ])\n    }\n    return buildVector(innerValue, input.len)\n  }\n\n  if (input.type === \"sequence\") {\n    const innerValue = input.value\n    if (innerValue.type === \"primitive\" && innerValue.value === \"u8\") {\n      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence])\n    }\n    return buildVector(innerValue)\n  }\n\n  const buildTuple = (entries: LookupEntry[]) =>\n    getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)])\n\n  const buildStruct = (entries: StringRecord<LookupEntry>) =>\n    structLikeBuilder(shapeIds.struct, entries, buildNextChecksum)\n\n  if (input.type === \"tuple\") return buildTuple(input.value)\n\n  if (input.type === \"struct\") return buildStruct(input.value)\n\n  if (input.type === \"option\")\n    return getChecksum([shapeIds.option, buildNextChecksum(input.value)])\n\n  if (input.type === \"result\")\n    return getChecksum([\n      shapeIds.result,\n      buildNextChecksum(input.value.ok),\n      buildNextChecksum(input.value.ko),\n    ])\n\n  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {\n    if (entry.type === \"lookupEntry\") return buildNextChecksum(entry.value)\n    switch (entry.type) {\n      case \"void\":\n        return getChecksum([shapeIds.void])\n      case \"tuple\":\n        return buildTuple(entry.value)\n      case \"struct\":\n        return buildStruct(entry.value)\n      case \"array\":\n        return buildVector(entry.value, entry.len)\n    }\n  })\n}\n\nconst sortCyclicGroups = (groups: Array<Set<number>>, graph: LookupGraph) => {\n  const getReachableNodes = (group: Set<number>) => {\n    const result = new Set<number>()\n    const toVisit = Array.from(group)\n    while (toVisit.length) {\n      const id = toVisit.pop()!\n      if (result.has(id)) continue\n      result.add(id)\n\n      graph.get(id)?.refs.forEach((id) => toVisit.push(id))\n    }\n\n    return Array.from(result)\n  }\n\n  const result: Array<Set<number>> = new Array()\n\n  function dependentsFirst(group: Set<number>) {\n    if (result.includes(group)) return\n    const dependents = groups.filter(\n      (candidate) =>\n        candidate !== group &&\n        getReachableNodes(group).some((node) => candidate.has(node)),\n    )\n    dependents.forEach((group) => dependentsFirst(group))\n    if (result.includes(group)) return\n    result.push(group)\n  }\n\n  groups.forEach((group) => dependentsFirst(group))\n  return result\n}\n\nfunction iterateChecksums(\n  group: Set<number>,\n  iterations: number,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) {\n  // Keep the values that are getting changed on each iteration in a separate\n  // cache, because two nodes referencing the same one should read the same\n  // previous iteration checksum for that node.\n  const groupReadCache = new Map([...group].map((id) => [id, 0n]))\n  const groupWriteCache = new Map<number, bigint>()\n\n  const recursiveBuildChecksum = (\n    entry: LookupEntry,\n    // The first call has to skip the cache, otherwise it would return the\n    // previous iteration result.\n    skipCache = true,\n  ): bigint => {\n    if (!skipCache && (groupReadCache.has(entry.id) || cache.has(entry.id))) {\n      return groupReadCache.get(entry.id) ?? cache.get(entry.id)!\n    }\n    const result = _buildChecksum(entry, (nextEntry) =>\n      recursiveBuildChecksum(nextEntry, false),\n    )\n    if (group.has(entry.id)) {\n      groupWriteCache.set(entry.id, result)\n    } else {\n      cache.set(entry.id, result)\n    }\n    return result\n  }\n\n  for (let i = 0; i < iterations; i++) {\n    group.forEach((id) => recursiveBuildChecksum(graph.get(id)!.entry))\n\n    group.forEach((id) => groupReadCache.set(id, groupWriteCache.get(id)!))\n  }\n\n  return groupReadCache\n}\n\nfunction getMirroredNodes(\n  cyclicGroups: Array<Set<number>>,\n  graph: LookupGraph,\n) {\n  const maxSize = cyclicGroups.reduce(\n    (acc, group) => Math.max(acc, group.size),\n    0,\n  )\n  const allEntries = new Set([...graph.values()].map((v) => v.entry.id))\n\n  const resultingChecksums = iterateChecksums(\n    allEntries,\n    maxSize,\n    // Cache won't be used, since it's using the internal one for every node.\n    new Map(),\n    graph,\n  )\n\n  const checksumToNodes = new Map<bigint, number[]>()\n  for (const id of allEntries) {\n    const checksum = resultingChecksums.get(id)\n    if (checksum == undefined) throw new Error(\"Unreachable\")\n    if (!checksumToNodes.has(checksum)) {\n      checksumToNodes.set(checksum, [])\n    }\n    checksumToNodes.get(checksum)!.push(id)\n  }\n\n  const checksumsWithDuplicates = [...checksumToNodes.entries()].filter(\n    ([, nodes]) => nodes.length > 1,\n  )\n\n  const duplicatesMap: Record<number, number[]> = {}\n  checksumsWithDuplicates.forEach(([, nodes]) => {\n    nodes.forEach((n) => (duplicatesMap[n] = nodes))\n  })\n\n  return duplicatesMap\n}\n\nconst buildChecksum = (\n  entry: LookupEntry,\n  cache: Map<number, bigint>,\n  graph: LookupGraph,\n) => {\n  if (cache.has(entry.id)) return cache.get(entry.id)!\n\n  const subGraph = getSubgraph(entry.id, graph)\n\n  const cycles = getStronglyConnectedComponents(subGraph)\n  const cyclicGroups = mergeSCCsWithCommonNodes(cycles).filter((group) => {\n    // Exclude groups that were previously calculated\n    return !cache.has(group.values().next().value)\n  })\n  const mirrored = getMirroredNodes(cyclicGroups, subGraph)\n  const sortedCyclicGroups = sortCyclicGroups(\n    cyclicGroups.filter((group) => group.size > 1),\n    subGraph,\n  )\n\n  sortedCyclicGroups.forEach((group) => {\n    if (cache.has(group.values().next().value)) {\n      // exclude mirrored groups\n      return\n    }\n\n    const result = iterateChecksums(group, group.size, cache, graph)\n    group.forEach((id) => {\n      const checksum = result.get(id)!\n      if (id in mirrored) {\n        mirrored[id].forEach((id) => cache.set(id, checksum))\n      } else {\n        cache.set(id, checksum)\n      }\n    })\n  })\n\n  const getChecksum = (entry: LookupEntry) => {\n    if (cache.has(entry.id)) return cache.get(entry.id)!\n    return _buildChecksum(entry, getChecksum)\n  }\n\n  return getChecksum(entry)\n}\n\nexport const getChecksumBuilder = (metadata: V14 | V15) => {\n  const lookupData = metadata.lookup\n  const getLookupEntryDef = getLookupFn(lookupData)\n  const graph = buildLookupGraph(getLookupEntryDef, lookupData.length)\n\n  const cache = new Map<number, bigint>()\n\n  const buildDefinition = (id: number): bigint =>\n    buildChecksum(getLookupEntryDef(id), cache, graph)\n\n  const buildStorage = (pallet: string, entry: string): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .storage!.items.find((s) => s.name === entry)!\n\n      if (storageEntry.type.tag === \"plain\")\n        return buildDefinition(storageEntry.type.value)\n\n      const { key, value } = storageEntry.type.value\n      const val = buildDefinition(value)\n      const returnKey = buildDefinition(key)\n      return getChecksum([val, returnKey])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildRuntimeCall = (api: string, method: string): bigint | null => {\n    try {\n      const entry = metadata.apis\n        .find((x) => x.name === api)\n        ?.methods.find((x) => x.name === method)\n      if (!entry) throw null\n\n      const argNamesChecksum = getStringChecksum(\n        entry.inputs.map((x) => x.name),\n      )\n      const argValuesChecksum = getChecksum(\n        entry.inputs.map((x) => buildDefinition(x.type)),\n      )\n      const outputChecksum = buildDefinition(entry.output)\n\n      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum])\n    } catch (_) {\n      return null\n    }\n  }\n\n  const buildComposite = (\n    input: TupleVar | StructVar | VoidVar | ArrayVar,\n  ): bigint => {\n    if (input.type === \"void\") return getChecksum([0n])\n\n    if (input.type === \"tuple\") {\n      const values = Object.values(input.value).map((entry) =>\n        buildDefinition(entry.id),\n      )\n\n      return getChecksum([shapeIds.tuple, ...values])\n    }\n\n    if (input.type === \"array\") {\n      return getChecksum([\n        shapeIds.vector,\n        buildDefinition(input.value.id),\n        BigInt(input.len),\n      ])\n    }\n\n    // Otherwise struct\n    return structLikeBuilder(shapeIds.struct, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildNamedTuple = (input: StructVar): bigint => {\n    return structLikeBuilder(shapeIds.tuple, input.value, (entry) =>\n      buildDefinition(entry.id),\n    )\n  }\n\n  const buildVariant =\n    (variantType: \"errors\" | \"events\" | \"calls\") =>\n    (pallet: string, name: string): bigint | null => {\n      try {\n        const palletEntry = metadata.pallets.find((x) => x.name === pallet)!\n        const enumLookup = getLookupEntryDef(\n          palletEntry[variantType]! as number,\n        )\n        buildDefinition(enumLookup.id)\n\n        if (enumLookup.type !== \"enum\") throw null\n        const entry = enumLookup.value[name]\n        return entry.type === \"lookupEntry\"\n          ? buildDefinition(entry.value.id)\n          : buildComposite(entry)\n      } catch (_) {\n        return null\n      }\n    }\n\n  const buildConstant = (\n    pallet: string,\n    constantName: string,\n  ): bigint | null => {\n    try {\n      const storageEntry = metadata.pallets\n        .find((x) => x.name === pallet)!\n        .constants!.find((s) => s.name === constantName)!\n\n      return buildDefinition(storageEntry.type)\n    } catch (_) {\n      return null\n    }\n  }\n\n  const toStringEnhancer =\n    <Args extends Array<any>>(\n      fn: (...args: Args) => bigint | null,\n    ): ((...args: Args) => string | null) =>\n    (...args) =>\n      fn(...args)?.toString(32) ?? null\n\n  return {\n    buildDefinition: toStringEnhancer(buildDefinition),\n    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),\n    buildStorage: toStringEnhancer(buildStorage),\n    buildCall: toStringEnhancer(buildVariant(\"calls\")),\n    buildEvent: toStringEnhancer(buildVariant(\"events\")),\n    buildError: toStringEnhancer(buildVariant(\"errors\")),\n    buildConstant: toStringEnhancer(buildConstant),\n    buildComposite: toStringEnhancer(buildComposite),\n    buildNamedTuple: toStringEnhancer(buildNamedTuple),\n    getAllGeneratedChecksums: () =>\n      Array.from(cache.values()).map((v) => v.toString(32)),\n  }\n}\n","import { LookupEntry } from \"./lookups\"\n\nexport type LookupGraph = Map<\n  number,\n  { entry: LookupEntry; backRefs: Set<number>; refs: Set<number> }\n>\n\nexport function buildLookupGraph(\n  lookupFn: (id: number) => LookupEntry,\n  lookupLength: number,\n): LookupGraph {\n  const result: LookupGraph = new Map()\n  const visited = new Set<number>()\n\n  const addEdge = (from: number, to: number) => {\n    if (!result.has(from))\n      result.set(from, {\n        entry: lookupFn(from),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    if (!result.has(to))\n      result.set(to, {\n        entry: lookupFn(to),\n        backRefs: new Set(),\n        refs: new Set(),\n      })\n    result.get(from)!.refs.add(to)\n    result.get(to)!.backRefs.add(from)\n  }\n\n  for (let i = 0; i < lookupLength; i++) {\n    const entry = lookupFn(i)\n    if (i !== entry.id) {\n      // Lookup solved a pointer, but we still need to add that node into our\n      // graph in case someone access it from there.\n      addEdge(i, entry.id)\n    }\n    if (visited.has(entry.id)) continue\n    visited.add(entry.id)\n\n    switch (entry.type) {\n      case \"array\":\n      case \"option\":\n      case \"sequence\":\n        addEdge(entry.id, entry.value.id)\n        break\n      case \"enum\":\n        Object.values(entry.value).forEach((enumEntry) => {\n          switch (enumEntry.type) {\n            case \"array\":\n            case \"lookupEntry\":\n              addEdge(entry.id, enumEntry.value.id)\n              break\n            case \"struct\":\n            case \"tuple\":\n              Object.values(enumEntry.value).forEach((v) =>\n                addEdge(entry.id, v.id),\n              )\n              break\n          }\n        })\n        break\n      case \"result\":\n        addEdge(entry.id, entry.value.ok.id)\n        addEdge(entry.id, entry.value.ko.id)\n        break\n      case \"struct\":\n      case \"tuple\":\n        Object.values(entry.value).forEach((v) => addEdge(entry.id, v.id))\n        break\n    }\n\n    // It could be that this node is not being referenced by any other type\n    // nor it references anything. We still have to add it into the graph.\n    if (!result.has(entry.id)) {\n      result.set(entry.id, {\n        backRefs: new Set(),\n        refs: new Set(),\n        entry,\n      })\n    }\n  }\n\n  return result\n}\n\nconst subgraphCache = new WeakMap<LookupGraph, Map<number, LookupGraph>>()\nfunction _getSubgraph(\n  id: number,\n  graph: LookupGraph,\n  result: LookupGraph,\n  cache: Map<number, LookupGraph>,\n) {\n  if (result.has(id)) return\n  const node = graph.get(id)!\n  result.set(id, node)\n  cache.set(id, result)\n\n  node.refs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n  node.backRefs.forEach((ref) => _getSubgraph(ref, graph, result, cache))\n}\n\nexport function getSubgraph(id: number, graph: LookupGraph) {\n  if (!subgraphCache.has(graph)) {\n    subgraphCache.set(graph, new Map())\n  }\n  const cache = subgraphCache.get(graph)!\n  if (cache.has(id)) return cache.get(id)!\n\n  const result: LookupGraph = new Map()\n  _getSubgraph(id, graph, result, cache)\n  return result\n}\n\nexport function getStronglyConnectedComponents(graph: LookupGraph) {\n  // Tarjan's strongly connected components\n  const tarjanState = new Map<\n    number,\n    {\n      index: number\n      lowLink: number\n      onStack: boolean\n    }\n  >()\n  let index = 0\n  const stack: number[] = []\n  const result: Array<Set<number>> = []\n\n  function strongConnect(v: number): void {\n    const state = {\n      index: index,\n      lowLink: index,\n      onStack: true,\n    }\n    tarjanState.set(v, state)\n    index++\n    stack.push(v)\n\n    const edges = graph.get(v)!.refs\n    for (let w of edges) {\n      const edgeState = tarjanState.get(w)\n      if (!edgeState) {\n        strongConnect(w)\n        state.lowLink = Math.min(state.lowLink, tarjanState.get(w)!.lowLink)\n      } else if (edgeState.onStack) {\n        state.lowLink = Math.min(state.lowLink, edgeState.index)\n      }\n    }\n\n    if (state.lowLink === state.index) {\n      const component = new Set<number>()\n\n      let poppedNode = -1\n      do {\n        poppedNode = stack.pop()!\n        tarjanState.get(poppedNode)!.onStack = false\n        component.add(poppedNode)\n      } while (poppedNode !== v)\n\n      if (component.size > 1) result.push(component)\n    }\n  }\n\n  for (const node of graph.keys()) {\n    if (!tarjanState.has(node)) {\n      strongConnect(node)\n    }\n  }\n\n  return result\n}\n\nexport function mergeSCCsWithCommonNodes(\n  stronglyConnectedComponents: Array<Set<number>>,\n) {\n  /**\n   * For Nodes that are shared between two sets of SCCs, we need to calculate\n   * the checksum for the both of them, which wouldn't work (it would give\n   * different checksums).\n   * So we merge the SCCs that are using shared nodes into one group.\n   */\n  const scc = stronglyConnectedComponents\n  const ungroupedCycles = new Set(scc.map((_, i) => i))\n  const edges = new Map(scc.map((_, i) => [i, new Set<number>()]))\n  scc.forEach((cycle, i) => {\n    scc.slice(i + 1).forEach((otherCycle, _j) => {\n      const j = _j + i + 1\n      const combined = new Set([...cycle, ...otherCycle])\n      if (combined.size !== cycle.size + otherCycle.size) {\n        edges.get(i)!.add(j)\n        edges.get(j)!.add(i)\n      }\n    })\n  })\n  const groups: Array<Set<number>> = []\n\n  while (ungroupedCycles.size) {\n    const group = new Set<number>()\n    const toVisit = [ungroupedCycles.values().next().value]\n    while (toVisit.length) {\n      const idx = toVisit.pop()\n      if (!ungroupedCycles.has(idx)) continue\n      ungroupedCycles.delete(idx)\n\n      const cycle = scc[idx]\n      cycle.forEach((v) => group.add(Number(v)))\n      edges.get(idx)!.forEach((n) => toVisit.push(n))\n    }\n    groups.push(group)\n  }\n\n  return groups\n}\n"],"mappings":"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","names":["src_exports","__export","getChecksumBuilder","getDynamicBuilder","getLookupFn","__toCommonJS","isBytes","value","nBytes","getLookupFn","lookupData","lookups","from","withCache","fn","id","entry","isAccountId32SearchOn","isAccountId20SearchOn","getLookupEntryDef","def","path","params","inner","allKey","values","innerDocs","x","idx","key","enumValue","enumDocs","valuesArr","innerDocsArr","areAllSame","v","doc","len","translated","scale","withCache","fn","onEnterCircular","onExitCircular","input","cache","stack","rest","id","res","result","import_utils","_bytes","_buildCodec","input","cache","stack","_accountId","scale","buildNextCodec","nextInput","buildCodec","buildVector","inner","len","innerCodec","buildTuple","value","buildStruct","key","dependencies","v","idx","indexes","x","i","withCache","res","getDynamicBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildDefinition","id","prefix","ss58Prefix","prefixVal","storagePallets","buildStorage","pallet","entry","storagePallet","storageEntry","s","storageWithFallback","args","result","hashers","val","hashes","hashArgs","buildEnumEntry","l","buildConstant","constantName","buildVariant","type","name","palletEntry","lookup","buildRuntimeCall","api","method","import_substrate_bindings","buildLookupGraph","lookupFn","lookupLength","result","visited","addEdge","from","to","i","entry","enumEntry","v","subgraphCache","_getSubgraph","id","graph","cache","node","ref","getSubgraph","getStronglyConnectedComponents","tarjanState","index","stack","strongConnect","state","edges","w","edgeState","component","poppedNode","mergeSCCsWithCommonNodes","stronglyConnectedComponents","scc","ungroupedCycles","_","cycle","otherCycle","_j","j","groups","group","toVisit","idx","n","textEncoder","encodeText","getChecksum","values","res","dv","i","getStringChecksum","v","shapeIds","runtimePrimitiveIds","metadataPrimitiveIds","structLikeBuilder","shapeId","input","innerChecksum","sortedEntries","a","b","keysChecksum","key","valuesChecksum","entry","_buildChecksum","buildNextChecksum","buildVector","length","innerValue","buildTuple","entries","buildStruct","sortCyclicGroups","groups","graph","getReachableNodes","group","result","toVisit","id","dependentsFirst","candidate","node","iterateChecksums","iterations","cache","groupReadCache","groupWriteCache","recursiveBuildChecksum","skipCache","nextEntry","getMirroredNodes","cyclicGroups","maxSize","acc","allEntries","resultingChecksums","checksumToNodes","checksum","checksumsWithDuplicates","nodes","duplicatesMap","n","buildChecksum","subGraph","getSubgraph","cycles","getStronglyConnectedComponents","mergeSCCsWithCommonNodes","mirrored","getChecksumBuilder","metadata","lookupData","getLookupEntryDef","getLookupFn","buildLookupGraph","buildDefinition","buildStorage","pallet","storageEntry","x","s","value","val","returnKey","buildRuntimeCall","api","method","argNamesChecksum","argValuesChecksum","outputChecksum","buildComposite","buildNamedTuple","buildVariant","variantType","name","palletEntry","enumLookup","buildConstant","constantName","toStringEnhancer","fn","args"]}
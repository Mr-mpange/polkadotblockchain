import { JsonRpcProvider } from '@polkadot-api/json-rpc-provider';
import { RuntimeContext, ChainHead$, BlockInfo, SystemEvent as SystemEvent$1, getObservableClient } from '@polkadot-api/observable-client';
import { HexString, Binary, SS58String, Enum, BlockHeader } from '@polkadot-api/substrate-bindings';
export { AccountId, Binary, Codec, Enum, EnumVariant, FixedSizeBinary, GetEnum, HexString, ResultPayload, SS58String, _Enum } from '@polkadot-api/substrate-bindings';
import { ChainSpecData } from '@polkadot-api/substrate-client';
import { Observable } from 'rxjs';
import { DescriptorValues } from '@polkadot-api/codegen';
export { DescriptorValues } from '@polkadot-api/codegen';
import { PolkadotSigner } from '@polkadot-api/polkadot-signer';
export { PolkadotSigner } from '@polkadot-api/polkadot-signer';

type PlainDescriptor<T> = {
    _type?: T;
};
type AssetDescriptor<T> = string & {
    _type?: T;
};
type StorageDescriptor<Args extends Array<any>, T, Optional extends true | false> = {
    _type: T;
    _args: Args;
    _optional: Optional;
};
type TxDescriptor<Args extends {} | undefined> = {
    ___: Args;
};
type RuntimeDescriptor<Args extends Array<any>, T> = [Args, T];
type DescriptorEntry<T> = Record<string, Record<string, T>>;
type PalletsTypedef<St extends DescriptorEntry<StorageDescriptor<any, any, any>>, Tx extends DescriptorEntry<TxDescriptor<any>>, Ev extends DescriptorEntry<PlainDescriptor<any>>, Err extends DescriptorEntry<PlainDescriptor<any>>, Ct extends DescriptorEntry<PlainDescriptor<any>>> = {
    __storage: St;
    __tx: Tx;
    __event: Ev;
    __error: Err;
    __const: Ct;
};
type ApisTypedef<T extends DescriptorEntry<RuntimeDescriptor<any, any>>> = T;

type ChainDefinition = {
    descriptors: Promise<DescriptorValues> & {
        pallets: PalletsTypedef<any, any, any, any, any>;
        apis: ApisTypedef<any>;
    };
    asset: AssetDescriptor<any>;
    checksums: Promise<string[]>;
};
type ExtractStorage<T extends DescriptorEntry<StorageDescriptor<any, any, any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends StorageDescriptor<infer Key, infer Value, infer Optional> ? {
            KeyArgs: Key;
            Value: Value;
            IsOptional: Optional;
        } : unknown;
    };
};
type ExtractTx<T extends DescriptorEntry<TxDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends TxDescriptor<infer Args> ? Args : unknown;
    };
};
type ExtractPlain<T extends DescriptorEntry<PlainDescriptor<any>>> = {
    [K in keyof T]: {
        [KK in keyof T[K]]: T[K][KK] extends PlainDescriptor<infer Value> ? Value : unknown;
    };
};
type QueryFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractStorage<T["__storage"]>;
type TxFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractTx<T["__tx"]>;
type EventsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__event"]>;
type ErrorsFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__error"]>;
type ConstFromPalletsDef<T extends PalletsTypedef<any, any, any, any, any>> = ExtractPlain<T["__const"]>;

declare const enum OpType {
    Storage = "storage",
    Tx = "tx",
    Event = "events",
    Error = "errors",
    Const = "constants"
}
declare class Runtime {
    private _ctx;
    private _checksums;
    private _descriptors;
    private constructor();
    /**
     * @access package  - Internal implementation detail. Do not use.
     */
    static _create(ctx: RuntimeContext, checksums: string[], descriptors: DescriptorValues): Runtime;
    /**
     * @access package  - Internal implementation detail. Do not use.
     */
    _getCtx(): RuntimeContext;
    /**
     * @access package  - Internal implementation detail. Do not use.
     */
    _getPalletChecksum(opType: OpType, pallet: string, name: string): string;
    /**
     * @access package  - Internal implementation detail. Do not use.
     */
    _getApiChecksum(name: string, method: string): string;
}
type RuntimeApi = Observable<Runtime> & {
    /**
     * @returns Promise that resolves in the `Runtime` as soon as it's
     *          loaded.
     */
    latest: () => Promise<Runtime>;
};
interface IsCompatible {
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     * In this case the function waits for `Runtime` to load, and returns
     * asynchronously.
     *
     * @returns Promise that resolves with the result of the compatibility
     *          check.
     */
    (): Promise<boolean>;
    /**
     * Passing the runtime makes the function to return synchronously.
     *
     * @returns Result of the compatibility check.
     */
    (runtime: Runtime): boolean;
}
declare const compatibilityHelper: (runtimeApi: RuntimeApi, getDescriptorChecksum: (runtime: Runtime) => string) => (getChecksum: (ctx: RuntimeContext) => string | null) => {
    isCompatible: IsCompatible;
    waitChecksums: () => Promise<(ctx: RuntimeContext) => boolean>;
    withCompatibleRuntime: <T>(chainHead: ChainHead$, mapper: (x: T) => string, error: () => Error) => (source$: Observable<T>) => Observable<[T, RuntimeContext]>;
    compatibleRuntime$: (chainHead: ChainHead$, hash: string | null, error: () => Error) => Observable<RuntimeContext>;
};
type CompatibilityHelper = ReturnType<typeof compatibilityHelper>;

interface ConstantEntry<T> {
    /**
     * Constants are simple key-value structures found in the runtime metadata.
     *
     * @returns Promise that will resolve in the value of the constant.
     */
    (): Promise<T>;
    /**
     * @param runtime  Runtime from got with `typedApi.runtime`
     * @returns Synchronously returns value of the constant.
     */
    (runtime: Runtime): T;
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     */
    isCompatible: IsCompatible;
}

type EventPhase = {
    type: "ApplyExtrinsic";
    value: number;
} | {
    type: "Finalization";
} | {
    type: "Initialization";
};
type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>;
type EvPull<T> = () => Promise<Array<{
    meta: {
        block: BlockInfo;
        phase: EventPhase;
    };
    payload: T;
}>>;
type EvFilter<T> = (collection: SystemEvent["event"][]) => Array<T>;
type EvClient<T> = {
    /**
     * Multicast and stateful Observable watching for new events (matching the
     * event kind chosen) in the latest known `finalized` block.
     *
     * @param filter  Optional filter function to only emit events complying
     *                with the function.
     */
    watch: EvWatch<T>;
    /**
     * Fetch (Promise-based) all events (matching the event kind chosen) available
     * in the latest known `finalized` block.
     */
    pull: EvPull<T>;
    /**
     * Filter a bunch of `SystemEvent` and return the decoded `payload` of every
     * of them.
     *
     * @param collection  Array of `SystemEvent` to filter.
     */
    filter: EvFilter<T>;
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     */
    isCompatible: IsCompatible;
};
type SystemEvent = {
    phase: EventPhase;
    event: {
        type: string;
        value: {
            type: string;
            value: any;
        };
    };
    topics: Array<any>;
};

type CallOptions$1 = Partial<{
    at: string;
    signal: AbortSignal;
}>;
type WithCallOptions$1<Args extends Array<any>> = Args["length"] extends 0 ? [options?: CallOptions$1] : [...args: Args, options?: CallOptions$1];
interface RuntimeCall<Args extends Array<any>, Payload> {
    /**
     * Get `Payload` (Promise-based) for the runtime call.
     *
     * @param args  All keys needed for that runtime call.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    (...args: WithCallOptions$1<Args>): Promise<Payload>;
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     */
    isCompatible: IsCompatible;
}

type CallOptions = Partial<{
    /**
     * `at` could be a blockHash, `best`, or `finalized` (default)
     */
    at: string;
    /**
     * `signal` allows you to abort an ongoing Promise. See [MDN
     * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for
     * more information
     */
    signal: AbortSignal;
}>;
type WithCallOptions<Args extends Array<any>> = [
    ...args: Args,
    options?: CallOptions
];
type PossibleParents<A extends Array<any>> = A extends [...infer Left, any] ? Left | PossibleParents<Left> : [];
type StorageEntryWithoutKeys<Payload> = {
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     */
    isCompatible: IsCompatible;
    /**
     * Get `Payload` (Promise-based) for the storage entry.
     *
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValue: (options?: CallOptions) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param bestOrFinalized  Optionally choose which block to query and watch
     *                         changes, `best` or `finalized` (default)
     */
    watchValue: (bestOrFinalized?: "best" | "finalized") => Observable<Payload>;
};
type StorageEntryWithKeys<Args extends Array<any>, Payload> = {
    /**
     * `isCompatible` enables you to check whether or not the call you're trying
     * to make is compatible with the descriptors you generated on dev time.
     */
    isCompatible: IsCompatible;
    /**
     * Get `Payload` (Promise-based) for the storage entry with a specific set of
     * `Args`.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     */
    getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>;
    /**
     * Watch changes in `Payload` (observable-based) for the storage entry.
     *
     * @param args  All keys needed for that storage entry.
     *              At the end, optionally choose which block to query and
     *              watch changes, `best` or `finalized` (default)
     */
    watchValue: (...args: [...Args, bestOrFinalized?: "best" | "finalized"]) => Observable<Payload>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with
     * several sets of `Args`.
     *
     * @param keys     Array of sets of keys needed for the storage entry.
     * @param options  Optionally set which block to target (latest known
     *                 finalized is the default) and an AbortSignal.
     */
    getValues: (keys: Array<[...Args]>, options?: CallOptions) => Promise<Array<Payload>>;
    /**
     * Get an Array of `Payload` (Promise-based) for the storage entry with a
     * subset of `Args`.
     *
     * @param args  Subset of keys needed for the storage entry.
     *              At the end, optionally set which block to target (latest
     *              known finalized is the default) and an AbortSignal.
     * @example
     *
     *   // this is a query with 3 keys
     *   typedApi.query.Pallet.Query.getEntries({ at: "best" }) // no keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, { at: "finalized" }) // 1/3 keys
     *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: "0x12345678" }) // 2/3 keys
     *
     */
    getEntries: (...args: WithCallOptions<PossibleParents<Args>>) => Promise<Array<{
        keyArgs: Args;
        value: NonNullable<Payload>;
    }>>;
};
type StorageEntry<Args extends Array<any>, Payload> = Args extends [] ? StorageEntryWithoutKeys<Payload> : StorageEntryWithKeys<Args, Payload>;

type TxEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxBroadcastEvent = TxSigned | TxBroadcasted | TxBestBlocksState | TxFinalized;
type TxSigned = {
    type: "signed";
    txHash: HexString;
};
type TxBroadcasted = {
    type: "broadcasted";
    txHash: HexString;
};
type TxBestBlocksState = {
    type: "txBestBlocksState";
    txHash: HexString;
} & (TxInBestBlocksNotFound | TxInBestBlocksFound);
type TxInBestBlocksNotFound = {
    found: false;
    isValid: boolean;
};
type TxInBestBlocksFound = {
    found: true;
} & TxEventsPayload;
type TxEventsPayload = {
    ok: boolean;
    events: Array<SystemEvent$1["event"]>;
    block: {
        hash: string;
        index: number;
    };
};
type TxFinalized = {
    type: "finalized";
    txHash: HexString;
} & TxEventsPayload;
type TxOptions<Asset> = Partial<void extends Asset ? {
    at: HexString | "best" | "finalized";
    tip: bigint;
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    nonce: number;
} : {
    at: HexString | "best" | "finalized";
    tip: bigint;
    mortality: {
        mortal: false;
    } | {
        mortal: true;
        period: number;
    };
    asset: Asset;
    nonce: number;
}>;
type TxFinalizedPayload = Omit<TxFinalized, "type">;
type TxPromise<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<TxFinalizedPayload>;
type TxObservable<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Observable<TxEvent>;
interface TxCall {
    (): Promise<Binary>;
    (runtime: Runtime): Binary;
}
type TxSignFn<Asset> = (from: PolkadotSigner, txOptions?: TxOptions<Asset>) => Promise<HexString>;
type Transaction<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> = {
    sign: TxSignFn<Asset>;
    signSubmitAndWatch: TxObservable<Asset>;
    signAndSubmit: TxPromise<Asset>;
    getEncodedData: TxCall;
    getEstimatedFees: (from: Uint8Array | SS58String, txOptions?: TxOptions<Asset>) => Promise<bigint>;
    decodedCall: Enum<{
        [P in Pallet]: Enum<{
            [N in Name]: Arg;
        }>;
    }>;
};
interface TxEntry<Arg extends {} | undefined, Pallet extends string, Name extends string, Asset> {
    (...args: Arg extends undefined ? [] : [data: Arg]): Transaction<Arg, Pallet, Name, Asset>;
    isCompatible: IsCompatible;
}

declare const submit$: (chainHead: ChainHead$, broadcastTx$: (tx: string) => Observable<never>, tx: HexString, at?: HexString, emitSign?: boolean) => Observable<TxEvent>;
declare const submit: (chainHead: ChainHead$, broadcastTx$: (tx: string) => Observable<never>, transaction: HexString, at?: HexString) => Promise<TxFinalizedPayload>;

declare const createTxEntry: <Arg extends {} | undefined, Pallet extends string, Name extends string, Asset extends AssetDescriptor<any>>(pallet: Pallet, name: Name, assetChecksum: Asset, chainHead: ReturnType<ReturnType<typeof getObservableClient>["chainHead$"]>, broadcast: (tx: string) => Observable<never>, compatibilityHelper: CompatibilityHelper) => TxEntry<Arg, Pallet, Name, Asset["_type"]>;

type StorageApi<A extends Record<string, Record<string, {
    KeyArgs: Array<any>;
    Value: any;
    IsOptional: false | true;
} | unknown>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {
            KeyArgs: Array<any>;
            Value: any;
            IsOptional: false | true;
        } ? StorageEntry<A[K][KK]["KeyArgs"], A[K][KK]["IsOptional"] extends true ? A[K][KK]["Value"] | undefined : A[K][KK]["Value"]> : unknown;
    };
};
type RuntimeCallsApi<A extends Record<string, Record<string, RuntimeDescriptor<Array<any>, any>>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends RuntimeDescriptor<infer Args, infer Value> ? RuntimeCall<Args, Value> : unknown;
    };
};
type TxApi<A extends Record<string, Record<string, any>>, Asset> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: A[K][KK] extends {} | undefined ? TxEntry<A[K][KK], K & string, KK & string, Asset> : unknown;
    };
};
type EvApi<A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: EvClient<A[K][KK]>;
    };
};
type ConstApi<A extends Record<string, Record<string, any>>> = {
    [K in keyof A]: {
        [KK in keyof A[K]]: ConstantEntry<A[K][KK]>;
    };
};
type TypedApi<D extends ChainDefinition> = {
    query: StorageApi<QueryFromPalletsDef<D["descriptors"]["pallets"]>>;
    tx: TxApi<TxFromPalletsDef<D["descriptors"]["pallets"]>, D["asset"]["_type"]>;
    event: EvApi<EventsFromPalletsDef<D["descriptors"]["pallets"]>>;
    apis: RuntimeCallsApi<D["descriptors"]["apis"]>;
    constants: ConstApi<ConstFromPalletsDef<D["descriptors"]["pallets"]>>;
    runtime: RuntimeApi;
};
interface PolkadotClient {
    /**
     * Retrieve the ChainSpecData as it comes from the [JSON-RPC
     * spec](https://paritytech.github.io/json-rpc-interface-spec/api/chainSpec.html)
     */
    getChainSpecData: () => Promise<ChainSpecData>;
    /**
     * Observable that emits `BlockInfo` from the latest known finalized block.
     * It's a multicast and stateful observable, that will synchronously replay
     * its latest known state.
     */
    finalizedBlock$: Observable<BlockInfo>;
    /**
     * @returns Latest known finalized block.
     */
    getFinalizedBlock: () => Promise<BlockInfo>;
    /**
     * Observable that emits an Array of `BlockInfo`, being the first element the
     * latest known best block, and the last element the latest known finalized
     * block. It's a multicast and stateful observable, that will synchronously
     * replay its latest known state. This array is an immutable data structure;
     * i.e. a new array is emitted at every event but the reference to its
     * children are stable if the children didn't change.
     *
     * Note that subscribing to this observable already supersedes the need of
     * subscribing to `finalizedBlock$`, since the last element of the array will
     * be the latest known finalized block.
     */
    bestBlocks$: Observable<BlockInfo[]>;
    /**
     * @returns Array of `BlockInfo`, being the first element the latest
     *          known best block, and the last element the latest known
     *          finalized block.
     */
    getBestBlocks: () => Promise<BlockInfo[]>;
    /**
     * Observable to watch Block Body.
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Observable to watch a block body. There'll be just one event
     *          with the payload and the observable will complete.
     */
    watchBlockBody: (hash: string) => Observable<HexString[]>;
    /**
     * Get Block Body (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"`, or `"best"`
     * @returns Block body.
     */
    getBlockBody: (hash: string) => Promise<HexString[]>;
    /**
     * Get Block Header (Promise-based)
     *
     * @param hash  It can be a block hash, `"finalized"` (default), or
     *              `"best"`
     * @returns Block hash.
     */
    getBlockHeader: (hash?: string) => Promise<BlockHeader>;
    /**
     * Broadcast a transaction (Promise-based)
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx, retrieve the next nonce,
     *                     and create the mortality taking that block into
     *                     account.
     */
    submit: (transaction: HexString, at?: HexString) => Promise<TxFinalizedPayload>;
    /**
     * Broadcast a transaction and returns an Observable. The observable will
     * complete as soon as the transaction is in a finalized block.
     *
     * @param transaction  SCALE-encoded tx to broadcast.
     * @param at           It can be a block hash, `"finalized"`, or `"best"`.
     *                     That block will be used to verify the validity of
     *                     the tx, retrieve the next nonce,
     *                     and create the mortality taking that block into
     *                     account.
     */
    submitAndWatch: (transaction: HexString, at?: HexString) => Observable<TxBroadcastEvent>;
    /**
     * Returns an instance of a `TypedApi`
     *
     * @param descriptors  Pass descriptors from `@polkadot-api/descriptors`
     *                     generated by `papi` CLI.
     */
    getTypedApi: <D extends ChainDefinition>(descriptors: D) => TypedApi<D>;
    destroy: () => void;
    /**
     * This API is meant as an "escape hatch" to allow access to debug endpoints
     * such as `system_version`, and other useful endpoints that are not spec
     * compliant.
     *
     * @example
     *
     *   const systemVersion = await client._request<string>("system_version", [])
     *   const myFancyThhing = await client._request<
     *     { value: string },
     *     [id: number]
     *   >("very_fancy", [1714])
     *
     */
    _request: <Reply = any, Params extends Array<any> = any[]>(method: string, params: Params) => Promise<Reply>;
}
type FixedSizeArray<L extends number, T> = Array<T> & {
    length: L;
};

/**
 * This is the top-level export for `polkadot-api`.
 *
 * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC
 *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),
 *                  which must support the `chainHead`, `transaction` and
 *                  `chainSpec` groups.
 * @example
 *
 *   import { createClient } from "polkadot-api"
 *   import { getSmProvider } from "polkadot-api/sm-provider"
 *   import { chainSpec } from "polkadot-api/chains/polkadot"
 *   import { start } from "polkadot-api/smoldot"
 *
 *   const smoldot = start()
 *   const chain = await smoldot.addChain({ chainSpec })
 *
 *   // Connect to the polkadot relay chain.
 *   const client = createClient(getSmProvider(chain))
 *
 */
declare function createClient(provider: JsonRpcProvider): PolkadotClient;

export { type ApisTypedef, type AssetDescriptor, type ChainDefinition, type ConstFromPalletsDef, type DescriptorEntry, type ErrorsFromPalletsDef, type EventPhase, type EventsFromPalletsDef, type FixedSizeArray, type PalletsTypedef, type PlainDescriptor, type PolkadotClient, type QueryFromPalletsDef, type RuntimeDescriptor, type StorageDescriptor, type Transaction, type TxBestBlocksState, type TxBroadcastEvent, type TxBroadcasted, type TxCall, type TxDescriptor, type TxEntry, type TxEvent, type TxEventsPayload, type TxFinalized, type TxFinalizedPayload, type TxFromPalletsDef, type TxInBestBlocksFound, type TxInBestBlocksNotFound, type TxObservable, type TxOptions, type TxPromise, type TxSignFn, type TxSigned, type TypedApi, createClient, createTxEntry, submit, submit$ };

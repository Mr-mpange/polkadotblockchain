{"version":3,"sources":["../../src/index.ts","../../src/client.ts","../../src/constants.ts","../../src/event.ts","../../src/utils/shareLatest.ts","../../src/utils/firstValueFromWithSignal.ts","../../src/utils/concatMapEager.ts","../../src/utils/raceMap.ts","../../src/utils/continue-with.ts","../../src/runtime.ts","../../src/runtime-call.ts","../../src/storage.ts","../../src/tx/tx.ts","../../src/tx/create-tx.ts","../../src/tx/signed-extensions/user/ChargeTransactionPayment.ts","../../src/tx/signed-extensions/utils.ts","../../src/tx/signed-extensions/user/CheckMortality.ts","../../src/tx/signed-extensions/user/ChargeAssetTxPayment.ts","../../src/tx/signed-extensions/chain/index.ts","../../src/tx/signed-extensions/chain/CheckGenesis.ts","../../src/tx/signed-extensions/chain/CheckMetadataHash.ts","../../src/tx/signed-extensions/chain/CheckNonce.ts","../../src/tx/signed-extensions/chain/CheckSpecVersion.ts","../../src/tx/signed-extensions/chain/CheckTxVersion.ts","../../src/tx/submit-fns.ts","../../src/re-exports.ts"],"sourcesContent":["export * from \"./client\"\nexport * from \"./re-exports\"\nexport * from \"./descriptors\"\nexport type { EventPhase } from \"./event\"\nexport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nexport type { PolkadotClient, TypedApi, FixedSizeArray } from \"./types\"\nexport type * from \"./tx\"\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getObservableClient } from \"@polkadot-api/observable-client\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, firstValueFrom } from \"rxjs\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { OpType, compatibilityHelper, getRuntimeApi } from \"./runtime\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport { PolkadotClient, TypedApi } from \"./types\"\n\nconst createTypedApi = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  broadcast$: (tx: string) => Observable<never>,\n): TypedApi<D> => {\n  const runtime = getRuntimeApi(\n    chainDefinition.checksums,\n    chainDefinition.descriptors,\n    chainHead,\n  )\n\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Storage, pallet, name),\n      ),\n    ),\n  )\n\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainDefinition.asset,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Tx, pallet, name),\n      ),\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Event, pallet, name),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Const, pallet, name),\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(runtime, (r) => r._getApiChecksum(api, method)),\n    ),\n  )\n\n  return {\n    query,\n    tx,\n    event,\n    apis,\n    constants,\n    runtime,\n  } as any\n}\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @example\n *\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain))\n *\n */\nexport function createClient(provider: JsonRpcProvider): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const { getChainSpecData } = rawClient\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  const { broadcastTx$ } = client\n  return {\n    getChainSpecData,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) =>\n      createTypedApi(chainDefinition, chainHead, broadcastTx$),\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n","import { firstValueFrom, map } from \"rxjs\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible, Runtime } from \"./runtime\"\n\nexport interface ConstantEntry<T> {\n  /**\n   * Constants are simple key-value structures found in the runtime metadata.\n   *\n   * @returns Promise that will resolve in the value of the constant.\n   */\n  (): Promise<T>\n  /**\n   * @param runtime  Runtime from got with `typedApi.runtime`\n   * @returns Synchronously returns value of the constant.\n   */\n  (runtime: Runtime): T\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\nexport const createConstantEntry = <T>(\n  palletName: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): ConstantEntry<T> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildConstant(palletName, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Constant(${palletName}.${name})`)\n\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName)\n    const constant = pallet?.constants.find((c) => c.name === name)!\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (runtime?: Runtime): any => {\n    if (runtime) {\n      if (!isCompatible(runtime)) throw checksumError()\n      return getValueWithContext(runtime._getCtx())\n    }\n    return firstValueFrom(\n      compatibleRuntime$(chainHead, null, checksumError).pipe(\n        map(getValueWithContext),\n      ),\n    )\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): EvClient<T> => {\n  const { isCompatible, withCompatibleRuntime } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildEvent(pallet, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),\n    concatMapEager(([block]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, isCompatible }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable, Subscription } from \"rxjs\"\n\nexport const raceMap =\n  <I, O>(mapper: (x: I) => Observable<O>, concurrent: number) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let innerSubscriptions = new Array<Subscription>()\n      let isOuterDone = false\n\n      const createSubscription = (value: I) => {\n        const sub = new Subscription()\n        innerSubscriptions.push(sub)\n        if (innerSubscriptions.length > concurrent) {\n          innerSubscriptions[0].unsubscribe()\n          innerSubscriptions = innerSubscriptions.slice(1)\n        }\n\n        const subscription = mapper(value).subscribe({\n          next(value) {\n            const index = innerSubscriptions.indexOf(sub)\n            innerSubscriptions.slice(0, index).forEach((s) => s.unsubscribe())\n            innerSubscriptions = innerSubscriptions.slice(index)\n\n            observer.next(value)\n          },\n          error(error) {\n            observer.error(error)\n          },\n          complete() {\n            const index = innerSubscriptions.indexOf(sub)\n            innerSubscriptions.splice(index, 1)\n\n            if (innerSubscriptions.length === 0 && isOuterDone)\n              observer.complete()\n          },\n        })\n        sub.add(subscription)\n      }\n\n      const outerSubscription = source$.subscribe({\n        next(value) {\n          createSubscription(value)\n        },\n        error(err) {\n          observer.error(err)\n        },\n        complete() {\n          if (innerSubscriptions.length === 0) observer.complete()\n          isOuterDone = true\n        },\n      })\n\n      return () => {\n        outerSubscription.unsubscribe()\n        innerSubscriptions.forEach((sub) => sub.unsubscribe())\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n","import {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  combineLatest,\n  connectable,\n  filter,\n  firstValueFrom,\n  map,\n} from \"rxjs\"\nimport { DescriptorValues } from \"./descriptors\"\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Error = \"errors\",\n  Const = \"constants\",\n}\n\nexport class Runtime {\n  private constructor(\n    private _ctx: RuntimeContext,\n    private _checksums: string[],\n    private _descriptors: DescriptorValues,\n  ) {}\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  static _create(\n    ctx: RuntimeContext,\n    checksums: string[],\n    descriptors: DescriptorValues,\n  ) {\n    return new Runtime(ctx, checksums, descriptors)\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getCtx() {\n    return this._ctx\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getPalletChecksum(opType: OpType, pallet: string, name: string) {\n    return this._checksums[this._descriptors[opType][pallet][name]]\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getApiChecksum(name: string, method: string) {\n    return this._checksums[this._descriptors.apis[name][method]]\n  }\n}\n\nexport type RuntimeApi = Observable<Runtime> & {\n  /**\n   * @returns Promise that resolves in the `Runtime` as soon as it's\n   *          loaded.\n   */\n  latest: () => Promise<Runtime>\n}\n\nexport const getRuntimeApi = (\n  checksums: Promise<string[]>,\n  descriptors: Promise<DescriptorValues>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeApi => {\n  const runtimeWithChecksums$ = connectable(\n    combineLatest([chainHead.runtime$, checksums, descriptors]).pipe(\n      map(([x, checksums, descriptors]) =>\n        x ? Runtime._create(x, checksums, descriptors) : null,\n      ),\n    ),\n    {\n      connector: () => new ReplaySubject(1),\n    },\n  )\n  runtimeWithChecksums$.connect()\n\n  const result = runtimeWithChecksums$.pipe(\n    filter((v) => Boolean(v)),\n  ) as RuntimeApi\n  result.latest = () => firstValueFrom(result)\n\n  return result\n}\n\nexport interface IsCompatible {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   * In this case the function waits for `Runtime` to load, and returns\n   * asynchronously.\n   *\n   * @returns Promise that resolves with the result of the compatibility\n   *          check.\n   */\n  (): Promise<boolean>\n  /**\n   * Passing the runtime makes the function to return synchronously.\n   *\n   * @returns Result of the compatibility check.\n   */\n  (runtime: Runtime): boolean\n}\n\nexport const compatibilityHelper =\n  (\n    runtimeApi: RuntimeApi,\n    getDescriptorChecksum: (runtime: Runtime) => string,\n  ) =>\n  (getChecksum: (ctx: RuntimeContext) => string | null) => {\n    function isCompatibleSync(runtime: Runtime) {\n      return getChecksum(runtime._getCtx()) === getDescriptorChecksum(runtime)\n    }\n\n    const isCompatible: IsCompatible = (runtime?: Runtime): any => {\n      if (runtime) {\n        return isCompatibleSync(runtime)\n      }\n\n      return runtimeApi.latest().then(isCompatibleSync)\n    }\n    const waitChecksums = async () => {\n      const runtime = await runtimeApi.latest()\n      return (ctx: RuntimeContext) =>\n        getChecksum(ctx) === getDescriptorChecksum(runtime)\n    }\n    const compatibleRuntime$ = (\n      chainHead: ChainHead$,\n      hash: string | null,\n      error: () => Error,\n    ) =>\n      combineLatest([chainHead.getRuntimeContext$(hash), waitChecksums()]).pipe(\n        map(([ctx, isCompatible]) => {\n          if (!isCompatible(ctx)) {\n            throw error()\n          }\n          return ctx\n        }),\n      )\n\n    const withCompatibleRuntime =\n      <T>(\n        chainHead: ChainHead$,\n        mapper: (x: T) => string,\n        error: () => Error,\n      ) =>\n      (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n        combineLatest([\n          source$.pipe(chainHead.withRuntime(mapper)),\n          waitChecksums(),\n        ]).pipe(\n          map(([[x, ctx], isCompatible]) => {\n            if (!isCompatible(ctx)) {\n              throw error()\n            }\n            return [x, ctx]\n          }),\n        )\n\n    return {\n      isCompatible,\n      waitChecksums,\n      withCompatibleRuntime,\n      compatibleRuntime$,\n    }\n  }\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n","import { firstValueFromWithSignal } from \"@/utils\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport interface RuntimeCall<Args extends Array<any>, Payload> {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): RuntimeCall<any, any> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildRuntimeCall(api, method),\n  )\n  const callName = `${api}_${method}`\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at, checksumError).pipe(\n      mergeMap((ctx) => {\n        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        return chainHead\n          .call$(at, callName, toHex(codecs.args.enc(args)))\n          .pipe(map(codecs.value.dec))\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { firstValueFromWithSignal, raceMap } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { Observable, debounceTime, distinctUntilChanged, map } from \"rxjs\"\nimport { ChainHead$, NotBestBlockError } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): StorageEntry<any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const { isCompatible, waitChecksums, withCompatibleRuntime } =\n    compatibilityHelper((ctx) => ctx.checksumBuilder.buildStorage(pallet, name))\n\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const actualArgs =\n      target === \"best\" || target === \"finalized\" ? args.slice(0, -1) : args\n\n    if (isSystemNumber)\n      return chainHead.bestBlocks$.pipe(\n        map((blocks) => blocks.at(target === \"best\" ? 0 : -1)!.number),\n        distinctUntilChanged(),\n      )\n\n    return chainHead[target === \"best\" ? \"best$\" : \"finalized$\"].pipe(\n      debounceTime(0),\n      withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),\n      raceMap(([block, ctx]) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return chainHead\n          .storage$(block.hash, \"value\", () => codecs.enc(...actualArgs))\n          .pipe(map((val) => ({ val, codecs })))\n      }, 4),\n      distinctUntilChanged((a, b) => a.val === b.val),\n      map(({ val, codecs }) =>\n        val === null ? codecs.fallback : codecs.dec(val),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    let result$: Observable<any>\n    if (isSystemNumber) {\n      result$ = chainHead.bestBlocks$.pipe(\n        map((blocks) => {\n          if (at === \"finalized\" || !at) return blocks.at(-1)\n          if (at === \"best\") return blocks.at(0)\n          return blocks.find((block) => block.hash === at)\n        }),\n        map((block) => {\n          if (!block) throw new NotBestBlockError()\n          return block.number\n        }),\n        distinctUntilChanged(),\n      )\n    } else {\n      const isCompatible = await waitChecksums()\n      result$ = chainHead.storage$(\n        at,\n        \"value\",\n        (ctx) => {\n          if (!isCompatible(ctx)) throw checksumError()\n          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n          const actualArgs =\n            args.length === codecs.len ? args : args.slice(0, -1)\n          if (args !== actualArgs && !isLastArgOptional) throw invalidArgs(args)\n          return codecs.enc(...actualArgs)\n        },\n        null,\n        (data, ctx) => {\n          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n          return data === null ? codecs.fallback : codecs.dec(data)\n        },\n      )\n    }\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const isCompatible = await waitChecksums()\n    const result$ = chainHead.storage$(\n      at,\n      \"descendantsValues\",\n      (ctx) => {\n        if (!isCompatible(ctx)) throw checksumError()\n\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        if (args.length > codecs.len) throw invalidArgs(args)\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs(args)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (values, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return values.map(({ key, value }) => ({\n          keyArgs: codecs.keyDecoder(key),\n          value: codecs.dec(value),\n        }))\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { isCompatible, getValue, getValues, getEntries, watchValue }\n}\n","import {\n  AccountId,\n  Binary,\n  Enum,\n  SS58String,\n  Tuple,\n  compact,\n  u128,\n  u32,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport {\n  BlockInfo,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, Runtime } from \"../runtime\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport { AssetDescriptor } from \"../descriptors\"\nimport { createTx } from \"./create-tx\"\nimport {\n  TxCall,\n  TxEntry,\n  TxPromise,\n  TxObservable,\n  TxOptions,\n  TxSignFn,\n} from \"./types\"\nimport { submit, submit$ } from \"./submit-fns\"\n\nexport { submit, submit$ }\n\nconst accountIdEnc = AccountId().enc\nconst queryInfoRawDec = Tuple(compact, compact, u8, u128).dec\nconst queryInfoDec = (input: string): bigint => queryInfoRawDec(input)[3]\nconst fakeSignature = new Uint8Array(64)\nconst getFakeSignature = () => fakeSignature\n\nexport const createTxEntry = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends AssetDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  assetChecksum: Asset,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  broadcast: (tx: string) => Observable<never>,\n  compatibilityHelper: CompatibilityHelper,\n): TxEntry<Arg, Pallet, Name, Asset[\"_type\"]> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildCall(pallet, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      { dynamicBuilder, asset: [assetEnc, assetCheck] }: RuntimeContext,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (assetChecksum !== assetCheck)\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = { ...txOptions, asset: assetEnc(txOptions.asset) }\n      }\n\n      const { location, codec } = dynamicBuilder.buildCall(pallet, name)\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8(new Uint8Array(location), codec.enc(arg)),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null, checksumError).pipe(\n        map((ctx) => getCallDataWithContext(ctx, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (runtime?: Runtime): any => {\n      if (!runtime)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      if (!isCompatible(runtime)) throw checksumError()\n      return getCallDataWithContext(runtime._getCtx(), arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(chainHead, from, callData.asBytes(), atBlock, options),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx, block }) =>\n          submit$(chainHead, broadcast, tx, block.hash, true),\n        ),\n      )\n\n    const getEstimatedFees = async (\n      from: Uint8Array | SS58String,\n      _options?: any,\n    ) => {\n      const fakeSigner = getPolkadotSigner(\n        from instanceof Uint8Array ? from : accountIdEnc(from),\n        \"Sr25519\",\n        getFakeSignature,\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)))\n\n      return firstValueFrom(\n        chainHead\n          .call$(null, \"TransactionPaymentApi_query_info\", args)\n          .pipe(map(queryInfoDec)),\n      )\n    }\n\n    return {\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { Observable, combineLatest, mergeMap, of, take } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport {\n  ChargeAssetTxPayment,\n  ChargeTransactionPayment,\n  CheckMortality,\n} from \"./signed-extensions/user\"\nimport * as chainSignedExtensions from \"./signed-extensions/chain\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { _void } from \"@polkadot-api/substrate-bindings\"\nimport { empty } from \"./signed-extensions/utils\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  hinted = {},\n) =>\n  chainHead.getRuntimeContext$(atBlock.hash).pipe(\n    take(1),\n    mergeMap((ctx) => {\n      const signedExtensionsCtx = {\n        metadata: ctx.metadata,\n        chainHead: chainHead,\n        callData: callData,\n        at: atBlock.hash,\n        from: signer.publicKey,\n      }\n\n      const mortality: Parameters<typeof CheckMortality>[0] = !hinted.mortality\n        ? { period: 64, blockNumber: atBlock.number }\n        : hinted.mortality.mortal\n          ? { period: hinted.mortality.period, blockNumber: atBlock.number }\n          : undefined // immortal\n\n      return combineLatest(\n        ctx.metadata.extrinsic.signedExtensions.map(\n          ({ identifier, type, additionalSigned }) => {\n            if (identifier === \"CheckMortality\")\n              return CheckMortality(mortality, signedExtensionsCtx)\n\n            if (identifier === \"ChargeTransactionPayment\")\n              return ChargeTransactionPayment(hinted.tip ?? 0n)\n\n            if (identifier === \"ChargeAssetTxPayment\")\n              return ChargeAssetTxPayment(hinted.tip ?? 0n, hinted.asset)\n\n            if (identifier === \"CheckNonce\" && \"nonce\" in hinted)\n              return chainSignedExtensions.getNonce(hinted.nonce!)\n\n            const fn = chainSignedExtensions[identifier as \"CheckGenesis\"]\n            if (!fn) {\n              if (\n                ctx.dynamicBuilder.buildDefinition(type) === _void &&\n                ctx.dynamicBuilder.buildDefinition(additionalSigned) === _void\n              )\n                return of({\n                  value: empty,\n                  additionalSigned: empty,\n                })\n\n              throw new Error(`Unsupported signed-extension: ${identifier}`)\n            }\n            return fn(signedExtensionsCtx)\n          },\n        ),\n      ).pipe(\n        mergeMap((signedExtensions) =>\n          signer.sign(\n            callData,\n            Object.fromEntries(\n              ctx.metadata.extrinsic.signedExtensions.map(\n                ({ identifier }, idx) => [\n                  identifier,\n                  { identifier, ...signedExtensions[idx] },\n                ],\n              ),\n            ),\n            ctx.metadataRaw,\n            atBlock.number,\n          ),\n        ),\n      )\n    }),\n  )\n","import { compactBn } from \"@polkadot-api/substrate-bindings\"\nimport { of } from \"rxjs\"\nimport { empty } from \"../utils\"\nimport { SignedExtension } from \"../internal-types\"\n\nexport const ChargeTransactionPayment = (tip: bigint): SignedExtension =>\n  of({\n    value: compactBn.enc(tip),\n    additionalSigned: empty,\n  })\n","import { map, noop, of } from \"rxjs\"\nimport {\n  V15,\n  Storage,\n  Twox64Concat,\n  u32,\n  V14,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport type { ChainExtensionCtx } from \"./internal-types\"\n\nexport const empty = new Uint8Array()\n\nconst genesisHashStorageKey = Storage(\"System\")(\"BlockHash\", noop, [\n  u32,\n  Twox64Concat,\n]).enc(0)\n\nexport const genesisHashFromCtx = (ctx: ChainExtensionCtx) =>\n  ctx.chainHead\n    .storage$(ctx.at, \"value\", () => genesisHashStorageKey, null)\n    .pipe(map((result) => fromHex(result!)))\n\nexport const systemVersionProp$ = (propName: string, metadata: V14 | V15) => {\n  const lookupFn = getLookupFn(metadata.lookup)\n  const dynamicBuilder = getDynamicBuilder(metadata)\n\n  const constant = metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n\n  const valueEnc = dynamicBuilder.buildDefinition(\n    systemVersion.value[propName].id,\n  ).enc\n\n  return of(valueEnc(systemVersionDec(constant.value)[propName]))\n}\n","import { map, of } from \"rxjs\"\nimport { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport { genesisHashFromCtx } from \"../utils\"\nimport { ChainExtensionCtx, SignedExtension } from \"../internal-types\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nconst mortal = enhanceEncoder(\n  Bytes(2).enc,\n  (value: { period: number; phase: number }) => {\n    const factor = Math.max(value.period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15)\n    const right = (value.phase / factor) << 4\n    return u16.enc(left | right)\n  },\n)\n\nconst zero = new Uint8Array([0])\nexport const CheckMortality = (\n  input: { period: number; blockNumber: number } | undefined,\n  ctx: ChainExtensionCtx,\n): SignedExtension => {\n  if (!input)\n    return genesisHashFromCtx(ctx).pipe(\n      map((additionalSigned) => ({\n        additionalSigned,\n        value: zero,\n      })),\n    )\n\n  const { period, blockNumber } = input\n  return of({\n    additionalSigned: fromHex(ctx.at),\n    value: mortal({\n      period,\n      phase: blockNumber % period,\n    }),\n  })\n}\n","import { of } from \"rxjs\"\nimport {\n  Bytes,\n  Option,\n  Struct,\n  compact,\n} from \"@polkadot-api/substrate-bindings\"\nimport { empty } from \"../utils\"\nimport { SignedExtension } from \"../internal-types\"\n\nconst encoder = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n}).enc\n\nexport const ChargeAssetTxPayment = (\n  tip: number | bigint,\n  asset: Uint8Array | undefined,\n): SignedExtension =>\n  of({\n    value: encoder({\n      tip,\n      asset,\n    }),\n    additionalSigned: empty,\n  })\n","export * from \"./CheckGenesis\"\nexport * from \"./CheckMetadataHash\"\nexport * from \"./CheckNonce\"\nexport * from \"./CheckSpecVersion\"\nexport * from \"./CheckTxVersion\"\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, genesisHashFromCtx } from \"../utils\"\n\nexport const CheckGenesis: GetChainSignedExtension = (ctx) =>\n  genesisHashFromCtx(ctx).pipe(\n    map((additionalSigned) => ({ value: empty, additionalSigned })),\n  )\n","import { of } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\n\nexport const CheckMetadataHash: GetChainSignedExtension = () =>\n  of({\n    value: Uint8Array.from([0]),\n    additionalSigned: Uint8Array.from([0]),\n  })\n","import { mergeMap, of } from \"rxjs\"\nimport { compact, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  GetChainSignedExtension,\n  SignedExtension,\n} from \"../internal-types\"\nimport { empty } from \"../utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nexport const getNonce = (input: number | bigint): SignedExtension =>\n  of({ value: compact.enc(input), additionalSigned: empty })\n\nexport const CheckNonce: GetChainSignedExtension = (ctx) =>\n  ctx.chainHead.call$(ctx.at, NONCE_RUNTIME_CALL, toHex(ctx.from)).pipe(\n    mergeMap((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return getNonce(decoder(bytes))\n    }),\n  )\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, systemVersionProp$ } from \"../utils\"\n\nexport const CheckSpecVersion: GetChainSignedExtension = ({ metadata }) =>\n  systemVersionProp$(\"spec_version\", metadata).pipe(\n    map((additionalSigned) => ({ additionalSigned, value: empty })),\n  )\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, systemVersionProp$ } from \"../utils\"\n\nexport const CheckTxVersion: GetChainSignedExtension = ({ metadata }) =>\n  systemVersionProp$(\"transaction_version\", metadata).pipe(\n    map((additionalSigned) => ({ additionalSigned, value: empty })),\n  )\n","import { Blake2256, HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        hash: string\n        index: number\n        events: any\n      }\n    | boolean\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          hash: string\n          index: number\n          events: any\n        }\n      | boolean\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        pinnedBlocks.blocks.get(analyzed.hash)!.number <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (\n        found &&\n        typeof latestState === \"object\" &&\n        latestState.hash === analyzed.hash\n      ) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = found\n          ? {\n              hash: analyzed.hash,\n              ...analyzed.found,\n            }\n          : analyzed.found.isValid),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (!analyzed.found.isValid) observer.error(new Error(\"Invalid\"))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.type === \"System\" && lastEvent.value.type === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => blocks.blocks.get(at!)?.hash ?? blocks.finalized),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x),\n        map(() => {\n          throw new Error(\"Invalid\")\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (x === true || x === false)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n","export type {\n  Codec,\n  SS58String,\n  HexString,\n  GetEnum,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nexport {\n  AccountId,\n  Binary,\n  FixedSizeBinary,\n  Enum,\n  type EnumVariant,\n  _Enum,\n} from \"@polkadot-api/substrate-bindings\"\n"],"mappings":"ubAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,wIAAAE,KAAA,eAAAC,GAAAH,ICCA,IAAAI,GAAoC,2CACpCC,GAGO,0CACPC,EAA2C,gBCN3C,IAAAC,EAAoC,gBAuBvBC,GAAsB,CACjCC,EACAC,EACAC,EACAC,IACqB,CACrB,GAAM,CAAE,aAAAC,EAAc,mBAAAC,CAAmB,EAAIF,EAAqBG,GAChEA,EAAI,gBAAgB,cAAcN,EAAYC,CAAI,CACpD,EACMM,EAAgB,IACpB,IAAI,MAAM,uCAAuCP,CAAU,IAAIC,CAAI,GAAG,EAElEO,EAAgB,IAAI,QACpBC,EAAuBH,GAAwB,CACnD,GAAIE,EAAc,IAAIF,CAAG,EACvB,OAAOE,EAAc,IAAIF,CAAG,EAI9B,IAAMI,EADSJ,EAAI,SAAS,QAAQ,KAAMK,GAAMA,EAAE,OAASX,CAAU,GAC5C,UAAU,KAAMY,GAAMA,EAAE,OAASX,CAAI,EACxDY,EAASP,EAAI,eAChB,cAAcN,EAAYC,CAAI,EAC9B,IAAIS,EAAS,KAAK,EACrB,OAAAF,EAAc,IAAIF,EAAKO,CAAM,EACtBA,CACT,EAcA,OAAO,OAAO,OAZFC,GAA2B,CACrC,GAAIA,EAAS,CACX,GAAI,CAACV,EAAaU,CAAO,EAAG,MAAMP,EAAc,EAChD,OAAOE,EAAoBK,EAAQ,QAAQ,CAAC,CAC9C,CACA,SAAO,kBACLT,EAAmBH,EAAW,KAAMK,CAAa,EAAE,QACjD,OAAIE,CAAmB,CACzB,CACF,CACF,EAEyB,CAAE,aAAAL,CAAa,CAAC,CAC3C,EC/DA,IAAAW,EAA0D,gBCA1D,IAAAC,EAAiD,gBAEpCC,MAAyD,SAAM,CAC1E,UAAW,IAAM,IAAI,gBAAc,CAAC,EACpC,aAAc,GACd,gBAAiB,GACjB,oBAAqB,EACvB,CAAC,ECPD,IAAAC,GAA2B,+BAC3BC,GAA+C,gBAExC,SAASC,EACdC,EACAC,EACY,CACZ,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,IAAIC,EAAoC,KACpCC,EAAS,GAEPC,EAAUL,EACZ,IAAM,CACJG,GAAc,YAAY,EAC1BD,EAAO,IAAI,aAAY,CACzB,EACA,QAEJC,EAAeJ,EAAO,UAAU,CAC9B,KAAOO,GAAU,CACfL,EAAQK,CAAK,EACbH,GAAc,YAAY,EAC1BC,EAAS,EACX,EACA,MAAQG,GAAM,CACZP,GAAQ,oBAAoB,QAASK,CAAO,EAC5CH,EAAOK,CAAC,CACV,EACA,SAAU,IAAM,CACdP,GAAQ,oBAAoB,QAASK,CAAO,EAC5CH,EAAO,IAAI,MAAM,uCAAuC,CAAC,CAC3D,CACF,CAAC,EAGIE,GAAQJ,GAAQ,iBAAiB,QAASK,CAAO,CACxD,CAAC,CACH,CCrCA,IAAAG,EAAiE,gBAEpDC,GACX,CACEC,EACAC,EAAa,MAEdC,GACC,IAAI,aAAeC,GAAa,CAC9B,IAAIC,EACEC,EAAS,IAAI,IACbC,EAAqB,IAAI,IACzBC,EAAU,IAAI,IAEhBC,EAAY,EACZC,EAAkB,EAClBC,EAAc,EAEZC,EAAmB,IAAM,CAC7B,IAAMC,EAASP,EAAO,IAAII,CAAe,EACzC,GAAI,CAACG,EAAQ,CAETN,EAAmB,OAAS,IAC3B,OAAOF,EAAoB,KAAeA,EAAgB,SAE3DD,EAAS,SAAS,EAEpB,MACF,CACA,IAAMU,EAAMJ,IACZJ,EAAO,OAAOQ,CAAG,EACbH,IAAgBG,GAClBN,EAAQ,IAAIM,EAAK,CAAC,CAAC,EAErBP,EAAmB,IACjBO,EACAD,EAAO,UAAU,CACf,KAAKE,EAAM,CACLJ,IAAgBG,EAClBV,EAAS,KAAKW,CAAC,EAEfP,EAAQ,IAAIM,CAAG,EAAG,KAAKC,CAAC,CAE5B,EACA,UAAW,CAET,GADAR,EAAmB,OAAOO,CAAG,EACzBA,IAAQH,EAEV,IADAA,IACOH,EAAQ,IAAIG,CAAW,IAC5BH,EAAQ,IAAIG,CAAW,EAAG,QAASI,GAAMX,EAAS,KAAKW,CAAC,CAAC,EACzDP,EAAQ,OAAOG,CAAW,EACtB,CAAAJ,EAAmB,IAAII,CAAW,IAGtCA,IAGJC,EAAiB,CACnB,EACA,MAAMI,EAAQ,CACZZ,EAAS,MAAMY,CAAC,CAClB,CACF,CAAC,CACH,CACF,EAEA,OAAAX,EAAkBF,EAAQ,UAAU,CAClC,KAAKc,EAAgB,CACnB,IAAMH,EAAML,IACZH,EAAO,IACLQ,KACA,SAAM,IAAMb,EAAOgB,EAAaH,CAAG,CAAC,CACtC,EACIP,EAAmB,KAAOL,GAC5BU,EAAiB,CAErB,EACA,MAAMI,EAAQ,CACZZ,EAAS,MAAMY,CAAC,CAClB,EACA,UAAW,CACLT,EAAmB,OAAS,GAC9BH,EAAS,SAAS,CAEtB,CACF,CAAC,EAEM,IAAM,CACXG,EAAmB,QAASW,GAAiBA,EAAa,YAAY,CAAC,EACvEb,EAAgB,YAAY,EAC5BC,EAAO,MAAM,EACbE,EAAQ,MAAM,CAChB,CACF,CAAC,EC7FL,IAAAW,EAAyC,gBAE5BC,GACX,CAAOC,EAAiCC,IACvCC,GACC,IAAI,aAAeC,GAAa,CAC9B,IAAIC,EAAqB,IAAI,MACzBC,EAAc,GAEZC,EAAsBC,GAAa,CACvC,IAAMC,EAAM,IAAI,eAChBJ,EAAmB,KAAKI,CAAG,EACvBJ,EAAmB,OAASH,IAC9BG,EAAmB,CAAC,EAAE,YAAY,EAClCA,EAAqBA,EAAmB,MAAM,CAAC,GAGjD,IAAMK,EAAeT,EAAOO,CAAK,EAAE,UAAU,CAC3C,KAAKA,EAAO,CACV,IAAMG,EAAQN,EAAmB,QAAQI,CAAG,EAC5CJ,EAAmB,MAAM,EAAGM,CAAK,EAAE,QAASC,GAAMA,EAAE,YAAY,CAAC,EACjEP,EAAqBA,EAAmB,MAAMM,CAAK,EAEnDP,EAAS,KAAKI,CAAK,CACrB,EACA,MAAMK,EAAO,CACXT,EAAS,MAAMS,CAAK,CACtB,EACA,UAAW,CACT,IAAMF,EAAQN,EAAmB,QAAQI,CAAG,EAC5CJ,EAAmB,OAAOM,EAAO,CAAC,EAE9BN,EAAmB,SAAW,GAAKC,GACrCF,EAAS,SAAS,CACtB,CACF,CAAC,EACDK,EAAI,IAAIC,CAAY,CACtB,EAEMI,EAAoBX,EAAQ,UAAU,CAC1C,KAAKK,EAAO,CACVD,EAAmBC,CAAK,CAC1B,EACA,MAAMO,EAAK,CACTX,EAAS,MAAMW,CAAG,CACpB,EACA,UAAW,CACLV,EAAmB,SAAW,GAAGD,EAAS,SAAS,EACvDE,EAAc,EAChB,CACF,CAAC,EAED,MAAO,IAAM,CACXQ,EAAkB,YAAY,EAC9BT,EAAmB,QAASI,GAAQA,EAAI,YAAY,CAAC,CACvD,CACF,CAAC,ECxDL,IAAAO,GAA2B,gBAEvBC,GAAQ,CAAC,EACAC,GAETC,GAEDC,GACC,IAAI,cAAYC,GAAa,CAC3B,IAAIC,EAAiBL,GACjBM,EAAeH,EAAO,UAAU,CAClC,KAAKI,EAAG,CACNH,EAAS,KAAMC,EAAcE,CAAE,CACjC,EACA,MAAMC,EAAG,CACPJ,EAAS,MAAMI,CAAC,CAClB,EACA,UAAW,CACLH,IAAgBL,GAAOI,EAAS,SAAS,EACxCE,EAAeJ,EAAOG,CAAW,EAAE,UAAUD,CAAQ,CAC5D,CACF,CAAC,EAED,MAAO,IAAM,CACXE,EAAa,YAAY,CAC3B,CACF,CAAC,EL4CE,IAAMG,GAAmB,CAC9BC,EACAC,EACAC,EACAC,IACgB,CAChB,GAAM,CAAE,aAAAC,EAAc,sBAAAC,CAAsB,EAAIF,EAAqBG,GACnEA,EAAI,gBAAgB,WAAWN,EAAQC,CAAI,CAC7C,EACMM,EAAgB,IACpB,IAAI,MAAM,oCAAoCP,CAAM,IAAIC,CAAI,GAAG,EAE3DO,EAAUN,EAAU,WAAW,KACnCG,EAAsBH,EAAYO,GAAMA,EAAE,KAAMF,CAAa,EAC7DG,GAAe,CAAC,CAACC,CAAK,IACpBT,EAAU,UAAUS,EAAM,IAAI,EAAE,QAC9B,OAAKC,GACaA,EAAO,OACpBC,GAAMA,EAAE,MAAM,OAASb,GAAUa,EAAE,MAAM,MAAM,OAASZ,CAC3D,EACe,IAAKQ,IACX,CACL,KAAM,CACJ,MAAOA,EAAE,MACT,MAAAE,CACF,EACA,QAASF,EAAE,MAAM,MAAM,KACzB,EACD,CACF,CACH,CACF,EACAK,EACF,EAYA,MAAO,CAAE,MAVkBC,GACzBP,EAAQ,QAAK,YAAUC,GAAOM,EAAIN,EAAE,OAAQO,GAAMD,EAAEC,EAAE,OAAO,CAAC,EAAIP,CAAE,CAAC,EASvD,KAPQ,OAAM,kBAAeD,CAAO,EAO9B,OALOI,GAC3BA,EACG,OAAQC,GAAMA,EAAE,OAASb,GAAUa,EAAE,MAAM,OAASZ,CAAI,EACxD,IAAKQ,GAAMA,EAAE,MAAM,KAAK,EAEC,aAAAL,CAAa,CAC7C,EM/GA,IAAAa,EAQO,gBAWA,IAAMC,GAAN,MAAMC,CAAQ,CACX,YACEC,EACAC,EACAC,EACR,CAHQ,UAAAF,EACA,gBAAAC,EACA,kBAAAC,CACP,CAKH,OAAO,QACLC,EACAC,EACAC,EACA,CACA,OAAO,IAAIN,EAAQI,EAAKC,EAAWC,CAAW,CAChD,CAKA,SAAU,CACR,OAAO,KAAK,IACd,CAKA,mBAAmBC,EAAgBC,EAAgBC,EAAc,CAC/D,OAAO,KAAK,WAAW,KAAK,aAAaF,CAAM,EAAEC,CAAM,EAAEC,CAAI,CAAC,CAChE,CAKA,gBAAgBA,EAAcC,EAAgB,CAC5C,OAAO,KAAK,WAAW,KAAK,aAAa,KAAKD,CAAI,EAAEC,CAAM,CAAC,CAC7D,CACF,EAUaC,GAAgB,CAC3BN,EACAC,EACAM,IACe,CACf,IAAMC,KAAwB,kBAC5B,iBAAc,CAACD,EAAU,SAAUP,EAAWC,CAAW,CAAC,EAAE,QAC1D,OAAI,CAAC,CAACQ,EAAGT,EAAWC,CAAW,IAC7BQ,EAAIf,GAAQ,QAAQe,EAAGT,EAAWC,CAAW,EAAI,IACnD,CACF,EACA,CACE,UAAW,IAAM,IAAI,gBAAc,CAAC,CACtC,CACF,EACAO,EAAsB,QAAQ,EAE9B,IAAME,EAASF,EAAsB,QACnC,UAAQG,GAAM,EAAQA,CAAE,CAC1B,EACA,OAAAD,EAAO,OAAS,OAAM,kBAAeA,CAAM,EAEpCA,CACT,EAqBaE,EACX,CACEC,EACAC,IAEDC,GAAwD,CACvD,SAASC,EAAiBC,EAAkB,CAC1C,OAAOF,EAAYE,EAAQ,QAAQ,CAAC,IAAMH,EAAsBG,CAAO,CACzE,CAEA,IAAMC,EAA8BD,GAC9BA,EACKD,EAAiBC,CAAO,EAG1BJ,EAAW,OAAO,EAAE,KAAKG,CAAgB,EAE5CG,EAAgB,SAAY,CAChC,IAAMF,EAAU,MAAMJ,EAAW,OAAO,EACxC,OAAQd,GACNgB,EAAYhB,CAAG,IAAMe,EAAsBG,CAAO,CACtD,EAkCA,MAAO,CACL,aAAAC,EACA,cAAAC,EACA,sBArBA,CACEZ,EACAa,EACAC,IAEDC,MACC,iBAAc,CACZA,EAAQ,KAAKf,EAAU,YAAYa,CAAM,CAAC,EAC1CD,EAAc,CAChB,CAAC,EAAE,QACD,OAAI,CAAC,CAAC,CAACV,EAAGV,CAAG,EAAGmB,CAAY,IAAM,CAChC,GAAI,CAACA,EAAanB,CAAG,EACnB,MAAMsB,EAAM,EAEd,MAAO,CAACZ,EAAGV,CAAG,CAChB,CAAC,CACH,EAMF,mBArCyB,CACzBQ,EACAgB,EACAF,OAEA,iBAAc,CAACd,EAAU,mBAAmBgB,CAAI,EAAGJ,EAAc,CAAC,CAAC,EAAE,QACnE,OAAI,CAAC,CAACpB,EAAKmB,CAAY,IAAM,CAC3B,GAAI,CAACA,EAAanB,CAAG,EACnB,MAAMsB,EAAM,EAEd,OAAOtB,CACT,CAAC,CACH,CA0BF,CACF,EChLF,IAAAyB,GAAsB,+BACtBC,EAA8B,gBA6BxBC,GAAiBC,GACjB,OAAOA,GAAY,SAAiB,GAEjC,OAAO,KAAKA,CAAO,EAAE,MACzBC,GACEA,IAAM,MAAQ,OAAOD,EAAQ,IAAO,UACpCC,IAAM,UAAYD,EAAQ,kBAAkB,WACjD,EAGWE,GAAyB,CACpCC,EACAC,EACAC,EACAC,IAC0B,CAC1B,GAAM,CAAE,aAAAC,EAAc,mBAAAC,CAAmB,EAAIF,EAAqBG,GAChEA,EAAI,gBAAgB,iBAAiBN,EAAKC,CAAM,CAClD,EACMM,EAAW,GAAGP,CAAG,IAAIC,CAAM,GAC3BO,EAAgB,IACpB,IAAI,MAAM,0CAA0CD,CAAQ,GAAG,EAoBjE,OAAO,OAAO,OAlBH,IAAIE,IAAqB,CAClC,IAAMZ,EAAUY,EAAKA,EAAK,OAAS,CAAC,EAC9BC,EAAoBd,GAAcC,CAAO,EACzC,CAAE,OAAAc,EAAQ,GAAIC,CAAI,EAAiBF,EAAoBb,EAAU,CAAC,EAClEgB,EAAKD,GAAO,KAEZE,EAAUT,EAAmBH,EAAWW,EAAIL,CAAa,EAAE,QAC/D,YAAUF,GAAQ,CAChB,IAAMS,EAAST,EAAI,eAAe,iBAAiBN,EAAKC,CAAM,EAC9D,OAAOC,EACJ,MAAMW,EAAIN,KAAU,UAAMQ,EAAO,KAAK,IAAIN,CAAI,CAAC,CAAC,EAChD,QAAK,OAAIM,EAAO,MAAM,GAAG,CAAC,CAC/B,CAAC,CACH,EAEA,OAAOC,EAAyBF,EAASH,CAAM,CACjD,EAEyB,CAAE,aAAAP,CAAa,CAAC,CAC3C,ECvEA,IAAAa,EAAoE,gBACpEC,GAA8C,2CAmHxCC,GAAiBC,GACjB,OAAOA,GAAY,SAAiB,GAEjC,OAAO,KAAKA,CAAO,EAAE,MACzBC,GACEA,IAAM,MAAQ,OAAOD,EAAQ,IAAO,UACpCC,IAAM,UAAYD,EAAQ,kBAAkB,WACjD,EAGWE,GAAqB,CAChCC,EACAC,EACAC,EACAC,IAC2B,CAC3B,IAAMC,EAAiBJ,IAAW,UAAYC,IAAS,SACjD,CAAE,aAAAI,EAAc,cAAAC,EAAe,sBAAAC,CAAsB,EACzDJ,EAAqBK,GAAQA,EAAI,gBAAgB,aAAaR,EAAQC,CAAI,CAAC,EAEvEQ,EAAgB,IACpB,IAAI,MAAM,sCAAsCT,CAAM,IAAIC,CAAI,GAAG,EAC7DS,EAAeC,GACnB,IAAI,MAAM,6BAA6BX,CAAM,IAAIC,CAAI,IAAIU,CAAI,GAAG,EAE5DC,EAAa,IAAID,IAAqB,CAC1C,IAAME,EAASF,EAAKA,EAAK,OAAS,CAAC,EAC7BG,EACJD,IAAW,QAAUA,IAAW,YAAcF,EAAK,MAAM,EAAG,EAAE,EAAIA,EAEpE,OAAIP,EACKF,EAAU,YAAY,QAC3B,OAAKa,GAAWA,EAAO,GAAGF,IAAW,OAAS,EAAI,EAAE,EAAG,MAAM,KAC7D,wBAAqB,CACvB,EAEKX,EAAUW,IAAW,OAAS,QAAU,YAAY,EAAE,QAC3D,gBAAa,CAAC,EACdN,EAAsBL,EAAYc,GAAMA,EAAE,KAAMP,CAAa,EAC7DQ,GAAQ,CAAC,CAACC,EAAOV,CAAG,IAAM,CACxB,IAAMW,EAASX,EAAI,eAAe,aAAaR,EAAQC,CAAI,EAC3D,OAAOC,EACJ,SAASgB,EAAM,KAAM,QAAS,IAAMC,EAAO,IAAI,GAAGL,CAAU,CAAC,EAC7D,QAAK,OAAKM,IAAS,CAAE,IAAAA,EAAK,OAAAD,CAAO,EAAE,CAAC,CACzC,EAAG,CAAC,KACJ,wBAAqB,CAACE,EAAGC,IAAMD,EAAE,MAAQC,EAAE,GAAG,KAC9C,OAAI,CAAC,CAAE,IAAAF,EAAK,OAAAD,CAAO,IACjBC,IAAQ,KAAOD,EAAO,SAAWA,EAAO,IAAIC,CAAG,CACjD,CACF,CACF,EAEMG,EAAW,SAAUZ,IAAqB,CAC9C,IAAMd,EAAUc,EAAKA,EAAK,OAAS,CAAC,EAC9Ba,EAAoB5B,GAAcC,CAAO,EACzC,CAAE,OAAA4B,EAAQ,GAAIC,CAAI,EAAiBF,EAAoB3B,EAAU,CAAC,EAClE8B,EAAKD,GAAO,KAEdE,EACJ,GAAIxB,EACFwB,EAAU1B,EAAU,YAAY,QAC9B,OAAKa,GACCY,IAAO,aAAe,CAACA,EAAWZ,EAAO,GAAG,EAAE,EAC9CY,IAAO,OAAeZ,EAAO,GAAG,CAAC,EAC9BA,EAAO,KAAMG,GAAUA,EAAM,OAASS,CAAE,CAChD,KACD,OAAKT,GAAU,CACb,GAAI,CAACA,EAAO,MAAM,IAAI,qBACtB,OAAOA,EAAM,MACf,CAAC,KACD,wBAAqB,CACvB,MACK,CACL,IAAMb,EAAe,MAAMC,EAAc,EACzCsB,EAAU1B,EAAU,SAClByB,EACA,QACCnB,GAAQ,CACP,GAAI,CAACH,EAAaG,CAAG,EAAG,MAAMC,EAAc,EAC5C,IAAMU,EAASX,EAAI,eAAe,aAAaR,EAAQC,CAAI,EACrDa,EACJH,EAAK,SAAWQ,EAAO,IAAMR,EAAOA,EAAK,MAAM,EAAG,EAAE,EACtD,GAAIA,IAASG,GAAc,CAACU,EAAmB,MAAMd,EAAYC,CAAI,EACrE,OAAOQ,EAAO,IAAI,GAAGL,CAAU,CACjC,EACA,KACA,CAACe,EAAMrB,IAAQ,CACb,IAAMW,EAASX,EAAI,eAAe,aAAaR,EAAQC,CAAI,EAC3D,OAAO4B,IAAS,KAAOV,EAAO,SAAWA,EAAO,IAAIU,CAAI,CAC1D,CACF,CACF,CAEA,OAAOC,EAAyBF,EAASH,CAAM,CACjD,EAwCA,MAAO,CAAE,aAAApB,EAAc,SAAAkB,EAAU,UALf,CAACQ,EAA4BC,IAC7C,QAAQ,IACND,EAAQ,IAAKpB,GAASY,EAAS,GAAIS,EAAU,CAAC,GAAGrB,EAAMqB,CAAO,EAAIrB,CAAK,CAAC,CAC1E,EAE0C,WAtCzB,SAAUA,IAAqB,CAChD,IAAMd,EAAUc,EAAKA,EAAK,OAAS,CAAC,EAC9Ba,EAAoB5B,GAAcC,CAAO,EACzC,CAAE,OAAA4B,EAAQ,GAAIC,CAAI,EAAiBF,EAAoB3B,EAAU,CAAC,EAClE8B,EAAKD,GAAO,KAEZrB,EAAe,MAAMC,EAAc,EACnCsB,EAAU1B,EAAU,SACxByB,EACA,oBACCnB,GAAQ,CACP,GAAI,CAACH,EAAaG,CAAG,EAAG,MAAMC,EAAc,EAE5C,IAAMU,EAASX,EAAI,eAAe,aAAaR,EAAQC,CAAI,EAC3D,GAAIU,EAAK,OAASQ,EAAO,IAAK,MAAMT,EAAYC,CAAI,EACpD,IAAMG,EACJH,EAAK,OAAS,GAAKa,EAAoBb,EAAK,MAAM,EAAG,EAAE,EAAIA,EAC7D,GAAIA,EAAK,SAAWQ,EAAO,KAAOL,IAAeH,EAC/C,MAAMD,EAAYC,CAAI,EACxB,OAAOQ,EAAO,IAAI,GAAGL,CAAU,CACjC,EACA,KACA,CAACmB,EAAQzB,IAAQ,CACf,IAAMW,EAASX,EAAI,eAAe,aAAaR,EAAQC,CAAI,EAC3D,OAAOgC,EAAO,IAAI,CAAC,CAAE,IAAAC,EAAK,MAAAC,EAAM,KAAO,CACrC,QAAShB,EAAO,WAAWe,CAAG,EAC9B,MAAOf,EAAO,IAAIgB,EAAK,CACzB,EAAE,CACJ,CACF,EACA,OAAOL,EAAyBF,EAASH,CAAM,CACjD,EAOwD,WAAAb,CAAW,CACrE,EC7PA,IAAAwB,EAUO,4CACPC,EAA2C,+BAC3CC,EAOO,gBAQPC,GAAkC,gCC3BlC,IAAAC,EAA8D,gBCA9D,IAAAC,GAA0B,4CAC1BC,GAAmB,gBCDnB,IAAAC,EAA8B,gBAC9BC,EAMO,4CACPC,EAA+C,2CAC/CC,GAAwB,+BAGXC,EAAQ,IAAI,WAEnBC,MAAwB,WAAQ,QAAQ,EAAE,YAAa,OAAM,CACjE,MACA,cACF,CAAC,EAAE,IAAI,CAAC,EAEKC,EAAsBC,GACjCA,EAAI,UACD,SAASA,EAAI,GAAI,QAAS,IAAMF,GAAuB,IAAI,EAC3D,QAAK,OAAKG,MAAW,YAAQA,CAAO,CAAC,CAAC,EAE9BC,EAAqB,CAACC,EAAkBC,IAAwB,CAC3E,IAAMC,KAAW,eAAYD,EAAS,MAAM,EACtCE,KAAiB,qBAAkBF,CAAQ,EAE3CG,EAAWH,EAAS,QACvB,KAAMI,GAAMA,EAAE,OAAS,QAAQ,EAC/B,UAAW,KAAM,GAAM,EAAE,OAAS,SAAS,EAExCC,EAAgBJ,EAASE,EAAS,IAAI,EACtCG,EAAmBJ,EAAe,gBAAgBC,EAAS,IAAI,EAAE,IAEvE,GAAIE,EAAc,OAAS,SAAU,MAAM,IAAI,MAAM,cAAc,EAEnE,IAAME,EAAWL,EAAe,gBAC9BG,EAAc,MAAMN,CAAQ,EAAE,EAChC,EAAE,IAEF,SAAO,MAAGQ,EAASD,EAAiBH,EAAS,KAAK,EAAEJ,CAAQ,CAAC,CAAC,CAChE,EDrCO,IAAMS,GAA4BC,MACvC,OAAG,CACD,MAAO,aAAU,IAAIA,CAAG,EACxB,iBAAkBC,CACpB,CAAC,EETH,IAAAC,GAAwB,gBACxBC,EAA2C,4CAC3CC,GAAwB,+BAIxB,SAASC,GAAeC,EAAW,CACjC,IAAIC,EAAI,EACR,KAAO,EAAED,EAAI,IACXC,IACAD,IAAM,EAER,OAAOC,CACT,CAEA,IAAMC,MAAS,qBACb,SAAM,CAAC,EAAE,IACRC,GAA6C,CAC5C,IAAMC,EAAS,KAAK,IAAID,EAAM,QAAU,GAAI,CAAC,EACvCE,EAAO,KAAK,IAAI,KAAK,IAAIN,GAAeI,EAAM,MAAM,EAAI,EAAG,CAAC,EAAG,EAAE,EACjEG,EAASH,EAAM,MAAQC,GAAW,EACxC,OAAO,MAAI,IAAIC,EAAOC,CAAK,CAC7B,CACF,EAEMC,GAAO,IAAI,WAAW,CAAC,CAAC,CAAC,EAClBC,GAAiB,CAC5BC,EACAC,IACoB,CACpB,GAAI,CAACD,EACH,OAAOE,EAAmBD,CAAG,EAAE,QAC7B,QAAKE,IAAsB,CACzB,iBAAAA,EACA,MAAOL,EACT,EAAE,CACJ,EAEF,GAAM,CAAE,OAAAM,EAAQ,YAAAC,CAAY,EAAIL,EAChC,SAAO,OAAG,CACR,oBAAkB,YAAQC,EAAI,EAAE,EAChC,MAAOR,GAAO,CACZ,OAAAW,EACA,MAAOC,EAAcD,CACvB,CAAC,CACH,CAAC,CACH,EC9CA,IAAAE,GAAmB,gBACnBC,EAKO,4CAIP,IAAMC,MAAU,UAAO,CACrB,IAAK,UACL,SAAO,aAAO,SAAM,GAAQ,CAAC,CAC/B,CAAC,EAAE,IAEUC,GAAuB,CAClCC,EACAC,OAEA,OAAG,CACD,MAAOH,GAAQ,CACb,IAAAE,EACA,MAAAC,CACF,CAAC,EACD,iBAAkBC,CACpB,CAAC,ECzBH,IAAAC,GAAA,GAAAC,GAAAD,GAAA,kBAAAE,GAAA,sBAAAC,GAAA,eAAAC,GAAA,qBAAAC,GAAA,mBAAAC,GAAA,aAAAC,KCAA,IAAAC,GAAoB,gBAIb,IAAMC,GAAyCC,GACpDC,EAAmBD,CAAG,EAAE,QACtB,QAAKE,IAAsB,CAAE,MAAOC,EAAO,iBAAAD,CAAiB,EAAE,CAChE,ECPF,IAAAE,GAAmB,gBAGNC,GAA6C,OACxD,OAAG,CACD,MAAO,WAAW,KAAK,CAAC,CAAC,CAAC,EAC1B,iBAAkB,WAAW,KAAK,CAAC,CAAC,CAAC,CACvC,CAAC,ECPH,IAAAC,GAA6B,gBAC7BC,EAA2C,4CAM3C,IAAAC,GAA+B,+BAEzBC,GAAqB,gCACrBC,GAAe,CACnB,EAAG,KAAG,IACN,EAAG,MAAI,IACP,EAAG,MAAI,IACP,EAAG,MAAI,GACT,EAEaC,GAAYC,MACvB,OAAG,CAAE,MAAO,UAAQ,IAAIA,CAAK,EAAG,iBAAkBC,CAAM,CAAC,EAE9CC,GAAuCC,GAClDA,EAAI,UAAU,MAAMA,EAAI,GAAIN,MAAoB,UAAMM,EAAI,IAAI,CAAC,EAAE,QAC/D,aAAUC,GAAW,CACnB,IAAMC,KAAQ,YAAQD,CAAM,EACtBE,EAAUR,GAAaO,EAAM,MAAmB,EACtD,GAAI,CAACC,EACH,MAAM,IAAI,MAAM,GAAGT,EAAkB,uBAAuB,EAC9D,OAAOE,GAASO,EAAQD,CAAK,CAAC,CAChC,CAAC,CACH,EC7BF,IAAAE,GAAoB,gBAIb,IAAMC,GAA4C,CAAC,CAAE,SAAAC,CAAS,IACnEC,EAAmB,eAAgBD,CAAQ,EAAE,QAC3C,QAAKE,IAAsB,CAAE,iBAAAA,EAAkB,MAAOC,CAAM,EAAE,CAChE,ECPF,IAAAC,GAAoB,gBAIb,IAAMC,GAA0C,CAAC,CAAE,SAAAC,CAAS,IACjEC,EAAmB,sBAAuBD,CAAQ,EAAE,QAClD,QAAKE,IAAsB,CAAE,iBAAAA,EAAkB,MAAOC,CAAM,EAAE,CAChE,EVEF,IAAAC,GAAsB,4CAUf,IAAMC,GAMiB,CAC5BC,EACAC,EACAC,EACAC,EACAC,EAAS,CAAC,IAEVJ,EAAU,mBAAmBG,EAAQ,IAAI,EAAE,QACzC,QAAK,CAAC,KACN,YAAUE,GAAQ,CAChB,IAAMC,EAAsB,CAC1B,SAAUD,EAAI,SACd,UAAWL,EACX,SAAUE,EACV,GAAIC,EAAQ,KACZ,KAAMF,EAAO,SACf,EAEMM,EAAmDH,EAAO,UAE5DA,EAAO,UAAU,OACf,CAAE,OAAQA,EAAO,UAAU,OAAQ,YAAaD,EAAQ,MAAO,EAC/D,OAHF,CAAE,OAAQ,GAAI,YAAaA,EAAQ,MAAO,EAK9C,SAAO,iBACLE,EAAI,SAAS,UAAU,iBAAiB,IACtC,CAAC,CAAE,WAAAG,EAAY,KAAAC,EAAM,iBAAAC,CAAiB,IAAM,CAC1C,GAAIF,IAAe,iBACjB,OAAOG,GAAeJ,EAAWD,CAAmB,EAEtD,GAAIE,IAAe,2BACjB,OAAOI,GAAyBR,EAAO,KAAO,EAAE,EAElD,GAAII,IAAe,uBACjB,OAAOK,GAAqBT,EAAO,KAAO,GAAIA,EAAO,KAAK,EAE5D,GAAII,IAAe,cAAgB,UAAWJ,EAC5C,OAA6BU,GAASV,EAAO,KAAM,EAErD,IAAMW,EAAKC,GAAsBR,CAA4B,EAC7D,GAAI,CAACO,EAAI,CACP,GACEV,EAAI,eAAe,gBAAgBI,CAAI,IAAM,UAC7CJ,EAAI,eAAe,gBAAgBK,CAAgB,IAAM,SAEzD,SAAO,MAAG,CACR,MAAOO,EACP,iBAAkBA,CACpB,CAAC,EAEH,MAAM,IAAI,MAAM,iCAAiCT,CAAU,EAAE,CAC/D,CACA,OAAOO,EAAGT,CAAmB,CAC/B,CACF,CACF,EAAE,QACA,YAAUY,GACRjB,EAAO,KACLC,EACA,OAAO,YACLG,EAAI,SAAS,UAAU,iBAAiB,IACtC,CAAC,CAAE,WAAAG,CAAW,EAAGW,IAAQ,CACvBX,EACA,CAAE,WAAAA,EAAY,GAAGU,EAAiBC,CAAG,CAAE,CACzC,CACF,CACF,EACAd,EAAI,YACJF,EAAQ,MACV,CACF,CACF,CACF,CAAC,CACH,EWlGF,IAAAiB,GAAqC,4CACrCC,EAWO,gBASP,IAAAC,GAA+B,+BAGzBC,GAAcC,MAAkB,aAAM,iBAAU,YAAQA,CAAE,CAAC,CAAC,EAE5DC,GAAe,CACnBC,EACAC,IAEA,IAAI,aAODC,GAAa,CACd,IAAMC,EAAiB,IAAI,IACvBC,EACAC,EAQEC,EAAmB,IAAM,CAC7B,IAAIC,EAAkBH,EAAa,KAC/BI,EAAsCL,EAAe,IAAII,CAAO,EAEpE,KAAO,CAACC,GAAU,CAChB,IAAMC,EAAQL,EAAa,OAAO,IAAIG,CAAO,EAC7C,GAAI,CAACE,EAAO,MACZD,EAAWL,EAAe,IAAKI,EAAUE,EAAM,MAAO,CACxD,CAEA,GAAI,CAACD,EAAU,OAEf,IAAME,EACJN,EAAa,OAAO,IAAII,EAAS,IAAI,EAAG,QACxCJ,EAAa,OAAO,IAAIA,EAAa,SAAS,EAAG,OAE7CO,EAAQH,EAAS,MAAM,KAC7B,GACEG,GACA,OAAON,GAAgB,UACvBA,EAAY,OAASG,EAAS,KAC9B,CACIE,GAAaR,EAAS,SAAS,EACnC,MACF,CAEAA,EAAS,KACNG,EAAcM,EACX,CACE,KAAMH,EAAS,KACf,GAAGA,EAAS,KACd,EACAA,EAAS,MAAM,OACrB,EAEIE,IACEC,EAAOT,EAAS,SAAS,EACnBM,EAAS,MAAM,SAASN,EAAS,MAAM,IAAI,MAAM,SAAS,CAAC,EAEzE,EAEMU,EAAeX,EAClB,QACC,wBACE,CAACY,EAAGC,IAAMD,EAAE,YAAcC,EAAE,WAAaD,EAAE,OAASC,EAAE,IACxD,CACF,EACC,UAAU,CACT,KAAOC,GAAyB,CAC9BX,EAAeW,EACXZ,EAAe,OAAS,GAC5BG,EAAiB,CACnB,EACA,MAAMU,EAAG,CACPd,EAAS,MAAMc,CAAC,CAClB,CACF,CAAC,EAEH,OAAAJ,EAAa,IACXZ,EAAU,UAAU,CAClB,KAAOS,GAAU,CACfN,EAAe,IAAIM,EAAM,KAAMA,CAAK,EACpCH,EAAiB,CACnB,EACA,MAAMU,EAAG,CACPd,EAAS,MAAMc,CAAC,CAClB,CACF,CAAC,CACH,EAEOJ,CACT,CAAC,EAAE,QAAK,wBAAqB,CAACC,EAAGC,IAAMD,IAAMC,CAAC,CAAC,EAE3CG,GAA+B,CACnCC,EACAC,IACmC,CACnC,IAAMC,EAASF,EACZ,OAAQG,GAAMA,EAAE,MAAM,OAAS,kBAAoBA,EAAE,MAAM,QAAUF,CAAK,EAC1E,IAAKE,GAAMA,EAAE,KAAK,EAEfC,EAAYF,EAAOA,EAAO,OAAS,CAAC,EAI1C,MAAO,CAAE,GAFPE,EAAU,OAAS,UAAYA,EAAU,MAAM,OAAS,mBAE7C,OAAAF,CAAO,CACtB,EAEaG,EAAU,CACrBC,EACAC,EACA3B,EACA4B,EACAC,EAAW,KACa,CACxB,IAAMC,EAAS/B,GAAWC,CAAE,EACtB+B,EAAa,CAIjBC,EACAC,KAEC,CACC,KAAAD,EACA,OAAAF,EACA,GAAGG,CACL,GAOIC,EALMR,EAAU,cAAc,QAClC,QAAK,CAAC,KACN,OAAKS,GAAWA,EAAO,OAAO,IAAIP,CAAG,GAAG,MAAQO,EAAO,SAAS,CAClE,EAEyC,QACvC,YAAUP,GACRF,EAAU,YAAYE,EAAI5B,CAAE,EAAE,QAC5B,UAAQuB,GAAM,CAACA,CAAC,KAChB,OAAI,IAAM,CACR,MAAM,IAAI,MAAM,SAAS,CAC3B,CAAC,CACH,CACF,CACF,EAEMa,EAAS,IAAI,aAA2BhC,GAAa,CACzD,IAAMU,EAAeY,EAAU,SAAS1B,CAAE,EAAE,UAAUI,CAAQ,EAC9D,OAAAU,EAAa,IACXa,EAAa3B,CAAE,EAAE,UAAU,CACzB,MAAMkB,EAAG,CACPd,EAAS,MAAMc,CAAC,CAClB,CACF,CAAC,CACH,EACOJ,CACT,CAAC,EAEKuB,EAAkBpC,GAAamC,EAAQV,EAAU,aAAa,EAAE,QACpE,OAAKH,GACCA,IAAM,IAAQA,IAAM,GACfQ,EAAW,oBAAqB,CACrC,MAAO,GACP,QAASR,CACX,CAAC,EAEIQ,EAAW,oBAAqB,CACrC,MAAO,GACP,MAAO,CACL,MAAOR,EAAE,MACT,KAAMA,EAAE,IACV,EACA,GAAGJ,GAA6BI,EAAE,OAAQA,EAAE,KAAK,CACnD,CAAC,CACF,CACH,EAEA,SAAO,UACLM,KAAW,MAAGE,EAAW,SAAU,CAAC,CAAC,CAAC,EAAI,QAC1CG,KACA,MAAGH,EAAW,cAAe,CAAC,CAAC,CAAC,EAChCM,EAAgB,KACdC,GAAa,CAAC,CAAE,MAAAzB,EAAO,KAAAmB,EAAM,GAAGC,CAAK,IACnCpB,KAAQ,MAAGkB,EAAW,YAAaE,CAAW,CAAC,EAAI,OACrD,CACF,CACF,CACF,EAEaM,EAAS,MACpBb,EACAC,EACAa,EACAZ,OAEA,iBAAcH,EAAQC,EAAWC,EAAca,EAAaZ,CAAE,CAAC,EAAE,KAAML,GAAM,CAC3E,GAAIA,EAAE,OAAS,YAAa,MAAM,KAClC,IAAMkB,EAA6B,CAAE,GAAGlB,CAAE,EAC1C,cAAQkB,EAAe,KAChBA,CACT,CAAC,EZzLH,IAAMC,MAAe,aAAU,EAAE,IAC3BC,MAAkB,SAAM,UAAS,UAAS,KAAI,MAAI,EAAE,IACpDC,GAAgBC,GAA0BF,GAAgBE,CAAK,EAAE,CAAC,EAClEC,GAAgB,IAAI,WAAW,EAAE,EACjCC,GAAmB,IAAMD,GAElBE,GAAgB,CAM3BC,EACAC,EACAC,EACAC,EACAC,EACAC,IAC+C,CAC/C,GAAM,CAAE,aAAAC,EAAc,mBAAAC,CAAmB,EAAIF,EAAqBG,GAChEA,EAAI,gBAAgB,UAAUR,EAAQC,CAAI,CAC5C,EACMQ,EAAgB,IACpB,IAAI,MAAM,iCAAiCT,CAAM,IAAIC,CAAI,GAAG,EA0H9D,OAAO,OAAO,OAxHFS,GAAmB,CAC7B,IAAMC,EAAyB,CAC7B,CAAE,eAAAC,EAAgB,MAAO,CAACC,EAAUC,CAAU,CAAE,EAChDJ,EACAK,EAAqC,CAAC,IACnC,CACH,IAAIC,EAAgBD,EACpB,GAAIA,EAAU,MAAO,CACnB,GAAIb,IAAkBY,EACpB,MAAM,IAAI,MAAM,4BAA4B,EAC9CE,EAAgB,CAAE,GAAGD,EAAW,MAAOF,EAASE,EAAU,KAAK,CAAE,CACnE,CAEA,GAAM,CAAE,SAAAE,GAAU,MAAAC,EAAM,EAAIN,EAAe,UAAUZ,EAAQC,CAAI,EACjE,MAAO,CACL,SAAU,SAAO,aACf,cAAW,IAAI,WAAWgB,EAAQ,EAAGC,GAAM,IAAIR,CAAG,CAAC,CACrD,EACA,QAASM,CACX,CACF,EAEMG,EAAe,CAACT,EAAUU,EAAmC,CAAC,IAClEb,EAAmBJ,EAAW,KAAMM,CAAa,EAAE,QACjD,OAAKD,GAAQG,EAAuBH,EAAKE,EAAKU,CAAO,CAAC,CACxD,EAEIC,EAA0BC,GAA2B,CACzD,GAAI,CAACA,EACH,SAAO,kBAAeH,EAAaT,CAAG,EAAE,QAAK,OAAKa,GAAMA,EAAE,QAAQ,CAAC,CAAC,EAEtE,GAAI,CAACjB,EAAagB,CAAO,EAAG,MAAMb,EAAc,EAChD,OAAOE,EAAuBW,EAAQ,QAAQ,EAAGZ,CAAG,EAAE,QACxD,EAEMc,EAAQ,CACZC,EACA,CAAE,GAAGC,CAAS,EACdC,IAEAR,EAAaT,EAAKgB,CAAQ,EAAE,QAC1B,YAAS,CAAC,CAAE,SAAAE,EAAU,QAAAR,CAAQ,IAC5BS,GAAS1B,EAAWsB,EAAMG,EAAS,QAAQ,EAAGD,EAASP,CAAO,CAChE,CACF,EAEIU,EAAQ,CACZL,EACA,CAAE,GAAAM,EAAI,GAAGL,CAAS,EAAmB,CAAC,KAGpC,CAACK,GAAMA,IAAO,YACV5B,EAAU,WACV4B,IAAO,OACL5B,EAAU,MACVA,EAAU,YAAY,QACpB,OAAKoB,GAAMA,EAAE,KAAMS,GAAMA,EAAE,OAASD,CAAE,CAAC,CACzC,GACN,QACA,QAAK,CAAC,KACN,YAAUJ,GACRA,EACIH,EAAMC,EAAMC,EAAUC,CAAO,EAAE,QAC7B,OAAKM,IAAY,CACf,MAAI,SAAMA,CAAM,EAChB,MAAON,CACT,EAAE,CACJ,KACA,cAAW,IAAM,IAAI,MAAM,gBAAgBI,CAAE,EAAE,CAAC,CACtD,CACF,EAGIG,EAAwB,CAACT,EAAML,OACnC,kBAAeU,EAAML,EAAML,CAAO,CAAC,EAAE,KAAMG,GAAMA,EAAE,EAAE,EAEjDY,EAAkC,CAACV,EAAMC,OAC7C,kBAAeI,EAAML,EAAMC,CAAQ,CAAC,EAAE,KAAK,CAAC,CAAE,GAAAU,EAAI,MAAAC,CAAM,IACtDC,EAAOnC,EAAWC,EAAWgC,EAAIC,EAAM,IAAI,CAC7C,EAEIE,EAA0C,CAACd,EAAMC,IACrDI,EAAML,EAAMC,CAAQ,EAAE,QACpB,YAAS,CAAC,CAAE,GAAAU,EAAI,MAAAC,CAAM,IACpBG,EAAQrC,EAAWC,EAAWgC,EAAIC,EAAM,KAAM,EAAI,CACpD,CACF,EAqBF,MAAO,CACL,iBApBuB,MACvBZ,EACAC,IACG,CACH,IAAMe,KAAa,sBACjBhB,aAAgB,WAAaA,EAAOhC,GAAagC,CAAI,EACrD,UACA3B,EACF,EACM4C,KAAU,WAAQ,MAAMR,EAAKO,EAAYf,CAAQ,CAAC,EAClDiB,KAAO,YAAM,cAAWD,EAAS,MAAI,IAAIA,EAAQ,MAAM,CAAC,CAAC,EAE/D,SAAO,kBACLvC,EACG,MAAM,KAAM,mCAAoCwC,CAAI,EACpD,QAAK,OAAIhD,EAAY,CAAC,CAC3B,CACF,EAIE,YAAa,CACX,KAAMK,EACN,SAAO,QAAKC,EAAMS,CAAU,CAC9B,EACA,eAAAW,EACA,KAAAa,EACA,mBAAAK,EACA,cAAAJ,CACF,CACF,EAEyB,CAAE,aAAA7B,CAAa,CAAC,CAC3C,EX5KA,IAAMsC,GAAiB,CACrBC,EACAC,EACAC,IACgB,CAChB,IAAMC,EAAUC,GACdJ,EAAgB,UAChBA,EAAgB,YAChBC,CACF,EAEMI,EAAS,CAAC,EACVC,EAAeC,GACnB,IAAI,MAAMF,EAAQ,CAChB,IAAIG,EAAGC,EAAM,CACX,OAAOF,EAASE,CAAc,CAChC,CACF,CAAC,EACGC,EAAsBC,GAA0C,CACpE,IAAMC,EAA2C,CAAC,EAClD,OAAON,EAAaO,IACbD,EAAMC,CAAC,IAAGD,EAAMC,CAAC,EAAI,CAAC,GACpBP,EAAaQ,IACbF,EAAMC,CAAC,EAAEC,CAAC,IAAGF,EAAMC,CAAC,EAAEC,CAAC,EAAIH,EAASE,EAAGC,CAAC,GACtCF,EAAMC,CAAC,EAAEC,CAAC,EAClB,EACF,CACH,EAEMC,EAAQL,EAAgB,CAACM,EAAQC,IACrCC,GACEF,EACAC,EACAhB,EACAkB,EAAoBhB,EAAUiB,GAC5BA,EAAE,6BAAmCJ,EAAQC,CAAI,CACnD,CACF,CACF,EAEMI,EAAKX,EAAgB,CAACM,EAAQC,IAClCK,GACEN,EACAC,EACAjB,EAAgB,MAChBC,EACAC,EACAiB,EAAoBhB,EAAUiB,GAC5BA,EAAE,wBAA8BJ,EAAQC,CAAI,CAC9C,CACF,CACF,EAEMM,EAAQb,EAAgB,CAACM,EAAQC,IACrCO,GACER,EACAC,EACAhB,EACAkB,EAAoBhB,EAAUiB,GAC5BA,EAAE,4BAAiCJ,EAAQC,CAAI,CACjD,CACF,CACF,EAEMQ,EAAYf,EAAgB,CAACM,EAAQC,IACzCS,GACEV,EACAC,EACAhB,EACAkB,EAAoBhB,EAAUiB,GAC5BA,EAAE,+BAAiCJ,EAAQC,CAAI,CACjD,CACF,CACF,EAEMU,EAAOjB,EAAgB,CAACkB,EAAKC,IACjCC,GACEF,EACAC,EACA5B,EACAkB,EAAoBhB,EAAUiB,GAAMA,EAAE,gBAAgBQ,EAAKC,CAAM,CAAC,CACpE,CACF,EAEA,MAAO,CACL,MAAAd,EACA,GAAAM,EACA,MAAAE,EACA,KAAAI,EACA,UAAAF,EACA,QAAAtB,CACF,CACF,EAuBO,SAAS4B,GAAaC,EAA2C,CACtE,IAAMC,KAA6B,GAAAC,cAAgBF,CAAQ,EACrDG,KAAS,wBAAoBF,CAAS,EACtChC,EAAYkC,EAAO,WAAW,EAE9B,CAAE,iBAAAC,CAAiB,EAAIH,EAEvBI,EAGgBJ,EAAU,QAE1B,CAAE,aAAAK,CAAa,EAAIH,EACzB,MAAO,CACL,iBAAAC,EAEA,gBAAiBnC,EAAU,WAC3B,kBAAmB,OAAM,kBAAeA,EAAU,UAAU,EAE5D,YAAaA,EAAU,YACvB,cAAe,OAAM,kBAAeA,EAAU,WAAW,EAEzD,eAAgBA,EAAU,MAC1B,aAAesC,MAAiB,kBAAetC,EAAU,MAAMsC,CAAI,CAAC,EAEpE,eAAiBA,MACf,kBAAetC,EAAU,QAAQsC,GAAQ,IAAI,CAAC,EAEhD,OAAQ,IAAIC,IAASC,EAAOxC,EAAWqC,EAAc,GAAGE,CAAI,EAC5D,eAAgB,IAAIA,IAASE,EAAQzC,EAAWqC,EAAc,GAAGE,CAAI,EAErE,YAAyCxC,GACvCD,GAAeC,EAAiBC,EAAWqC,CAAY,EAEzD,QAAS,IAAM,CACbrC,EAAU,SAAS,EACnBkC,EAAO,QAAQ,CACjB,EAEA,SAAAE,CACF,CACF,CwBrKA,IAAAM,EAOO","names":["src_exports","__export","createClient","__toCommonJS","import_observable_client","import_substrate_client","import_rxjs","import_rxjs","createConstantEntry","palletName","name","chainHead","compatibilityHelper","isCompatible","compatibleRuntime$","ctx","checksumError","cachedResults","getValueWithContext","constant","p","c","result","runtime","import_rxjs","import_rxjs","shareLatest","import_utils","import_rxjs","firstValueFromWithSignal","source","signal","resolve","reject","subscription","isDone","onAbort","value","e","import_rxjs","concatMapEager","mapper","concurrent","source$","observer","topSubscription","queues","innerSubscriptions","results","mapperIdx","subscriptionIdx","observerIdx","nextSubscription","inner$","idx","x","e","outterValue","subscription","import_rxjs","raceMap","mapper","concurrent","source$","observer","innerSubscriptions","isOuterDone","createSubscription","value","sub","subscription","index","s","error","outerSubscription","err","import_rxjs","NOTIN","continueWith","mapper","source","observer","latestValue","subscription","v","e","createEventEntry","pallet","name","chainHead","compatibilityHelper","isCompatible","withCompatibleRuntime","ctx","checksumError","shared$","x","concatMapEager","block","events","e","shareLatest","f","d","import_rxjs","Runtime","_Runtime","_ctx","_checksums","_descriptors","ctx","checksums","descriptors","opType","pallet","name","method","getRuntimeApi","chainHead","runtimeWithChecksums$","x","result","v","compatibilityHelper","runtimeApi","getDescriptorChecksum","getChecksum","isCompatibleSync","runtime","isCompatible","waitChecksums","mapper","error","source$","hash","import_utils","import_rxjs","isOptionalArg","lastArg","k","createRuntimeCallEntry","api","method","chainHead","compatibilityHelper","isCompatible","compatibleRuntime$","ctx","callName","checksumError","args","isLastArgOptional","signal","_at","at","result$","codecs","firstValueFromWithSignal","import_rxjs","import_observable_client","isOptionalArg","lastArg","k","createStorageEntry","pallet","name","chainHead","compatibilityHelper","isSystemNumber","isCompatible","waitChecksums","withCompatibleRuntime","ctx","checksumError","invalidArgs","args","watchValue","target","actualArgs","blocks","x","raceMap","block","codecs","val","a","b","getValue","isLastArgOptional","signal","_at","at","result$","data","firstValueFromWithSignal","keyArgs","options","values","key","value","import_substrate_bindings","import_utils","import_rxjs","import_signer","import_rxjs","import_substrate_bindings","import_rxjs","import_rxjs","import_substrate_bindings","import_metadata_builders","import_utils","empty","genesisHashStorageKey","genesisHashFromCtx","ctx","result","systemVersionProp$","propName","metadata","lookupFn","dynamicBuilder","constant","x","systemVersion","systemVersionDec","valueEnc","ChargeTransactionPayment","tip","empty","import_rxjs","import_substrate_bindings","import_utils","trailingZeroes","n","i","mortal","value","factor","left","right","zero","CheckMortality","input","ctx","genesisHashFromCtx","additionalSigned","period","blockNumber","import_rxjs","import_substrate_bindings","encoder","ChargeAssetTxPayment","tip","asset","empty","chain_exports","__export","CheckGenesis","CheckMetadataHash","CheckNonce","CheckSpecVersion","CheckTxVersion","getNonce","import_rxjs","CheckGenesis","ctx","genesisHashFromCtx","additionalSigned","empty","import_rxjs","CheckMetadataHash","import_rxjs","import_substrate_bindings","import_utils","NONCE_RUNTIME_CALL","lenToDecoder","getNonce","input","empty","CheckNonce","ctx","result","bytes","decoder","import_rxjs","CheckSpecVersion","metadata","systemVersionProp$","additionalSigned","empty","import_rxjs","CheckTxVersion","metadata","systemVersionProp$","additionalSigned","empty","import_substrate_bindings","createTx","chainHead","signer","callData","atBlock","hinted","ctx","signedExtensionsCtx","mortality","identifier","type","additionalSigned","CheckMortality","ChargeTransactionPayment","ChargeAssetTxPayment","getNonce","fn","chain_exports","empty","signedExtensions","idx","import_substrate_bindings","import_rxjs","import_utils","hashFromTx","tx","computeState","analized$","blocks$","observer","analyzedBlocks","pinnedBlocks","latestState","computeNextState","current","analyzed","block","isFinalized","found","subscription","a","b","pinned","e","getTxSuccessFromSystemEvents","systemEvents","txIdx","events","x","lastEvent","submit$","chainHead","broadcastTx$","at","emitSign","txHash","getTxEvent","type","rest","validate$","blocks","track$","bestBlockState$","continueWith","submit","transaction","result","accountIdEnc","queryInfoRawDec","queryInfoDec","input","fakeSignature","getFakeSignature","createTxEntry","pallet","name","assetChecksum","chainHead","broadcast","compatibilityHelper","isCompatible","compatibleRuntime$","ctx","checksumError","arg","getCallDataWithContext","dynamicBuilder","assetEnc","assetCheck","txOptions","returnOptions","location","codec","getCallData$","options","getEncodedData","runtime","x","sign$","from","_options","atBlock","callData","createTx","_sign","at","b","signed","sign","signAndSubmit","tx","block","submit","signSubmitAndWatch","submit$","fakeSigner","encoded","args","createTypedApi","chainDefinition","chainHead","broadcast$","runtime","getRuntimeApi","target","createProxy","propCall","_","prop","createProxyPath","pathCall","cache","a","b","query","pallet","name","createStorageEntry","compatibilityHelper","r","tx","createTxEntry","event","createEventEntry","constants","createConstantEntry","apis","api","method","createRuntimeCallEntry","createClient","provider","rawClient","createRawClient","client","getChainSpecData","_request","broadcastTx$","hash","args","submit","submit$","import_substrate_bindings"]}
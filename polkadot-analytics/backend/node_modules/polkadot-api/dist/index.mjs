var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/client.ts
import { getObservableClient } from "@polkadot-api/observable-client";
import {
  createClient as createRawClient
} from "@polkadot-api/substrate-client";
import { firstValueFrom as firstValueFrom5 } from "rxjs";

// src/constants.ts
import { firstValueFrom, map } from "rxjs";
var createConstantEntry = (palletName, name, chainHead, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildConstant(palletName, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Constant(${palletName}.${name})`);
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName);
    const constant = pallet?.constants.find((c) => c.name === name);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (runtime) => {
    if (runtime) {
      if (!isCompatible(runtime))
        throw checksumError();
      return getValueWithContext(runtime._getCtx());
    }
    return firstValueFrom(
      compatibleRuntime$(chainHead, null, checksumError).pipe(
        map(getValueWithContext)
      )
    );
  };
  return Object.assign(fn, { isCompatible });
};

// src/event.ts
import { firstValueFrom as firstValueFrom2, map as map2, mergeMap } from "rxjs";

// src/utils/shareLatest.ts
import { ReplaySubject, share } from "rxjs";
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/firstValueFromWithSignal.ts
import { AbortError } from "@polkadot-api/utils";
import { noop } from "rxjs";
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription?.unsubscribe();
      reject(new AbortError());
    } : noop;
    subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        subscription?.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e);
      },
      complete: () => {
        signal?.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
      }
    });
    if (!isDone)
      signal?.addEventListener("abort", onAbort);
  });
}

// src/utils/concatMapEager.ts
import { defer, Observable as Observable3 } from "rxjs";
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable3((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        defer(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/raceMap.ts
import { Observable as Observable4, Subscription as Subscription3 } from "rxjs";
var raceMap = (mapper, concurrent) => (source$) => new Observable4((observer) => {
  let innerSubscriptions = new Array();
  let isOuterDone = false;
  const createSubscription = (value) => {
    const sub = new Subscription3();
    innerSubscriptions.push(sub);
    if (innerSubscriptions.length > concurrent) {
      innerSubscriptions[0].unsubscribe();
      innerSubscriptions = innerSubscriptions.slice(1);
    }
    const subscription = mapper(value).subscribe({
      next(value2) {
        const index = innerSubscriptions.indexOf(sub);
        innerSubscriptions.slice(0, index).forEach((s) => s.unsubscribe());
        innerSubscriptions = innerSubscriptions.slice(index);
        observer.next(value2);
      },
      error(error) {
        observer.error(error);
      },
      complete() {
        const index = innerSubscriptions.indexOf(sub);
        innerSubscriptions.splice(index, 1);
        if (innerSubscriptions.length === 0 && isOuterDone)
          observer.complete();
      }
    });
    sub.add(subscription);
  };
  const outerSubscription = source$.subscribe({
    next(value) {
      createSubscription(value);
    },
    error(err) {
      observer.error(err);
    },
    complete() {
      if (innerSubscriptions.length === 0)
        observer.complete();
      isOuterDone = true;
    }
  });
  return () => {
    outerSubscription.unsubscribe();
    innerSubscriptions.forEach((sub) => sub.unsubscribe());
  };
});

// src/utils/continue-with.ts
import { Observable as Observable5 } from "rxjs";
var NOTIN = {};
var continueWith = (mapper) => (source) => new Observable5((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN)
        observer.complete();
      else
        subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

// src/event.ts
var createEventEntry = (pallet, name, chainHead, compatibilityHelper2) => {
  const { isCompatible, withCompatibleRuntime } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildEvent(pallet, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead.finalized$.pipe(
    withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),
    concatMapEager(
      ([block]) => chainHead.eventsAt$(block.hash).pipe(
        map2((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe(mergeMap((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => firstValueFrom2(shared$);
  const filter3 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter3, isCompatible };
};

// src/runtime.ts
import {
  ReplaySubject as ReplaySubject2,
  combineLatest,
  connectable,
  filter,
  firstValueFrom as firstValueFrom3,
  map as map3
} from "rxjs";
var Runtime = class _Runtime {
  constructor(_ctx, _checksums, _descriptors) {
    this._ctx = _ctx;
    this._checksums = _checksums;
    this._descriptors = _descriptors;
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  static _create(ctx, checksums, descriptors) {
    return new _Runtime(ctx, checksums, descriptors);
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getCtx() {
    return this._ctx;
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getPalletChecksum(opType, pallet, name) {
    return this._checksums[this._descriptors[opType][pallet][name]];
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getApiChecksum(name, method) {
    return this._checksums[this._descriptors.apis[name][method]];
  }
};
var getRuntimeApi = (checksums, descriptors, chainHead) => {
  const runtimeWithChecksums$ = connectable(
    combineLatest([chainHead.runtime$, checksums, descriptors]).pipe(
      map3(
        ([x, checksums2, descriptors2]) => x ? Runtime._create(x, checksums2, descriptors2) : null
      )
    ),
    {
      connector: () => new ReplaySubject2(1)
    }
  );
  runtimeWithChecksums$.connect();
  const result = runtimeWithChecksums$.pipe(
    filter((v) => Boolean(v))
  );
  result.latest = () => firstValueFrom3(result);
  return result;
};
var compatibilityHelper = (runtimeApi, getDescriptorChecksum) => (getChecksum) => {
  function isCompatibleSync(runtime) {
    return getChecksum(runtime._getCtx()) === getDescriptorChecksum(runtime);
  }
  const isCompatible = (runtime) => {
    if (runtime) {
      return isCompatibleSync(runtime);
    }
    return runtimeApi.latest().then(isCompatibleSync);
  };
  const waitChecksums = async () => {
    const runtime = await runtimeApi.latest();
    return (ctx) => getChecksum(ctx) === getDescriptorChecksum(runtime);
  };
  const compatibleRuntime$ = (chainHead, hash, error) => combineLatest([chainHead.getRuntimeContext$(hash), waitChecksums()]).pipe(
    map3(([ctx, isCompatible2]) => {
      if (!isCompatible2(ctx)) {
        throw error();
      }
      return ctx;
    })
  );
  const withCompatibleRuntime = (chainHead, mapper, error) => (source$) => combineLatest([
    source$.pipe(chainHead.withRuntime(mapper)),
    waitChecksums()
  ]).pipe(
    map3(([[x, ctx], isCompatible2]) => {
      if (!isCompatible2(ctx)) {
        throw error();
      }
      return [x, ctx];
    })
  );
  return {
    isCompatible,
    waitChecksums,
    withCompatibleRuntime,
    compatibleRuntime$
  };
};

// src/runtime-call.ts
import { toHex } from "@polkadot-api/utils";
import { map as map4, mergeMap as mergeMap2 } from "rxjs";
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createRuntimeCallEntry = (api, method, chainHead, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildRuntimeCall(api, method)
  );
  const callName = `${api}_${method}`;
  const checksumError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at, checksumError).pipe(
      mergeMap2((ctx) => {
        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        return chainHead.call$(at, callName, toHex(codecs.args.enc(args))).pipe(map4(codecs.value.dec));
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { isCompatible });
};

// src/storage.ts
import { debounceTime, distinctUntilChanged, map as map5 } from "rxjs";
import { NotBestBlockError } from "@polkadot-api/observable-client";
var isOptionalArg2 = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (pallet, name, chainHead, compatibilityHelper2) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const { isCompatible, waitChecksums, withCompatibleRuntime } = compatibilityHelper2((ctx) => ctx.checksumBuilder.buildStorage(pallet, name));
  const checksumError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const actualArgs = target === "best" || target === "finalized" ? args.slice(0, -1) : args;
    if (isSystemNumber)
      return chainHead.bestBlocks$.pipe(
        map5((blocks) => blocks.at(target === "best" ? 0 : -1).number),
        distinctUntilChanged()
      );
    return chainHead[target === "best" ? "best$" : "finalized$"].pipe(
      debounceTime(0),
      withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),
      raceMap(([block, ctx]) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return chainHead.storage$(block.hash, "value", () => codecs.enc(...actualArgs)).pipe(map5((val) => ({ val, codecs })));
      }, 4),
      distinctUntilChanged((a, b) => a.val === b.val),
      map5(
        ({ val, codecs }) => val === null ? codecs.fallback : codecs.dec(val)
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    let result$;
    if (isSystemNumber) {
      result$ = chainHead.bestBlocks$.pipe(
        map5((blocks) => {
          if (at === "finalized" || !at)
            return blocks.at(-1);
          if (at === "best")
            return blocks.at(0);
          return blocks.find((block) => block.hash === at);
        }),
        map5((block) => {
          if (!block)
            throw new NotBestBlockError();
          return block.number;
        }),
        distinctUntilChanged()
      );
    } else {
      const isCompatible2 = await waitChecksums();
      result$ = chainHead.storage$(
        at,
        "value",
        (ctx) => {
          if (!isCompatible2(ctx))
            throw checksumError();
          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
          const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
          if (args !== actualArgs && !isLastArgOptional)
            throw invalidArgs(args);
          return codecs.enc(...actualArgs);
        },
        null,
        (data, ctx) => {
          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
          return data === null ? codecs.fallback : codecs.dec(data);
        }
      );
    }
    return firstValueFromWithSignal(result$, signal);
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const isCompatible2 = await waitChecksums();
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        if (!isCompatible2(ctx))
          throw checksumError();
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        if (args.length > codecs.len)
          throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return values.map(({ key, value }) => ({
          keyArgs: codecs.keyDecoder(key),
          value: codecs.dec(value)
        }));
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { isCompatible, getValue, getValues, getEntries, watchValue };
};

// src/tx/tx.ts
import {
  AccountId,
  Binary,
  Enum,
  Tuple,
  compact as compact3,
  u128,
  u32 as u323,
  u8 as u82
} from "@polkadot-api/substrate-bindings";
import { fromHex as fromHex5, mergeUint8, toHex as toHex4 } from "@polkadot-api/utils";
import {
  firstValueFrom as firstValueFrom4,
  map as map12,
  mergeMap as mergeMap6,
  take as take3,
  throwError
} from "rxjs";
import { getPolkadotSigner } from "@polkadot-api/signer";

// src/tx/create-tx.ts
import { combineLatest as combineLatest2, mergeMap as mergeMap4, of as of7, take } from "rxjs";

// src/tx/signed-extensions/user/ChargeTransactionPayment.ts
import { compactBn } from "@polkadot-api/substrate-bindings";
import { of as of2 } from "rxjs";

// src/tx/signed-extensions/utils.ts
import { map as map6, noop as noop2, of } from "rxjs";
import {
  Storage,
  Twox64Concat,
  u32
} from "@polkadot-api/substrate-bindings";
import { getDynamicBuilder, getLookupFn } from "@polkadot-api/metadata-builders";
import { fromHex } from "@polkadot-api/utils";
var empty = new Uint8Array();
var genesisHashStorageKey = Storage("System")("BlockHash", noop2, [
  u32,
  Twox64Concat
]).enc(0);
var genesisHashFromCtx = (ctx) => ctx.chainHead.storage$(ctx.at, "value", () => genesisHashStorageKey, null).pipe(map6((result) => fromHex(result)));
var systemVersionProp$ = (propName, metadata) => {
  const lookupFn = getLookupFn(metadata.lookup);
  const dynamicBuilder = getDynamicBuilder(metadata);
  const constant = metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct")
    throw new Error("not a struct");
  const valueEnc = dynamicBuilder.buildDefinition(
    systemVersion.value[propName].id
  ).enc;
  return of(valueEnc(systemVersionDec(constant.value)[propName]));
};

// src/tx/signed-extensions/user/ChargeTransactionPayment.ts
var ChargeTransactionPayment = (tip) => of2({
  value: compactBn.enc(tip),
  additionalSigned: empty
});

// src/tx/signed-extensions/user/CheckMortality.ts
import { map as map7, of as of3 } from "rxjs";
import { Bytes, enhanceEncoder, u16 } from "@polkadot-api/substrate-bindings";
import { fromHex as fromHex2 } from "@polkadot-api/utils";
function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
var mortal = enhanceEncoder(
  Bytes(2).enc,
  (value) => {
    const factor = Math.max(value.period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15);
    const right = value.phase / factor << 4;
    return u16.enc(left | right);
  }
);
var zero = new Uint8Array([0]);
var CheckMortality = (input, ctx) => {
  if (!input)
    return genesisHashFromCtx(ctx).pipe(
      map7((additionalSigned) => ({
        additionalSigned,
        value: zero
      }))
    );
  const { period, blockNumber } = input;
  return of3({
    additionalSigned: fromHex2(ctx.at),
    value: mortal({
      period,
      phase: blockNumber % period
    })
  });
};

// src/tx/signed-extensions/user/ChargeAssetTxPayment.ts
import { of as of4 } from "rxjs";
import {
  Bytes as Bytes2,
  Option,
  Struct,
  compact
} from "@polkadot-api/substrate-bindings";
var encoder = Struct({
  tip: compact,
  asset: Option(Bytes2(Infinity))
}).enc;
var ChargeAssetTxPayment = (tip, asset) => of4({
  value: encoder({
    tip,
    asset
  }),
  additionalSigned: empty
});

// src/tx/signed-extensions/chain/index.ts
var chain_exports = {};
__export(chain_exports, {
  CheckGenesis: () => CheckGenesis,
  CheckMetadataHash: () => CheckMetadataHash,
  CheckNonce: () => CheckNonce,
  CheckSpecVersion: () => CheckSpecVersion,
  CheckTxVersion: () => CheckTxVersion,
  getNonce: () => getNonce
});

// src/tx/signed-extensions/chain/CheckGenesis.ts
import { map as map8 } from "rxjs";
var CheckGenesis = (ctx) => genesisHashFromCtx(ctx).pipe(
  map8((additionalSigned) => ({ value: empty, additionalSigned }))
);

// src/tx/signed-extensions/chain/CheckMetadataHash.ts
import { of as of5 } from "rxjs";
var CheckMetadataHash = () => of5({
  value: Uint8Array.from([0]),
  additionalSigned: Uint8Array.from([0])
});

// src/tx/signed-extensions/chain/CheckNonce.ts
import { mergeMap as mergeMap3, of as of6 } from "rxjs";
import { compact as compact2, u16 as u162, u32 as u322, u64, u8 } from "@polkadot-api/substrate-bindings";
import { fromHex as fromHex3, toHex as toHex2 } from "@polkadot-api/utils";
var NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
var lenToDecoder = {
  1: u8.dec,
  2: u162.dec,
  4: u322.dec,
  8: u64.dec
};
var getNonce = (input) => of6({ value: compact2.enc(input), additionalSigned: empty });
var CheckNonce = (ctx) => ctx.chainHead.call$(ctx.at, NONCE_RUNTIME_CALL, toHex2(ctx.from)).pipe(
  mergeMap3((result) => {
    const bytes = fromHex3(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return getNonce(decoder(bytes));
  })
);

// src/tx/signed-extensions/chain/CheckSpecVersion.ts
import { map as map9 } from "rxjs";
var CheckSpecVersion = ({ metadata }) => systemVersionProp$("spec_version", metadata).pipe(
  map9((additionalSigned) => ({ additionalSigned, value: empty }))
);

// src/tx/signed-extensions/chain/CheckTxVersion.ts
import { map as map10 } from "rxjs";
var CheckTxVersion = ({ metadata }) => systemVersionProp$("transaction_version", metadata).pipe(
  map10((additionalSigned) => ({ additionalSigned, value: empty }))
);

// src/tx/create-tx.ts
import { _void } from "@polkadot-api/substrate-bindings";
var createTx = (chainHead, signer, callData, atBlock, hinted = {}) => chainHead.getRuntimeContext$(atBlock.hash).pipe(
  take(1),
  mergeMap4((ctx) => {
    const signedExtensionsCtx = {
      metadata: ctx.metadata,
      chainHead,
      callData,
      at: atBlock.hash,
      from: signer.publicKey
    };
    const mortality = !hinted.mortality ? { period: 64, blockNumber: atBlock.number } : hinted.mortality.mortal ? { period: hinted.mortality.period, blockNumber: atBlock.number } : void 0;
    return combineLatest2(
      ctx.metadata.extrinsic.signedExtensions.map(
        ({ identifier, type, additionalSigned }) => {
          if (identifier === "CheckMortality")
            return CheckMortality(mortality, signedExtensionsCtx);
          if (identifier === "ChargeTransactionPayment")
            return ChargeTransactionPayment(hinted.tip ?? 0n);
          if (identifier === "ChargeAssetTxPayment")
            return ChargeAssetTxPayment(hinted.tip ?? 0n, hinted.asset);
          if (identifier === "CheckNonce" && "nonce" in hinted)
            return getNonce(hinted.nonce);
          const fn = chain_exports[identifier];
          if (!fn) {
            if (ctx.dynamicBuilder.buildDefinition(type) === _void && ctx.dynamicBuilder.buildDefinition(additionalSigned) === _void)
              return of7({
                value: empty,
                additionalSigned: empty
              });
            throw new Error(`Unsupported signed-extension: ${identifier}`);
          }
          return fn(signedExtensionsCtx);
        }
      )
    ).pipe(
      mergeMap4(
        (signedExtensions) => signer.sign(
          callData,
          Object.fromEntries(
            ctx.metadata.extrinsic.signedExtensions.map(
              ({ identifier }, idx) => [
                identifier,
                { identifier, ...signedExtensions[idx] }
              ]
            )
          ),
          ctx.metadataRaw,
          atBlock.number
        )
      )
    );
  })
);

// src/tx/submit-fns.ts
import { Blake2256 } from "@polkadot-api/substrate-bindings";
import {
  EMPTY,
  Observable as Observable10,
  concat,
  distinctUntilChanged as distinctUntilChanged2,
  filter as filter2,
  lastValueFrom,
  map as map11,
  mergeMap as mergeMap5,
  of as of8,
  take as take2
} from "rxjs";
import { fromHex as fromHex4, toHex as toHex3 } from "@polkadot-api/utils";
var hashFromTx = (tx) => toHex3(Blake2256(fromHex4(tx)));
var computeState = (analized$, blocks$) => new Observable10((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block)
        break;
      analyzed = analyzedBlocks.get(current = block.parent);
    }
    if (!analyzed)
      return;
    const isFinalized = pinnedBlocks.blocks.get(analyzed.hash).number <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && typeof latestState === "object" && latestState.hash === analyzed.hash) {
      if (isFinalized)
        observer.complete();
      return;
    }
    observer.next(
      latestState = found ? {
        hash: analyzed.hash,
        ...analyzed.found
      } : analyzed.found.isValid
    );
    if (isFinalized) {
      if (found)
        observer.complete();
      else if (!analyzed.found.isValid)
        observer.error(new Error("Invalid"));
    }
  };
  const subscription = blocks$.pipe(
    distinctUntilChanged2(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0)
        return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe(distinctUntilChanged2((a, b) => a === b));
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicSuccess";
  return { ok, events };
};
var submit$ = (chainHead, broadcastTx$, tx, at, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const at$ = chainHead.pinnedBlocks$.pipe(
    take2(1),
    map11((blocks) => blocks.blocks.get(at)?.hash ?? blocks.finalized)
  );
  const validate$ = at$.pipe(
    mergeMap5(
      (at2) => chainHead.validateTx$(at2, tx).pipe(
        filter2((x) => !x),
        map11(() => {
          throw new Error("Invalid");
        })
      )
    )
  );
  const track$ = new Observable10((observer) => {
    const subscription = chainHead.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(
    map11((x) => {
      if (x === true || x === false)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: x
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return concat(
    emitSign ? of8(getTxEvent("signed", {})) : EMPTY,
    validate$,
    of8(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? of8(getTxEvent("finalized", rest)) : EMPTY
      )
    )
  );
};
var submit = async (chainHead, broadcastTx$, transaction, at) => lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {
  if (x.type !== "finalized")
    throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

// src/tx/tx.ts
var accountIdEnc = AccountId().enc;
var queryInfoRawDec = Tuple(compact3, compact3, u82, u128).dec;
var queryInfoDec = (input) => queryInfoRawDec(input)[3];
var fakeSignature = new Uint8Array(64);
var getFakeSignature = () => fakeSignature;
var createTxEntry = (pallet, name, assetChecksum, chainHead, broadcast, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildCall(pallet, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
  const fn = (arg) => {
    const getCallDataWithContext = ({ dynamicBuilder, asset: [assetEnc, assetCheck] }, arg2, txOptions = {}) => {
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetChecksum !== assetCheck)
          throw new Error(`Incompatible runtime asset`);
        returnOptions = { ...txOptions, asset: assetEnc(txOptions.asset) };
      }
      const { location, codec } = dynamicBuilder.buildCall(pallet, name);
      return {
        callData: Binary.fromBytes(
          mergeUint8(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead, null, checksumError).pipe(
      map12((ctx) => getCallDataWithContext(ctx, arg2, options))
    );
    const getEncodedData = (runtime) => {
      if (!runtime)
        return firstValueFrom4(getCallData$(arg).pipe(map12((x) => x.callData)));
      if (!isCompatible(runtime))
        throw checksumError();
      return getCallDataWithContext(runtime._getCtx(), arg).callData;
    };
    const sign$ = (from, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      mergeMap6(
        ({ callData, options }) => createTx(chainHead, from, callData.asBytes(), atBlock, options)
      )
    );
    const _sign = (from, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead.finalized$ : at === "best" ? chainHead.best$ : chainHead.bestBlocks$.pipe(
        map12((x) => x.find((b) => b.hash === at))
      )).pipe(
        take3(1),
        mergeMap6(
          (atBlock) => atBlock ? sign$(from, _options, atBlock).pipe(
            map12((signed) => ({
              tx: toHex4(signed),
              block: atBlock
            }))
          ) : throwError(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from, options) => firstValueFrom4(_sign(from, options)).then((x) => x.tx);
    const signAndSubmit = (from, _options) => firstValueFrom4(_sign(from, _options)).then(
      ({ tx, block }) => submit(chainHead, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from, _options) => _sign(from, _options).pipe(
      mergeMap6(
        ({ tx, block }) => submit$(chainHead, broadcast, tx, block.hash, true)
      )
    );
    const getEstimatedFees = async (from, _options) => {
      const fakeSigner = getPolkadotSigner(
        from instanceof Uint8Array ? from : accountIdEnc(from),
        "Sr25519",
        getFakeSignature
      );
      const encoded = fromHex5(await sign(fakeSigner, _options));
      const args = toHex4(mergeUint8(encoded, u323.enc(encoded.length)));
      return firstValueFrom4(
        chainHead.call$(null, "TransactionPaymentApi_query_info", args).pipe(map12(queryInfoDec))
      );
    };
    return {
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: Enum(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, { isCompatible });
};

// src/client.ts
var createTypedApi = (chainDefinition, chainHead, broadcast$) => {
  const runtime = getRuntimeApi(
    chainDefinition.checksums,
    chainDefinition.descriptors,
    chainHead
  );
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a])
        cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b])
          cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("storage" /* Storage */, pallet, name)
      )
    )
  );
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainDefinition.asset,
      chainHead,
      broadcast$,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("tx" /* Tx */, pallet, name)
      )
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("events" /* Event */, pallet, name)
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("constants" /* Const */, pallet, name)
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(runtime, (r) => r._getApiChecksum(api, method))
    )
  );
  return {
    query,
    tx,
    event,
    apis,
    constants,
    runtime
  };
};
function createClient(provider) {
  const rawClient = createRawClient(provider);
  const client = getObservableClient(rawClient);
  const chainHead = client.chainHead$();
  const { getChainSpecData } = rawClient;
  const _request = rawClient.request;
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => firstValueFrom5(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => firstValueFrom5(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => firstValueFrom5(chainHead.body$(hash)),
    getBlockHeader: (hash) => firstValueFrom5(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => createTypedApi(chainDefinition, chainHead, broadcastTx$),
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
}

// src/re-exports.ts
import {
  AccountId as AccountId2,
  Binary as Binary2,
  FixedSizeBinary,
  Enum as Enum2,
  _Enum
} from "@polkadot-api/substrate-bindings";
export {
  AccountId2 as AccountId,
  Binary2 as Binary,
  Enum2 as Enum,
  FixedSizeBinary,
  _Enum,
  createClient
};
//# sourceMappingURL=index.mjs.map
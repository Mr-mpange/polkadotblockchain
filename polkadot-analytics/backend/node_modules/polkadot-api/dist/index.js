"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountId: () => import_substrate_bindings9.AccountId,
  Binary: () => import_substrate_bindings9.Binary,
  Enum: () => import_substrate_bindings9.Enum,
  FixedSizeBinary: () => import_substrate_bindings9.FixedSizeBinary,
  _Enum: () => import_substrate_bindings9._Enum,
  createClient: () => createClient
});
module.exports = __toCommonJS(src_exports);

// src/client.ts
var import_observable_client2 = require("@polkadot-api/observable-client");
var import_substrate_client = require("@polkadot-api/substrate-client");
var import_rxjs23 = require("rxjs");

// src/constants.ts
var import_rxjs = require("rxjs");
var createConstantEntry = (palletName, name, chainHead, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildConstant(palletName, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Constant(${palletName}.${name})`);
  const cachedResults = /* @__PURE__ */ new WeakMap();
  const getValueWithContext = (ctx) => {
    if (cachedResults.has(ctx)) {
      return cachedResults.get(ctx);
    }
    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName);
    const constant = pallet?.constants.find((c) => c.name === name);
    const result = ctx.dynamicBuilder.buildConstant(palletName, name).dec(constant.value);
    cachedResults.set(ctx, result);
    return result;
  };
  const fn = (runtime) => {
    if (runtime) {
      if (!isCompatible(runtime))
        throw checksumError();
      return getValueWithContext(runtime._getCtx());
    }
    return (0, import_rxjs.firstValueFrom)(
      compatibleRuntime$(chainHead, null, checksumError).pipe(
        (0, import_rxjs.map)(getValueWithContext)
      )
    );
  };
  return Object.assign(fn, { isCompatible });
};

// src/event.ts
var import_rxjs7 = require("rxjs");

// src/utils/shareLatest.ts
var import_rxjs2 = require("rxjs");
var shareLatest = (0, import_rxjs2.share)({
  connector: () => new import_rxjs2.ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/firstValueFromWithSignal.ts
var import_utils = require("@polkadot-api/utils");
var import_rxjs3 = require("rxjs");
function firstValueFromWithSignal(source, signal) {
  return new Promise((resolve, reject) => {
    let subscription = null;
    let isDone = false;
    const onAbort = signal ? () => {
      subscription?.unsubscribe();
      reject(new import_utils.AbortError());
    } : import_rxjs3.noop;
    subscription = source.subscribe({
      next: (value) => {
        resolve(value);
        subscription?.unsubscribe();
        isDone = true;
      },
      error: (e) => {
        signal?.removeEventListener("abort", onAbort);
        reject(e);
      },
      complete: () => {
        signal?.removeEventListener("abort", onAbort);
        reject(new Error("Observable completed without emitting"));
      }
    });
    if (!isDone)
      signal?.addEventListener("abort", onAbort);
  });
}

// src/utils/concatMapEager.ts
var import_rxjs4 = require("rxjs");
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new import_rxjs4.Observable((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        (0, import_rxjs4.defer)(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/raceMap.ts
var import_rxjs5 = require("rxjs");
var raceMap = (mapper, concurrent) => (source$) => new import_rxjs5.Observable((observer) => {
  let innerSubscriptions = new Array();
  let isOuterDone = false;
  const createSubscription = (value) => {
    const sub = new import_rxjs5.Subscription();
    innerSubscriptions.push(sub);
    if (innerSubscriptions.length > concurrent) {
      innerSubscriptions[0].unsubscribe();
      innerSubscriptions = innerSubscriptions.slice(1);
    }
    const subscription = mapper(value).subscribe({
      next(value2) {
        const index = innerSubscriptions.indexOf(sub);
        innerSubscriptions.slice(0, index).forEach((s) => s.unsubscribe());
        innerSubscriptions = innerSubscriptions.slice(index);
        observer.next(value2);
      },
      error(error) {
        observer.error(error);
      },
      complete() {
        const index = innerSubscriptions.indexOf(sub);
        innerSubscriptions.splice(index, 1);
        if (innerSubscriptions.length === 0 && isOuterDone)
          observer.complete();
      }
    });
    sub.add(subscription);
  };
  const outerSubscription = source$.subscribe({
    next(value) {
      createSubscription(value);
    },
    error(err) {
      observer.error(err);
    },
    complete() {
      if (innerSubscriptions.length === 0)
        observer.complete();
      isOuterDone = true;
    }
  });
  return () => {
    outerSubscription.unsubscribe();
    innerSubscriptions.forEach((sub) => sub.unsubscribe());
  };
});

// src/utils/continue-with.ts
var import_rxjs6 = require("rxjs");
var NOTIN = {};
var continueWith = (mapper) => (source) => new import_rxjs6.Observable((observer) => {
  let latestValue = NOTIN;
  let subscription = source.subscribe({
    next(v) {
      observer.next(latestValue = v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (latestValue === NOTIN)
        observer.complete();
      else
        subscription = mapper(latestValue).subscribe(observer);
    }
  });
  return () => {
    subscription.unsubscribe();
  };
});

// src/event.ts
var createEventEntry = (pallet, name, chainHead, compatibilityHelper2) => {
  const { isCompatible, withCompatibleRuntime } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildEvent(pallet, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Event(${pallet}.${name})`);
  const shared$ = chainHead.finalized$.pipe(
    withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),
    concatMapEager(
      ([block]) => chainHead.eventsAt$(block.hash).pipe(
        (0, import_rxjs7.map)((events) => {
          const winners = events.filter(
            (e) => e.event.type === pallet && e.event.value.type === name
          );
          return winners.map((x) => {
            return {
              meta: {
                phase: x.phase,
                block
              },
              payload: x.event.value.value
            };
          });
        })
      )
    ),
    shareLatest
  );
  const watch = (f) => shared$.pipe((0, import_rxjs7.mergeMap)((x) => f ? x.filter((d) => f(d.payload)) : x));
  const pull = () => (0, import_rxjs7.firstValueFrom)(shared$);
  const filter3 = (events) => events.filter((e) => e.type === pallet && e.value.type === name).map((x) => x.value.value);
  return { watch, pull, filter: filter3, isCompatible };
};

// src/runtime.ts
var import_rxjs8 = require("rxjs");
var Runtime = class _Runtime {
  constructor(_ctx, _checksums, _descriptors) {
    this._ctx = _ctx;
    this._checksums = _checksums;
    this._descriptors = _descriptors;
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  static _create(ctx, checksums, descriptors) {
    return new _Runtime(ctx, checksums, descriptors);
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getCtx() {
    return this._ctx;
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getPalletChecksum(opType, pallet, name) {
    return this._checksums[this._descriptors[opType][pallet][name]];
  }
  /**
   * @access package  - Internal implementation detail. Do not use.
   */
  _getApiChecksum(name, method) {
    return this._checksums[this._descriptors.apis[name][method]];
  }
};
var getRuntimeApi = (checksums, descriptors, chainHead) => {
  const runtimeWithChecksums$ = (0, import_rxjs8.connectable)(
    (0, import_rxjs8.combineLatest)([chainHead.runtime$, checksums, descriptors]).pipe(
      (0, import_rxjs8.map)(
        ([x, checksums2, descriptors2]) => x ? Runtime._create(x, checksums2, descriptors2) : null
      )
    ),
    {
      connector: () => new import_rxjs8.ReplaySubject(1)
    }
  );
  runtimeWithChecksums$.connect();
  const result = runtimeWithChecksums$.pipe(
    (0, import_rxjs8.filter)((v) => Boolean(v))
  );
  result.latest = () => (0, import_rxjs8.firstValueFrom)(result);
  return result;
};
var compatibilityHelper = (runtimeApi, getDescriptorChecksum) => (getChecksum) => {
  function isCompatibleSync(runtime) {
    return getChecksum(runtime._getCtx()) === getDescriptorChecksum(runtime);
  }
  const isCompatible = (runtime) => {
    if (runtime) {
      return isCompatibleSync(runtime);
    }
    return runtimeApi.latest().then(isCompatibleSync);
  };
  const waitChecksums = async () => {
    const runtime = await runtimeApi.latest();
    return (ctx) => getChecksum(ctx) === getDescriptorChecksum(runtime);
  };
  const compatibleRuntime$ = (chainHead, hash, error) => (0, import_rxjs8.combineLatest)([chainHead.getRuntimeContext$(hash), waitChecksums()]).pipe(
    (0, import_rxjs8.map)(([ctx, isCompatible2]) => {
      if (!isCompatible2(ctx)) {
        throw error();
      }
      return ctx;
    })
  );
  const withCompatibleRuntime = (chainHead, mapper, error) => (source$) => (0, import_rxjs8.combineLatest)([
    source$.pipe(chainHead.withRuntime(mapper)),
    waitChecksums()
  ]).pipe(
    (0, import_rxjs8.map)(([[x, ctx], isCompatible2]) => {
      if (!isCompatible2(ctx)) {
        throw error();
      }
      return [x, ctx];
    })
  );
  return {
    isCompatible,
    waitChecksums,
    withCompatibleRuntime,
    compatibleRuntime$
  };
};

// src/runtime-call.ts
var import_utils4 = require("@polkadot-api/utils");
var import_rxjs9 = require("rxjs");
var isOptionalArg = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createRuntimeCallEntry = (api, method, chainHead, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildRuntimeCall(api, method)
  );
  const callName = `${api}_${method}`;
  const checksumError = () => new Error(`Incompatible runtime entry RuntimeCall(${callName})`);
  const fn = (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const result$ = compatibleRuntime$(chainHead, at, checksumError).pipe(
      (0, import_rxjs9.mergeMap)((ctx) => {
        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method);
        return chainHead.call$(at, callName, (0, import_utils4.toHex)(codecs.args.enc(args))).pipe((0, import_rxjs9.map)(codecs.value.dec));
      })
    );
    return firstValueFromWithSignal(result$, signal);
  };
  return Object.assign(fn, { isCompatible });
};

// src/storage.ts
var import_rxjs10 = require("rxjs");
var import_observable_client = require("@polkadot-api/observable-client");
var isOptionalArg2 = (lastArg) => {
  if (typeof lastArg !== "object")
    return false;
  return Object.keys(lastArg).every(
    (k) => k === "at" && typeof lastArg.at === "string" || k === "signal" && lastArg.signal instanceof AbortSignal
  );
};
var createStorageEntry = (pallet, name, chainHead, compatibilityHelper2) => {
  const isSystemNumber = pallet === "System" && name === "Number";
  const { isCompatible, waitChecksums, withCompatibleRuntime } = compatibilityHelper2((ctx) => ctx.checksumBuilder.buildStorage(pallet, name));
  const checksumError = () => new Error(`Incompatible runtime entry Storage(${pallet}.${name})`);
  const invalidArgs = (args) => new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`);
  const watchValue = (...args) => {
    const target = args[args.length - 1];
    const actualArgs = target === "best" || target === "finalized" ? args.slice(0, -1) : args;
    if (isSystemNumber)
      return chainHead.bestBlocks$.pipe(
        (0, import_rxjs10.map)((blocks) => blocks.at(target === "best" ? 0 : -1).number),
        (0, import_rxjs10.distinctUntilChanged)()
      );
    return chainHead[target === "best" ? "best$" : "finalized$"].pipe(
      (0, import_rxjs10.debounceTime)(0),
      withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),
      raceMap(([block, ctx]) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return chainHead.storage$(block.hash, "value", () => codecs.enc(...actualArgs)).pipe((0, import_rxjs10.map)((val) => ({ val, codecs })));
      }, 4),
      (0, import_rxjs10.distinctUntilChanged)((a, b) => a.val === b.val),
      (0, import_rxjs10.map)(
        ({ val, codecs }) => val === null ? codecs.fallback : codecs.dec(val)
      )
    );
  };
  const getValue = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    let result$;
    if (isSystemNumber) {
      result$ = chainHead.bestBlocks$.pipe(
        (0, import_rxjs10.map)((blocks) => {
          if (at === "finalized" || !at)
            return blocks.at(-1);
          if (at === "best")
            return blocks.at(0);
          return blocks.find((block) => block.hash === at);
        }),
        (0, import_rxjs10.map)((block) => {
          if (!block)
            throw new import_observable_client.NotBestBlockError();
          return block.number;
        }),
        (0, import_rxjs10.distinctUntilChanged)()
      );
    } else {
      const isCompatible2 = await waitChecksums();
      result$ = chainHead.storage$(
        at,
        "value",
        (ctx) => {
          if (!isCompatible2(ctx))
            throw checksumError();
          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
          const actualArgs = args.length === codecs.len ? args : args.slice(0, -1);
          if (args !== actualArgs && !isLastArgOptional)
            throw invalidArgs(args);
          return codecs.enc(...actualArgs);
        },
        null,
        (data, ctx) => {
          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
          return data === null ? codecs.fallback : codecs.dec(data);
        }
      );
    }
    return firstValueFromWithSignal(result$, signal);
  };
  const getEntries = async (...args) => {
    const lastArg = args[args.length - 1];
    const isLastArgOptional = isOptionalArg2(lastArg);
    const { signal, at: _at } = isLastArgOptional ? lastArg : {};
    const at = _at ?? null;
    const isCompatible2 = await waitChecksums();
    const result$ = chainHead.storage$(
      at,
      "descendantsValues",
      (ctx) => {
        if (!isCompatible2(ctx))
          throw checksumError();
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        if (args.length > codecs.len)
          throw invalidArgs(args);
        const actualArgs = args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args;
        if (args.length === codecs.len && actualArgs === args)
          throw invalidArgs(args);
        return codecs.enc(...actualArgs);
      },
      null,
      (values, ctx) => {
        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name);
        return values.map(({ key, value }) => ({
          keyArgs: codecs.keyDecoder(key),
          value: codecs.dec(value)
        }));
      }
    );
    return firstValueFromWithSignal(result$, signal);
  };
  const getValues = (keyArgs, options) => Promise.all(
    keyArgs.map((args) => getValue(...options ? [...args, options] : args))
  );
  return { isCompatible, getValue, getValues, getEntries, watchValue };
};

// src/tx/tx.ts
var import_substrate_bindings8 = require("@polkadot-api/substrate-bindings");
var import_utils19 = require("@polkadot-api/utils");
var import_rxjs22 = require("rxjs");
var import_signer = require("@polkadot-api/signer");

// src/tx/create-tx.ts
var import_rxjs20 = require("rxjs");

// src/tx/signed-extensions/user/ChargeTransactionPayment.ts
var import_substrate_bindings2 = require("@polkadot-api/substrate-bindings");
var import_rxjs12 = require("rxjs");

// src/tx/signed-extensions/utils.ts
var import_rxjs11 = require("rxjs");
var import_substrate_bindings = require("@polkadot-api/substrate-bindings");
var import_metadata_builders = require("@polkadot-api/metadata-builders");
var import_utils6 = require("@polkadot-api/utils");
var empty = new Uint8Array();
var genesisHashStorageKey = (0, import_substrate_bindings.Storage)("System")("BlockHash", import_rxjs11.noop, [
  import_substrate_bindings.u32,
  import_substrate_bindings.Twox64Concat
]).enc(0);
var genesisHashFromCtx = (ctx) => ctx.chainHead.storage$(ctx.at, "value", () => genesisHashStorageKey, null).pipe((0, import_rxjs11.map)((result) => (0, import_utils6.fromHex)(result)));
var systemVersionProp$ = (propName, metadata) => {
  const lookupFn = (0, import_metadata_builders.getLookupFn)(metadata.lookup);
  const dynamicBuilder = (0, import_metadata_builders.getDynamicBuilder)(metadata);
  const constant = metadata.pallets.find((x) => x.name === "System").constants.find((s) => s.name === "Version");
  const systemVersion = lookupFn(constant.type);
  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec;
  if (systemVersion.type !== "struct")
    throw new Error("not a struct");
  const valueEnc = dynamicBuilder.buildDefinition(
    systemVersion.value[propName].id
  ).enc;
  return (0, import_rxjs11.of)(valueEnc(systemVersionDec(constant.value)[propName]));
};

// src/tx/signed-extensions/user/ChargeTransactionPayment.ts
var ChargeTransactionPayment = (tip) => (0, import_rxjs12.of)({
  value: import_substrate_bindings2.compactBn.enc(tip),
  additionalSigned: empty
});

// src/tx/signed-extensions/user/CheckMortality.ts
var import_rxjs13 = require("rxjs");
var import_substrate_bindings3 = require("@polkadot-api/substrate-bindings");
var import_utils8 = require("@polkadot-api/utils");
function trailingZeroes(n) {
  let i = 0;
  while (!(n & 1)) {
    i++;
    n >>= 1;
  }
  return i;
}
var mortal = (0, import_substrate_bindings3.enhanceEncoder)(
  (0, import_substrate_bindings3.Bytes)(2).enc,
  (value) => {
    const factor = Math.max(value.period >> 12, 1);
    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15);
    const right = value.phase / factor << 4;
    return import_substrate_bindings3.u16.enc(left | right);
  }
);
var zero = new Uint8Array([0]);
var CheckMortality = (input, ctx) => {
  if (!input)
    return genesisHashFromCtx(ctx).pipe(
      (0, import_rxjs13.map)((additionalSigned) => ({
        additionalSigned,
        value: zero
      }))
    );
  const { period, blockNumber } = input;
  return (0, import_rxjs13.of)({
    additionalSigned: (0, import_utils8.fromHex)(ctx.at),
    value: mortal({
      period,
      phase: blockNumber % period
    })
  });
};

// src/tx/signed-extensions/user/ChargeAssetTxPayment.ts
var import_rxjs14 = require("rxjs");
var import_substrate_bindings4 = require("@polkadot-api/substrate-bindings");
var encoder = (0, import_substrate_bindings4.Struct)({
  tip: import_substrate_bindings4.compact,
  asset: (0, import_substrate_bindings4.Option)((0, import_substrate_bindings4.Bytes)(Infinity))
}).enc;
var ChargeAssetTxPayment = (tip, asset) => (0, import_rxjs14.of)({
  value: encoder({
    tip,
    asset
  }),
  additionalSigned: empty
});

// src/tx/signed-extensions/chain/index.ts
var chain_exports = {};
__export(chain_exports, {
  CheckGenesis: () => CheckGenesis,
  CheckMetadataHash: () => CheckMetadataHash,
  CheckNonce: () => CheckNonce,
  CheckSpecVersion: () => CheckSpecVersion,
  CheckTxVersion: () => CheckTxVersion,
  getNonce: () => getNonce
});

// src/tx/signed-extensions/chain/CheckGenesis.ts
var import_rxjs15 = require("rxjs");
var CheckGenesis = (ctx) => genesisHashFromCtx(ctx).pipe(
  (0, import_rxjs15.map)((additionalSigned) => ({ value: empty, additionalSigned }))
);

// src/tx/signed-extensions/chain/CheckMetadataHash.ts
var import_rxjs16 = require("rxjs");
var CheckMetadataHash = () => (0, import_rxjs16.of)({
  value: Uint8Array.from([0]),
  additionalSigned: Uint8Array.from([0])
});

// src/tx/signed-extensions/chain/CheckNonce.ts
var import_rxjs17 = require("rxjs");
var import_substrate_bindings5 = require("@polkadot-api/substrate-bindings");
var import_utils13 = require("@polkadot-api/utils");
var NONCE_RUNTIME_CALL = "AccountNonceApi_account_nonce";
var lenToDecoder = {
  1: import_substrate_bindings5.u8.dec,
  2: import_substrate_bindings5.u16.dec,
  4: import_substrate_bindings5.u32.dec,
  8: import_substrate_bindings5.u64.dec
};
var getNonce = (input) => (0, import_rxjs17.of)({ value: import_substrate_bindings5.compact.enc(input), additionalSigned: empty });
var CheckNonce = (ctx) => ctx.chainHead.call$(ctx.at, NONCE_RUNTIME_CALL, (0, import_utils13.toHex)(ctx.from)).pipe(
  (0, import_rxjs17.mergeMap)((result) => {
    const bytes = (0, import_utils13.fromHex)(result);
    const decoder = lenToDecoder[bytes.length];
    if (!decoder)
      throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`);
    return getNonce(decoder(bytes));
  })
);

// src/tx/signed-extensions/chain/CheckSpecVersion.ts
var import_rxjs18 = require("rxjs");
var CheckSpecVersion = ({ metadata }) => systemVersionProp$("spec_version", metadata).pipe(
  (0, import_rxjs18.map)((additionalSigned) => ({ additionalSigned, value: empty }))
);

// src/tx/signed-extensions/chain/CheckTxVersion.ts
var import_rxjs19 = require("rxjs");
var CheckTxVersion = ({ metadata }) => systemVersionProp$("transaction_version", metadata).pipe(
  (0, import_rxjs19.map)((additionalSigned) => ({ additionalSigned, value: empty }))
);

// src/tx/create-tx.ts
var import_substrate_bindings6 = require("@polkadot-api/substrate-bindings");
var createTx = (chainHead, signer, callData, atBlock, hinted = {}) => chainHead.getRuntimeContext$(atBlock.hash).pipe(
  (0, import_rxjs20.take)(1),
  (0, import_rxjs20.mergeMap)((ctx) => {
    const signedExtensionsCtx = {
      metadata: ctx.metadata,
      chainHead,
      callData,
      at: atBlock.hash,
      from: signer.publicKey
    };
    const mortality = !hinted.mortality ? { period: 64, blockNumber: atBlock.number } : hinted.mortality.mortal ? { period: hinted.mortality.period, blockNumber: atBlock.number } : void 0;
    return (0, import_rxjs20.combineLatest)(
      ctx.metadata.extrinsic.signedExtensions.map(
        ({ identifier, type, additionalSigned }) => {
          if (identifier === "CheckMortality")
            return CheckMortality(mortality, signedExtensionsCtx);
          if (identifier === "ChargeTransactionPayment")
            return ChargeTransactionPayment(hinted.tip ?? 0n);
          if (identifier === "ChargeAssetTxPayment")
            return ChargeAssetTxPayment(hinted.tip ?? 0n, hinted.asset);
          if (identifier === "CheckNonce" && "nonce" in hinted)
            return getNonce(hinted.nonce);
          const fn = chain_exports[identifier];
          if (!fn) {
            if (ctx.dynamicBuilder.buildDefinition(type) === import_substrate_bindings6._void && ctx.dynamicBuilder.buildDefinition(additionalSigned) === import_substrate_bindings6._void)
              return (0, import_rxjs20.of)({
                value: empty,
                additionalSigned: empty
              });
            throw new Error(`Unsupported signed-extension: ${identifier}`);
          }
          return fn(signedExtensionsCtx);
        }
      )
    ).pipe(
      (0, import_rxjs20.mergeMap)(
        (signedExtensions) => signer.sign(
          callData,
          Object.fromEntries(
            ctx.metadata.extrinsic.signedExtensions.map(
              ({ identifier }, idx) => [
                identifier,
                { identifier, ...signedExtensions[idx] }
              ]
            )
          ),
          ctx.metadataRaw,
          atBlock.number
        )
      )
    );
  })
);

// src/tx/submit-fns.ts
var import_substrate_bindings7 = require("@polkadot-api/substrate-bindings");
var import_rxjs21 = require("rxjs");
var import_utils18 = require("@polkadot-api/utils");
var hashFromTx = (tx) => (0, import_utils18.toHex)((0, import_substrate_bindings7.Blake2256)((0, import_utils18.fromHex)(tx)));
var computeState = (analized$, blocks$) => new import_rxjs21.Observable((observer) => {
  const analyzedBlocks = /* @__PURE__ */ new Map();
  let pinnedBlocks;
  let latestState;
  const computeNextState = () => {
    let current = pinnedBlocks.best;
    let analyzed = analyzedBlocks.get(current);
    while (!analyzed) {
      const block = pinnedBlocks.blocks.get(current);
      if (!block)
        break;
      analyzed = analyzedBlocks.get(current = block.parent);
    }
    if (!analyzed)
      return;
    const isFinalized = pinnedBlocks.blocks.get(analyzed.hash).number <= pinnedBlocks.blocks.get(pinnedBlocks.finalized).number;
    const found = analyzed.found.type;
    if (found && typeof latestState === "object" && latestState.hash === analyzed.hash) {
      if (isFinalized)
        observer.complete();
      return;
    }
    observer.next(
      latestState = found ? {
        hash: analyzed.hash,
        ...analyzed.found
      } : analyzed.found.isValid
    );
    if (isFinalized) {
      if (found)
        observer.complete();
      else if (!analyzed.found.isValid)
        observer.error(new Error("Invalid"));
    }
  };
  const subscription = blocks$.pipe(
    (0, import_rxjs21.distinctUntilChanged)(
      (a, b) => a.finalized === b.finalized && a.best === b.best
    )
  ).subscribe({
    next: (pinned) => {
      pinnedBlocks = pinned;
      if (analyzedBlocks.size === 0)
        return;
      computeNextState();
    },
    error(e) {
      observer.error(e);
    }
  });
  subscription.add(
    analized$.subscribe({
      next: (block) => {
        analyzedBlocks.set(block.hash, block);
        computeNextState();
      },
      error(e) {
        observer.error(e);
      }
    })
  );
  return subscription;
}).pipe((0, import_rxjs21.distinctUntilChanged)((a, b) => a === b));
var getTxSuccessFromSystemEvents = (systemEvents, txIdx) => {
  const events = systemEvents.filter((x) => x.phase.type === "ApplyExtrinsic" && x.phase.value === txIdx).map((x) => x.event);
  const lastEvent = events[events.length - 1];
  const ok = lastEvent.type === "System" && lastEvent.value.type === "ExtrinsicSuccess";
  return { ok, events };
};
var submit$ = (chainHead, broadcastTx$, tx, at, emitSign = false) => {
  const txHash = hashFromTx(tx);
  const getTxEvent = (type, rest) => ({
    type,
    txHash,
    ...rest
  });
  const at$ = chainHead.pinnedBlocks$.pipe(
    (0, import_rxjs21.take)(1),
    (0, import_rxjs21.map)((blocks) => blocks.blocks.get(at)?.hash ?? blocks.finalized)
  );
  const validate$ = at$.pipe(
    (0, import_rxjs21.mergeMap)(
      (at2) => chainHead.validateTx$(at2, tx).pipe(
        (0, import_rxjs21.filter)((x) => !x),
        (0, import_rxjs21.map)(() => {
          throw new Error("Invalid");
        })
      )
    )
  );
  const track$ = new import_rxjs21.Observable((observer) => {
    const subscription = chainHead.trackTx$(tx).subscribe(observer);
    subscription.add(
      broadcastTx$(tx).subscribe({
        error(e) {
          observer.error(e);
        }
      })
    );
    return subscription;
  });
  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(
    (0, import_rxjs21.map)((x) => {
      if (x === true || x === false)
        return getTxEvent("txBestBlocksState", {
          found: false,
          isValid: x
        });
      return getTxEvent("txBestBlocksState", {
        found: true,
        block: {
          index: x.index,
          hash: x.hash
        },
        ...getTxSuccessFromSystemEvents(x.events, x.index)
      });
    })
  );
  return (0, import_rxjs21.concat)(
    emitSign ? (0, import_rxjs21.of)(getTxEvent("signed", {})) : import_rxjs21.EMPTY,
    validate$,
    (0, import_rxjs21.of)(getTxEvent("broadcasted", {})),
    bestBlockState$.pipe(
      continueWith(
        ({ found, type, ...rest }) => found ? (0, import_rxjs21.of)(getTxEvent("finalized", rest)) : import_rxjs21.EMPTY
      )
    )
  );
};
var submit = async (chainHead, broadcastTx$, transaction, at) => (0, import_rxjs21.lastValueFrom)(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {
  if (x.type !== "finalized")
    throw null;
  const result = { ...x };
  delete result.type;
  return result;
});

// src/tx/tx.ts
var accountIdEnc = (0, import_substrate_bindings8.AccountId)().enc;
var queryInfoRawDec = (0, import_substrate_bindings8.Tuple)(import_substrate_bindings8.compact, import_substrate_bindings8.compact, import_substrate_bindings8.u8, import_substrate_bindings8.u128).dec;
var queryInfoDec = (input) => queryInfoRawDec(input)[3];
var fakeSignature = new Uint8Array(64);
var getFakeSignature = () => fakeSignature;
var createTxEntry = (pallet, name, assetChecksum, chainHead, broadcast, compatibilityHelper2) => {
  const { isCompatible, compatibleRuntime$ } = compatibilityHelper2(
    (ctx) => ctx.checksumBuilder.buildCall(pallet, name)
  );
  const checksumError = () => new Error(`Incompatible runtime entry Tx(${pallet}.${name})`);
  const fn = (arg) => {
    const getCallDataWithContext = ({ dynamicBuilder, asset: [assetEnc, assetCheck] }, arg2, txOptions = {}) => {
      let returnOptions = txOptions;
      if (txOptions.asset) {
        if (assetChecksum !== assetCheck)
          throw new Error(`Incompatible runtime asset`);
        returnOptions = { ...txOptions, asset: assetEnc(txOptions.asset) };
      }
      const { location, codec } = dynamicBuilder.buildCall(pallet, name);
      return {
        callData: import_substrate_bindings8.Binary.fromBytes(
          (0, import_utils19.mergeUint8)(new Uint8Array(location), codec.enc(arg2))
        ),
        options: returnOptions
      };
    };
    const getCallData$ = (arg2, options = {}) => compatibleRuntime$(chainHead, null, checksumError).pipe(
      (0, import_rxjs22.map)((ctx) => getCallDataWithContext(ctx, arg2, options))
    );
    const getEncodedData = (runtime) => {
      if (!runtime)
        return (0, import_rxjs22.firstValueFrom)(getCallData$(arg).pipe((0, import_rxjs22.map)((x) => x.callData)));
      if (!isCompatible(runtime))
        throw checksumError();
      return getCallDataWithContext(runtime._getCtx(), arg).callData;
    };
    const sign$ = (from, { ..._options }, atBlock) => getCallData$(arg, _options).pipe(
      (0, import_rxjs22.mergeMap)(
        ({ callData, options }) => createTx(chainHead, from, callData.asBytes(), atBlock, options)
      )
    );
    const _sign = (from, { at, ..._options } = {}) => {
      return (!at || at === "finalized" ? chainHead.finalized$ : at === "best" ? chainHead.best$ : chainHead.bestBlocks$.pipe(
        (0, import_rxjs22.map)((x) => x.find((b) => b.hash === at))
      )).pipe(
        (0, import_rxjs22.take)(1),
        (0, import_rxjs22.mergeMap)(
          (atBlock) => atBlock ? sign$(from, _options, atBlock).pipe(
            (0, import_rxjs22.map)((signed) => ({
              tx: (0, import_utils19.toHex)(signed),
              block: atBlock
            }))
          ) : (0, import_rxjs22.throwError)(() => new Error(`Uknown block ${at}`))
        )
      );
    };
    const sign = (from, options) => (0, import_rxjs22.firstValueFrom)(_sign(from, options)).then((x) => x.tx);
    const signAndSubmit = (from, _options) => (0, import_rxjs22.firstValueFrom)(_sign(from, _options)).then(
      ({ tx, block }) => submit(chainHead, broadcast, tx, block.hash)
    );
    const signSubmitAndWatch = (from, _options) => _sign(from, _options).pipe(
      (0, import_rxjs22.mergeMap)(
        ({ tx, block }) => submit$(chainHead, broadcast, tx, block.hash, true)
      )
    );
    const getEstimatedFees = async (from, _options) => {
      const fakeSigner = (0, import_signer.getPolkadotSigner)(
        from instanceof Uint8Array ? from : accountIdEnc(from),
        "Sr25519",
        getFakeSignature
      );
      const encoded = (0, import_utils19.fromHex)(await sign(fakeSigner, _options));
      const args = (0, import_utils19.toHex)((0, import_utils19.mergeUint8)(encoded, import_substrate_bindings8.u32.enc(encoded.length)));
      return (0, import_rxjs22.firstValueFrom)(
        chainHead.call$(null, "TransactionPaymentApi_query_info", args).pipe((0, import_rxjs22.map)(queryInfoDec))
      );
    };
    return {
      getEstimatedFees,
      decodedCall: {
        type: pallet,
        value: (0, import_substrate_bindings8.Enum)(name, arg)
      },
      getEncodedData,
      sign,
      signSubmitAndWatch,
      signAndSubmit
    };
  };
  return Object.assign(fn, { isCompatible });
};

// src/client.ts
var createTypedApi = (chainDefinition, chainHead, broadcast$) => {
  const runtime = getRuntimeApi(
    chainDefinition.checksums,
    chainDefinition.descriptors,
    chainHead
  );
  const target = {};
  const createProxy = (propCall) => new Proxy(target, {
    get(_, prop) {
      return propCall(prop);
    }
  });
  const createProxyPath = (pathCall) => {
    const cache = {};
    return createProxy((a) => {
      if (!cache[a])
        cache[a] = {};
      return createProxy((b) => {
        if (!cache[a][b])
          cache[a][b] = pathCall(a, b);
        return cache[a][b];
      });
    });
  };
  const query = createProxyPath(
    (pallet, name) => createStorageEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("storage" /* Storage */, pallet, name)
      )
    )
  );
  const tx = createProxyPath(
    (pallet, name) => createTxEntry(
      pallet,
      name,
      chainDefinition.asset,
      chainHead,
      broadcast$,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("tx" /* Tx */, pallet, name)
      )
    )
  );
  const event = createProxyPath(
    (pallet, name) => createEventEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("events" /* Event */, pallet, name)
      )
    )
  );
  const constants = createProxyPath(
    (pallet, name) => createConstantEntry(
      pallet,
      name,
      chainHead,
      compatibilityHelper(
        runtime,
        (r) => r._getPalletChecksum("constants" /* Const */, pallet, name)
      )
    )
  );
  const apis = createProxyPath(
    (api, method) => createRuntimeCallEntry(
      api,
      method,
      chainHead,
      compatibilityHelper(runtime, (r) => r._getApiChecksum(api, method))
    )
  );
  return {
    query,
    tx,
    event,
    apis,
    constants,
    runtime
  };
};
function createClient(provider) {
  const rawClient = (0, import_substrate_client.createClient)(provider);
  const client = (0, import_observable_client2.getObservableClient)(rawClient);
  const chainHead = client.chainHead$();
  const { getChainSpecData } = rawClient;
  const _request = rawClient.request;
  const { broadcastTx$ } = client;
  return {
    getChainSpecData,
    finalizedBlock$: chainHead.finalized$,
    getFinalizedBlock: () => (0, import_rxjs23.firstValueFrom)(chainHead.finalized$),
    bestBlocks$: chainHead.bestBlocks$,
    getBestBlocks: () => (0, import_rxjs23.firstValueFrom)(chainHead.bestBlocks$),
    watchBlockBody: chainHead.body$,
    getBlockBody: (hash) => (0, import_rxjs23.firstValueFrom)(chainHead.body$(hash)),
    getBlockHeader: (hash) => (0, import_rxjs23.firstValueFrom)(chainHead.header$(hash ?? null)),
    submit: (...args) => submit(chainHead, broadcastTx$, ...args),
    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),
    getTypedApi: (chainDefinition) => createTypedApi(chainDefinition, chainHead, broadcastTx$),
    destroy: () => {
      chainHead.unfollow();
      client.destroy();
    },
    _request
  };
}

// src/re-exports.ts
var import_substrate_bindings9 = require("@polkadot-api/substrate-bindings");
//# sourceMappingURL=index.js.map
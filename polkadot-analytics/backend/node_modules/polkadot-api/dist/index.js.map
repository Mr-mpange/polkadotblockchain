{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/constants.ts","../src/event.ts","../src/utils/shareLatest.ts","../src/utils/firstValueFromWithSignal.ts","../src/utils/concatMapEager.ts","../src/utils/raceMap.ts","../src/utils/continue-with.ts","../src/runtime.ts","../src/runtime-call.ts","../src/storage.ts","../src/tx/tx.ts","../src/tx/create-tx.ts","../src/tx/signed-extensions/user/ChargeTransactionPayment.ts","../src/tx/signed-extensions/utils.ts","../src/tx/signed-extensions/user/CheckMortality.ts","../src/tx/signed-extensions/user/ChargeAssetTxPayment.ts","../src/tx/signed-extensions/chain/index.ts","../src/tx/signed-extensions/chain/CheckGenesis.ts","../src/tx/signed-extensions/chain/CheckMetadataHash.ts","../src/tx/signed-extensions/chain/CheckNonce.ts","../src/tx/signed-extensions/chain/CheckSpecVersion.ts","../src/tx/signed-extensions/chain/CheckTxVersion.ts","../src/tx/submit-fns.ts","../src/re-exports.ts"],"sourcesContent":["export * from \"./client\"\nexport * from \"./re-exports\"\nexport * from \"./descriptors\"\nexport type { EventPhase } from \"./event\"\nexport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nexport type { PolkadotClient, TypedApi, FixedSizeArray } from \"./types\"\nexport type * from \"./tx\"\n","import { JsonRpcProvider } from \"@polkadot-api/json-rpc-provider\"\nimport { getObservableClient } from \"@polkadot-api/observable-client\"\nimport {\n  SubstrateClient,\n  createClient as createRawClient,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, firstValueFrom } from \"rxjs\"\nimport { createConstantEntry } from \"./constants\"\nimport { ChainDefinition } from \"./descriptors\"\nimport { createEventEntry } from \"./event\"\nimport { OpType, compatibilityHelper, getRuntimeApi } from \"./runtime\"\nimport { createRuntimeCallEntry } from \"./runtime-call\"\nimport { createStorageEntry } from \"./storage\"\nimport { createTxEntry, submit, submit$ } from \"./tx\"\nimport { PolkadotClient, TypedApi } from \"./types\"\n\nconst createTypedApi = <D extends ChainDefinition>(\n  chainDefinition: D,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  broadcast$: (tx: string) => Observable<never>,\n): TypedApi<D> => {\n  const runtime = getRuntimeApi(\n    chainDefinition.checksums,\n    chainDefinition.descriptors,\n    chainHead,\n  )\n\n  const target = {}\n  const createProxy = (propCall: (prop: string) => unknown) =>\n    new Proxy(target, {\n      get(_, prop) {\n        return propCall(prop as string)\n      },\n    })\n  const createProxyPath = <T>(pathCall: (a: string, b: string) => T) => {\n    const cache: Record<string, Record<string, T>> = {}\n    return createProxy((a) => {\n      if (!cache[a]) cache[a] = {}\n      return createProxy((b) => {\n        if (!cache[a][b]) cache[a][b] = pathCall(a, b)\n        return cache[a][b]\n      })\n    }) as Record<string, Record<string, T>>\n  }\n\n  const query = createProxyPath((pallet, name) =>\n    createStorageEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Storage, pallet, name),\n      ),\n    ),\n  )\n\n  const tx = createProxyPath((pallet, name) =>\n    createTxEntry(\n      pallet,\n      name,\n      chainDefinition.asset,\n      chainHead,\n      broadcast$,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Tx, pallet, name),\n      ),\n    ),\n  )\n\n  const event = createProxyPath((pallet, name) =>\n    createEventEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Event, pallet, name),\n      ),\n    ),\n  )\n\n  const constants = createProxyPath((pallet, name) =>\n    createConstantEntry(\n      pallet,\n      name,\n      chainHead,\n      compatibilityHelper(runtime, (r) =>\n        r._getPalletChecksum(OpType.Const, pallet, name),\n      ),\n    ),\n  )\n\n  const apis = createProxyPath((api, method) =>\n    createRuntimeCallEntry(\n      api,\n      method,\n      chainHead,\n      compatibilityHelper(runtime, (r) => r._getApiChecksum(api, method)),\n    ),\n  )\n\n  return {\n    query,\n    tx,\n    event,\n    apis,\n    constants,\n    runtime,\n  } as any\n}\n\n/**\n * This is the top-level export for `polkadot-api`.\n *\n * @param provider  A `JsonRpcProvider` compliant with the [JSON-RPC\n *                  spec](https://paritytech.github.io/json-rpc-interface-spec/),\n *                  which must support the `chainHead`, `transaction` and\n *                  `chainSpec` groups.\n * @example\n *\n *   import { createClient } from \"polkadot-api\"\n *   import { getSmProvider } from \"polkadot-api/sm-provider\"\n *   import { chainSpec } from \"polkadot-api/chains/polkadot\"\n *   import { start } from \"polkadot-api/smoldot\"\n *\n *   const smoldot = start()\n *   const chain = await smoldot.addChain({ chainSpec })\n *\n *   // Connect to the polkadot relay chain.\n *   const client = createClient(getSmProvider(chain))\n *\n */\nexport function createClient(provider: JsonRpcProvider): PolkadotClient {\n  const rawClient: SubstrateClient = createRawClient(provider)\n  const client = getObservableClient(rawClient)\n  const chainHead = client.chainHead$()\n\n  const { getChainSpecData } = rawClient\n\n  const _request: <Reply = any, Params extends Array<any> = any[]>(\n    method: string,\n    params: Params,\n  ) => Promise<Reply> = rawClient.request\n\n  const { broadcastTx$ } = client\n  return {\n    getChainSpecData,\n\n    finalizedBlock$: chainHead.finalized$,\n    getFinalizedBlock: () => firstValueFrom(chainHead.finalized$),\n\n    bestBlocks$: chainHead.bestBlocks$,\n    getBestBlocks: () => firstValueFrom(chainHead.bestBlocks$),\n\n    watchBlockBody: chainHead.body$,\n    getBlockBody: (hash: string) => firstValueFrom(chainHead.body$(hash)),\n\n    getBlockHeader: (hash?: string) =>\n      firstValueFrom(chainHead.header$(hash ?? null)),\n\n    submit: (...args) => submit(chainHead, broadcastTx$, ...args),\n    submitAndWatch: (...args) => submit$(chainHead, broadcastTx$, ...args),\n\n    getTypedApi: <D extends ChainDefinition>(chainDefinition: D) =>\n      createTypedApi(chainDefinition, chainHead, broadcastTx$),\n\n    destroy: () => {\n      chainHead.unfollow()\n      client.destroy()\n    },\n\n    _request,\n  }\n}\n","import { firstValueFrom, map } from \"rxjs\"\nimport { ChainHead$, RuntimeContext } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible, Runtime } from \"./runtime\"\n\nexport interface ConstantEntry<T> {\n  /**\n   * Constants are simple key-value structures found in the runtime metadata.\n   *\n   * @returns Promise that will resolve in the value of the constant.\n   */\n  (): Promise<T>\n  /**\n   * @param runtime  Runtime from got with `typedApi.runtime`\n   * @returns Synchronously returns value of the constant.\n   */\n  (runtime: Runtime): T\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\nexport const createConstantEntry = <T>(\n  palletName: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): ConstantEntry<T> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildConstant(palletName, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Constant(${palletName}.${name})`)\n\n  const cachedResults = new WeakMap<RuntimeContext, T>()\n  const getValueWithContext = (ctx: RuntimeContext) => {\n    if (cachedResults.has(ctx)) {\n      return cachedResults.get(ctx)!\n    }\n\n    const pallet = ctx.metadata.pallets.find((p) => p.name === palletName)\n    const constant = pallet?.constants.find((c) => c.name === name)!\n    const result = ctx.dynamicBuilder\n      .buildConstant(palletName, name)\n      .dec(constant.value)\n    cachedResults.set(ctx, result)\n    return result\n  }\n\n  const fn = (runtime?: Runtime): any => {\n    if (runtime) {\n      if (!isCompatible(runtime)) throw checksumError()\n      return getValueWithContext(runtime._getCtx())\n    }\n    return firstValueFrom(\n      compatibleRuntime$(chainHead, null, checksumError).pipe(\n        map(getValueWithContext),\n      ),\n    )\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { Observable, firstValueFrom, map, mergeMap } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\nimport { concatMapEager, shareLatest } from \"./utils\"\n\nexport type EventPhase =\n  | { type: \"ApplyExtrinsic\"; value: number }\n  | { type: \"Finalization\" }\n  | { type: \"Initialization\" }\n\nexport type EvWatch<T> = (filter?: (value: T) => boolean) => Observable<{\n  meta: {\n    block: BlockInfo\n    phase: EventPhase\n  }\n  payload: T\n}>\n\nexport type EvPull<T> = () => Promise<\n  Array<{\n    meta: {\n      block: BlockInfo\n      phase: EventPhase\n    }\n    payload: T\n  }>\n>\n\nexport type EvFilter<T> = (collection: SystemEvent[\"event\"][]) => Array<T>\n\nexport type EvClient<T> = {\n  /**\n   * Multicast and stateful Observable watching for new events (matching the\n   * event kind chosen) in the latest known `finalized` block.\n   *\n   * @param filter  Optional filter function to only emit events complying\n   *                with the function.\n   */\n  watch: EvWatch<T>\n  /**\n   * Fetch (Promise-based) all events (matching the event kind chosen) available\n   * in the latest known `finalized` block.\n   */\n  pull: EvPull<T>\n  /**\n   * Filter a bunch of `SystemEvent` and return the decoded `payload` of every\n   * of them.\n   *\n   * @param collection  Array of `SystemEvent` to filter.\n   */\n  filter: EvFilter<T>\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\ntype SystemEvent = {\n  phase: EventPhase\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport const createEventEntry = <T>(\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): EvClient<T> => {\n  const { isCompatible, withCompatibleRuntime } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildEvent(pallet, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Event(${pallet}.${name})`)\n\n  const shared$ = chainHead.finalized$.pipe(\n    withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),\n    concatMapEager(([block]) =>\n      chainHead.eventsAt$(block.hash).pipe(\n        map((events) => {\n          const winners = events.filter(\n            (e) => e.event.type === pallet && e.event.value.type === name,\n          )\n          return winners.map((x) => {\n            return {\n              meta: {\n                phase: x.phase,\n                block,\n              },\n              payload: x.event.value.value,\n            }\n          })\n        }),\n      ),\n    ),\n    shareLatest,\n  )\n\n  const watch: EvWatch<T> = (f) =>\n    shared$.pipe(mergeMap((x) => (f ? x.filter((d) => f(d.payload)) : x)))\n\n  const pull: EvPull<T> = () => firstValueFrom(shared$)\n\n  const filter: EvFilter<T> = (events) =>\n    events\n      .filter((e) => e.type === pallet && e.value.type === name)\n      .map((x) => x.value.value)\n\n  return { watch, pull, filter, isCompatible }\n}\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { AbortError } from \"@polkadot-api/utils\"\nimport { Observable, Subscription, noop } from \"rxjs\"\n\nexport function firstValueFromWithSignal<T>(\n  source: Observable<T>,\n  signal?: AbortSignal,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let subscription: Subscription | null = null\n    let isDone = false\n\n    const onAbort = signal\n      ? () => {\n          subscription?.unsubscribe()\n          reject(new AbortError())\n        }\n      : noop\n\n    subscription = source.subscribe({\n      next: (value) => {\n        resolve(value)\n        subscription?.unsubscribe()\n        isDone = true\n      },\n      error: (e) => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(e)\n      },\n      complete: () => {\n        signal?.removeEventListener(\"abort\", onAbort)\n        reject(new Error(\"Observable completed without emitting\"))\n      },\n    })\n\n    // the observable could have emitted synchronously\n    if (!isDone) signal?.addEventListener(\"abort\", onAbort)\n  })\n}\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable, Subscription } from \"rxjs\"\n\nexport const raceMap =\n  <I, O>(mapper: (x: I) => Observable<O>, concurrent: number) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let innerSubscriptions = new Array<Subscription>()\n      let isOuterDone = false\n\n      const createSubscription = (value: I) => {\n        const sub = new Subscription()\n        innerSubscriptions.push(sub)\n        if (innerSubscriptions.length > concurrent) {\n          innerSubscriptions[0].unsubscribe()\n          innerSubscriptions = innerSubscriptions.slice(1)\n        }\n\n        const subscription = mapper(value).subscribe({\n          next(value) {\n            const index = innerSubscriptions.indexOf(sub)\n            innerSubscriptions.slice(0, index).forEach((s) => s.unsubscribe())\n            innerSubscriptions = innerSubscriptions.slice(index)\n\n            observer.next(value)\n          },\n          error(error) {\n            observer.error(error)\n          },\n          complete() {\n            const index = innerSubscriptions.indexOf(sub)\n            innerSubscriptions.splice(index, 1)\n\n            if (innerSubscriptions.length === 0 && isOuterDone)\n              observer.complete()\n          },\n        })\n        sub.add(subscription)\n      }\n\n      const outerSubscription = source$.subscribe({\n        next(value) {\n          createSubscription(value)\n        },\n        error(err) {\n          observer.error(err)\n        },\n        complete() {\n          if (innerSubscriptions.length === 0) observer.complete()\n          isOuterDone = true\n        },\n      })\n\n      return () => {\n        outerSubscription.unsubscribe()\n        innerSubscriptions.forEach((sub) => sub.unsubscribe())\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nlet NOTIN = {}\nexport const continueWith =\n  <I, O>(\n    mapper: (input: I) => Observable<O>,\n  ): ((source: Observable<I>) => Observable<I | O>) =>\n  (source) =>\n    new Observable((observer) => {\n      let latestValue: I = NOTIN as I\n      let subscription = source.subscribe({\n        next(v) {\n          observer.next((latestValue = v))\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          if (latestValue === NOTIN) observer.complete()\n          else subscription = mapper(latestValue).subscribe(observer)\n        },\n      })\n\n      return () => {\n        subscription.unsubscribe()\n      }\n    })\n","import {\n  ChainHead$,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  combineLatest,\n  connectable,\n  filter,\n  firstValueFrom,\n  map,\n} from \"rxjs\"\nimport { DescriptorValues } from \"./descriptors\"\n\nexport const enum OpType {\n  Storage = \"storage\",\n  Tx = \"tx\",\n  Event = \"events\",\n  Error = \"errors\",\n  Const = \"constants\",\n}\n\nexport class Runtime {\n  private constructor(\n    private _ctx: RuntimeContext,\n    private _checksums: string[],\n    private _descriptors: DescriptorValues,\n  ) {}\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  static _create(\n    ctx: RuntimeContext,\n    checksums: string[],\n    descriptors: DescriptorValues,\n  ) {\n    return new Runtime(ctx, checksums, descriptors)\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getCtx() {\n    return this._ctx\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getPalletChecksum(opType: OpType, pallet: string, name: string) {\n    return this._checksums[this._descriptors[opType][pallet][name]]\n  }\n\n  /**\n   * @access package  - Internal implementation detail. Do not use.\n   */\n  _getApiChecksum(name: string, method: string) {\n    return this._checksums[this._descriptors.apis[name][method]]\n  }\n}\n\nexport type RuntimeApi = Observable<Runtime> & {\n  /**\n   * @returns Promise that resolves in the `Runtime` as soon as it's\n   *          loaded.\n   */\n  latest: () => Promise<Runtime>\n}\n\nexport const getRuntimeApi = (\n  checksums: Promise<string[]>,\n  descriptors: Promise<DescriptorValues>,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n): RuntimeApi => {\n  const runtimeWithChecksums$ = connectable(\n    combineLatest([chainHead.runtime$, checksums, descriptors]).pipe(\n      map(([x, checksums, descriptors]) =>\n        x ? Runtime._create(x, checksums, descriptors) : null,\n      ),\n    ),\n    {\n      connector: () => new ReplaySubject(1),\n    },\n  )\n  runtimeWithChecksums$.connect()\n\n  const result = runtimeWithChecksums$.pipe(\n    filter((v) => Boolean(v)),\n  ) as RuntimeApi\n  result.latest = () => firstValueFrom(result)\n\n  return result\n}\n\nexport interface IsCompatible {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   * In this case the function waits for `Runtime` to load, and returns\n   * asynchronously.\n   *\n   * @returns Promise that resolves with the result of the compatibility\n   *          check.\n   */\n  (): Promise<boolean>\n  /**\n   * Passing the runtime makes the function to return synchronously.\n   *\n   * @returns Result of the compatibility check.\n   */\n  (runtime: Runtime): boolean\n}\n\nexport const compatibilityHelper =\n  (\n    runtimeApi: RuntimeApi,\n    getDescriptorChecksum: (runtime: Runtime) => string,\n  ) =>\n  (getChecksum: (ctx: RuntimeContext) => string | null) => {\n    function isCompatibleSync(runtime: Runtime) {\n      return getChecksum(runtime._getCtx()) === getDescriptorChecksum(runtime)\n    }\n\n    const isCompatible: IsCompatible = (runtime?: Runtime): any => {\n      if (runtime) {\n        return isCompatibleSync(runtime)\n      }\n\n      return runtimeApi.latest().then(isCompatibleSync)\n    }\n    const waitChecksums = async () => {\n      const runtime = await runtimeApi.latest()\n      return (ctx: RuntimeContext) =>\n        getChecksum(ctx) === getDescriptorChecksum(runtime)\n    }\n    const compatibleRuntime$ = (\n      chainHead: ChainHead$,\n      hash: string | null,\n      error: () => Error,\n    ) =>\n      combineLatest([chainHead.getRuntimeContext$(hash), waitChecksums()]).pipe(\n        map(([ctx, isCompatible]) => {\n          if (!isCompatible(ctx)) {\n            throw error()\n          }\n          return ctx\n        }),\n      )\n\n    const withCompatibleRuntime =\n      <T>(\n        chainHead: ChainHead$,\n        mapper: (x: T) => string,\n        error: () => Error,\n      ) =>\n      (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n        combineLatest([\n          source$.pipe(chainHead.withRuntime(mapper)),\n          waitChecksums(),\n        ]).pipe(\n          map(([[x, ctx], isCompatible]) => {\n            if (!isCompatible(ctx)) {\n              throw error()\n            }\n            return [x, ctx]\n          }),\n        )\n\n    return {\n      isCompatible,\n      waitChecksums,\n      withCompatibleRuntime,\n      compatibleRuntime$,\n    }\n  }\nexport type CompatibilityHelper = ReturnType<typeof compatibilityHelper>\n","import { firstValueFromWithSignal } from \"@/utils\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { map, mergeMap } from \"rxjs\"\nimport { ChainHead$ } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\n\ntype CallOptions = Partial<{\n  at: string\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = Args[\"length\"] extends 0\n  ? [options?: CallOptions]\n  : [...args: Args, options?: CallOptions]\n\nexport interface RuntimeCall<Args extends Array<any>, Payload> {\n  /**\n   * Get `Payload` (Promise-based) for the runtime call.\n   *\n   * @param args  All keys needed for that runtime call.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  (...args: WithCallOptions<Args>): Promise<Payload>\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n}\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createRuntimeCallEntry = (\n  api: string,\n  method: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): RuntimeCall<any, any> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildRuntimeCall(api, method),\n  )\n  const callName = `${api}_${method}`\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry RuntimeCall(${callName})`)\n\n  const fn = (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const result$ = compatibleRuntime$(chainHead, at, checksumError).pipe(\n      mergeMap((ctx) => {\n        const codecs = ctx.dynamicBuilder.buildRuntimeCall(api, method)\n        return chainHead\n          .call$(at, callName, toHex(codecs.args.enc(args)))\n          .pipe(map(codecs.value.dec))\n      }),\n    )\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { firstValueFromWithSignal, raceMap } from \"@/utils\"\nimport { StorageItemInput, StorageResult } from \"@polkadot-api/substrate-client\"\nimport { Observable, debounceTime, distinctUntilChanged, map } from \"rxjs\"\nimport { ChainHead$, NotBestBlockError } from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, IsCompatible } from \"./runtime\"\n\ntype CallOptions = Partial<{\n  /**\n   * `at` could be a blockHash, `best`, or `finalized` (default)\n   */\n  at: string\n  /**\n   * `signal` allows you to abort an ongoing Promise. See [MDN\n   * docs](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for\n   * more information\n   */\n  signal: AbortSignal\n}>\n\ntype WithCallOptions<Args extends Array<any>> = [\n  ...args: Args,\n  options?: CallOptions,\n]\n\ntype PossibleParents<A extends Array<any>> = A extends [...infer Left, any]\n  ? Left | PossibleParents<Left>\n  : []\n\ntype StorageEntryWithoutKeys<Payload> = {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n  /**\n   * Get `Payload` (Promise-based) for the storage entry.\n   *\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValue: (options?: CallOptions) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param bestOrFinalized  Optionally choose which block to query and watch\n   *                         changes, `best` or `finalized` (default)\n   */\n  watchValue: (bestOrFinalized?: \"best\" | \"finalized\") => Observable<Payload>\n}\n\ntype StorageEntryWithKeys<Args extends Array<any>, Payload> = {\n  /**\n   * `isCompatible` enables you to check whether or not the call you're trying\n   * to make is compatible with the descriptors you generated on dev time.\n   */\n  isCompatible: IsCompatible\n  /**\n   * Get `Payload` (Promise-based) for the storage entry with a specific set of\n   * `Args`.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   */\n  getValue: (...args: [...WithCallOptions<Args>]) => Promise<Payload>\n  /**\n   * Watch changes in `Payload` (observable-based) for the storage entry.\n   *\n   * @param args  All keys needed for that storage entry.\n   *              At the end, optionally choose which block to query and\n   *              watch changes, `best` or `finalized` (default)\n   */\n  watchValue: (\n    ...args: [...Args, bestOrFinalized?: \"best\" | \"finalized\"]\n  ) => Observable<Payload>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with\n   * several sets of `Args`.\n   *\n   * @param keys     Array of sets of keys needed for the storage entry.\n   * @param options  Optionally set which block to target (latest known\n   *                 finalized is the default) and an AbortSignal.\n   */\n  getValues: (\n    keys: Array<[...Args]>,\n    options?: CallOptions,\n  ) => Promise<Array<Payload>>\n  /**\n   * Get an Array of `Payload` (Promise-based) for the storage entry with a\n   * subset of `Args`.\n   *\n   * @param args  Subset of keys needed for the storage entry.\n   *              At the end, optionally set which block to target (latest\n   *              known finalized is the default) and an AbortSignal.\n   * @example\n   *\n   *   // this is a query with 3 keys\n   *   typedApi.query.Pallet.Query.getEntries({ at: \"best\" }) // no keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, { at: \"finalized\" }) // 1/3 keys\n   *   typedApi.query.Pallet.Query.getEntries(arg1, arg2, { at: \"0x12345678\" }) // 2/3 keys\n   *\n   */\n  getEntries: (\n    ...args: WithCallOptions<PossibleParents<Args>>\n  ) => Promise<Array<{ keyArgs: Args; value: NonNullable<Payload> }>>\n}\n\nexport type StorageEntry<Args extends Array<any>, Payload> = Args extends []\n  ? StorageEntryWithoutKeys<Payload>\n  : StorageEntryWithKeys<Args, Payload>\n\nexport type Storage$ = <Type extends StorageItemInput[\"type\"]>(\n  hash: string | null,\n  type: Type,\n  key: string,\n  childTrie: string | null,\n) => Observable<StorageResult<Type>>\n\nconst isOptionalArg = (lastArg: any) => {\n  if (typeof lastArg !== \"object\") return false\n\n  return Object.keys(lastArg).every(\n    (k) =>\n      (k === \"at\" && typeof lastArg.at === \"string\") ||\n      (k === \"signal\" && lastArg.signal instanceof AbortSignal),\n  )\n}\n\nexport const createStorageEntry = (\n  pallet: string,\n  name: string,\n  chainHead: ChainHead$,\n  compatibilityHelper: CompatibilityHelper,\n): StorageEntry<any, any> => {\n  const isSystemNumber = pallet === \"System\" && name === \"Number\"\n  const { isCompatible, waitChecksums, withCompatibleRuntime } =\n    compatibilityHelper((ctx) => ctx.checksumBuilder.buildStorage(pallet, name))\n\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Storage(${pallet}.${name})`)\n  const invalidArgs = (args: Array<any>) =>\n    new Error(`Invalid Arguments calling ${pallet}.${name}(${args})`)\n\n  const watchValue = (...args: Array<any>) => {\n    const target = args[args.length - 1]\n    const actualArgs =\n      target === \"best\" || target === \"finalized\" ? args.slice(0, -1) : args\n\n    if (isSystemNumber)\n      return chainHead.bestBlocks$.pipe(\n        map((blocks) => blocks.at(target === \"best\" ? 0 : -1)!.number),\n        distinctUntilChanged(),\n      )\n\n    return chainHead[target === \"best\" ? \"best$\" : \"finalized$\"].pipe(\n      debounceTime(0),\n      withCompatibleRuntime(chainHead, (x) => x.hash, checksumError),\n      raceMap(([block, ctx]) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return chainHead\n          .storage$(block.hash, \"value\", () => codecs.enc(...actualArgs))\n          .pipe(map((val) => ({ val, codecs })))\n      }, 4),\n      distinctUntilChanged((a, b) => a.val === b.val),\n      map(({ val, codecs }) =>\n        val === null ? codecs.fallback : codecs.dec(val),\n      ),\n    )\n  }\n\n  const getValue = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    let result$: Observable<any>\n    if (isSystemNumber) {\n      result$ = chainHead.bestBlocks$.pipe(\n        map((blocks) => {\n          if (at === \"finalized\" || !at) return blocks.at(-1)\n          if (at === \"best\") return blocks.at(0)\n          return blocks.find((block) => block.hash === at)\n        }),\n        map((block) => {\n          if (!block) throw new NotBestBlockError()\n          return block.number\n        }),\n        distinctUntilChanged(),\n      )\n    } else {\n      const isCompatible = await waitChecksums()\n      result$ = chainHead.storage$(\n        at,\n        \"value\",\n        (ctx) => {\n          if (!isCompatible(ctx)) throw checksumError()\n          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n          const actualArgs =\n            args.length === codecs.len ? args : args.slice(0, -1)\n          if (args !== actualArgs && !isLastArgOptional) throw invalidArgs(args)\n          return codecs.enc(...actualArgs)\n        },\n        null,\n        (data, ctx) => {\n          const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n          return data === null ? codecs.fallback : codecs.dec(data)\n        },\n      )\n    }\n\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getEntries = async (...args: Array<any>) => {\n    const lastArg = args[args.length - 1]\n    const isLastArgOptional = isOptionalArg(lastArg)\n    const { signal, at: _at }: CallOptions = isLastArgOptional ? lastArg : {}\n    const at = _at ?? null\n\n    const isCompatible = await waitChecksums()\n    const result$ = chainHead.storage$(\n      at,\n      \"descendantsValues\",\n      (ctx) => {\n        if (!isCompatible(ctx)) throw checksumError()\n\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        if (args.length > codecs.len) throw invalidArgs(args)\n        const actualArgs =\n          args.length > 0 && isLastArgOptional ? args.slice(0, -1) : args\n        if (args.length === codecs.len && actualArgs === args)\n          throw invalidArgs(args)\n        return codecs.enc(...actualArgs)\n      },\n      null,\n      (values, ctx) => {\n        const codecs = ctx.dynamicBuilder.buildStorage(pallet, name)\n        return values.map(({ key, value }) => ({\n          keyArgs: codecs.keyDecoder(key),\n          value: codecs.dec(value),\n        }))\n      },\n    )\n    return firstValueFromWithSignal(result$, signal)\n  }\n\n  const getValues = (keyArgs: Array<Array<any>>, options?: CallOptions) =>\n    Promise.all(\n      keyArgs.map((args) => getValue(...(options ? [...args, options] : args))),\n    )\n\n  return { isCompatible, getValue, getValues, getEntries, watchValue }\n}\n","import {\n  AccountId,\n  Binary,\n  Enum,\n  SS58String,\n  Tuple,\n  compact,\n  u128,\n  u32,\n  u8,\n} from \"@polkadot-api/substrate-bindings\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport {\n  Observable,\n  firstValueFrom,\n  map,\n  mergeMap,\n  take,\n  throwError,\n} from \"rxjs\"\nimport {\n  BlockInfo,\n  RuntimeContext,\n  getObservableClient,\n} from \"@polkadot-api/observable-client\"\nimport { CompatibilityHelper, Runtime } from \"../runtime\"\nimport { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { getPolkadotSigner } from \"@polkadot-api/signer\"\nimport { AssetDescriptor } from \"../descriptors\"\nimport { createTx } from \"./create-tx\"\nimport {\n  TxCall,\n  TxEntry,\n  TxPromise,\n  TxObservable,\n  TxOptions,\n  TxSignFn,\n} from \"./types\"\nimport { submit, submit$ } from \"./submit-fns\"\n\nexport { submit, submit$ }\n\nconst accountIdEnc = AccountId().enc\nconst queryInfoRawDec = Tuple(compact, compact, u8, u128).dec\nconst queryInfoDec = (input: string): bigint => queryInfoRawDec(input)[3]\nconst fakeSignature = new Uint8Array(64)\nconst getFakeSignature = () => fakeSignature\n\nexport const createTxEntry = <\n  Arg extends {} | undefined,\n  Pallet extends string,\n  Name extends string,\n  Asset extends AssetDescriptor<any>,\n>(\n  pallet: Pallet,\n  name: Name,\n  assetChecksum: Asset,\n  chainHead: ReturnType<ReturnType<typeof getObservableClient>[\"chainHead$\"]>,\n  broadcast: (tx: string) => Observable<never>,\n  compatibilityHelper: CompatibilityHelper,\n): TxEntry<Arg, Pallet, Name, Asset[\"_type\"]> => {\n  const { isCompatible, compatibleRuntime$ } = compatibilityHelper((ctx) =>\n    ctx.checksumBuilder.buildCall(pallet, name),\n  )\n  const checksumError = () =>\n    new Error(`Incompatible runtime entry Tx(${pallet}.${name})`)\n\n  const fn = (arg?: Arg): any => {\n    const getCallDataWithContext = (\n      { dynamicBuilder, asset: [assetEnc, assetCheck] }: RuntimeContext,\n      arg: any,\n      txOptions: Partial<{ asset: any }> = {},\n    ) => {\n      let returnOptions = txOptions\n      if (txOptions.asset) {\n        if (assetChecksum !== assetCheck)\n          throw new Error(`Incompatible runtime asset`)\n        returnOptions = { ...txOptions, asset: assetEnc(txOptions.asset) }\n      }\n\n      const { location, codec } = dynamicBuilder.buildCall(pallet, name)\n      return {\n        callData: Binary.fromBytes(\n          mergeUint8(new Uint8Array(location), codec.enc(arg)),\n        ),\n        options: returnOptions,\n      }\n    }\n\n    const getCallData$ = (arg: any, options: Partial<{ asset: any }> = {}) =>\n      compatibleRuntime$(chainHead, null, checksumError).pipe(\n        map((ctx) => getCallDataWithContext(ctx, arg, options)),\n      )\n\n    const getEncodedData: TxCall = (runtime?: Runtime): any => {\n      if (!runtime)\n        return firstValueFrom(getCallData$(arg).pipe(map((x) => x.callData)))\n\n      if (!isCompatible(runtime)) throw checksumError()\n      return getCallDataWithContext(runtime._getCtx(), arg).callData\n    }\n\n    const sign$ = (\n      from: PolkadotSigner,\n      { ..._options }: Omit<TxOptions<{}>, \"at\">,\n      atBlock: BlockInfo,\n    ) =>\n      getCallData$(arg, _options).pipe(\n        mergeMap(({ callData, options }) =>\n          createTx(chainHead, from, callData.asBytes(), atBlock, options),\n        ),\n      )\n\n    const _sign = (\n      from: PolkadotSigner,\n      { at, ..._options }: TxOptions<{}> = {},\n    ) => {\n      return (\n        !at || at === \"finalized\"\n          ? chainHead.finalized$\n          : at === \"best\"\n            ? chainHead.best$\n            : chainHead.bestBlocks$.pipe(\n                map((x) => x.find((b) => b.hash === at)),\n              )\n      ).pipe(\n        take(1),\n        mergeMap((atBlock) =>\n          atBlock\n            ? sign$(from, _options, atBlock).pipe(\n                map((signed) => ({\n                  tx: toHex(signed),\n                  block: atBlock,\n                })),\n              )\n            : throwError(() => new Error(`Uknown block ${at}`)),\n        ),\n      )\n    }\n\n    const sign: TxSignFn<Asset> = (from, options) =>\n      firstValueFrom(_sign(from, options)).then((x) => x.tx)\n\n    const signAndSubmit: TxPromise<Asset> = (from, _options) =>\n      firstValueFrom(_sign(from, _options)).then(({ tx, block }) =>\n        submit(chainHead, broadcast, tx, block.hash),\n      )\n\n    const signSubmitAndWatch: TxObservable<Asset> = (from, _options) =>\n      _sign(from, _options).pipe(\n        mergeMap(({ tx, block }) =>\n          submit$(chainHead, broadcast, tx, block.hash, true),\n        ),\n      )\n\n    const getEstimatedFees = async (\n      from: Uint8Array | SS58String,\n      _options?: any,\n    ) => {\n      const fakeSigner = getPolkadotSigner(\n        from instanceof Uint8Array ? from : accountIdEnc(from),\n        \"Sr25519\",\n        getFakeSignature,\n      )\n      const encoded = fromHex(await sign(fakeSigner, _options))\n      const args = toHex(mergeUint8(encoded, u32.enc(encoded.length)))\n\n      return firstValueFrom(\n        chainHead\n          .call$(null, \"TransactionPaymentApi_query_info\", args)\n          .pipe(map(queryInfoDec)),\n      )\n    }\n\n    return {\n      getEstimatedFees,\n      decodedCall: {\n        type: pallet,\n        value: Enum(name, arg as any),\n      },\n      getEncodedData,\n      sign,\n      signSubmitAndWatch,\n      signAndSubmit,\n    }\n  }\n\n  return Object.assign(fn, { isCompatible })\n}\n","import { Observable, combineLatest, mergeMap, of, take } from \"rxjs\"\nimport { BlockInfo, ChainHead$ } from \"@polkadot-api/observable-client\"\nimport {\n  ChargeAssetTxPayment,\n  ChargeTransactionPayment,\n  CheckMortality,\n} from \"./signed-extensions/user\"\nimport * as chainSignedExtensions from \"./signed-extensions/chain\"\nimport type { PolkadotSigner } from \"@polkadot-api/polkadot-signer\"\nimport { _void } from \"@polkadot-api/substrate-bindings\"\nimport { empty } from \"./signed-extensions/utils\"\n\ntype HintedSignedExtensions = Partial<{\n  tip: bigint\n  mortality: { mortal: false } | { mortal: true; period: number }\n  asset: Uint8Array\n  nonce: number\n}>\n\nexport const createTx: (\n  chainHead: ChainHead$,\n  signer: PolkadotSigner,\n  callData: Uint8Array,\n  atBlock: BlockInfo,\n  hinted?: HintedSignedExtensions,\n) => Observable<Uint8Array> = (\n  chainHead,\n  signer,\n  callData,\n  atBlock,\n  hinted = {},\n) =>\n  chainHead.getRuntimeContext$(atBlock.hash).pipe(\n    take(1),\n    mergeMap((ctx) => {\n      const signedExtensionsCtx = {\n        metadata: ctx.metadata,\n        chainHead: chainHead,\n        callData: callData,\n        at: atBlock.hash,\n        from: signer.publicKey,\n      }\n\n      const mortality: Parameters<typeof CheckMortality>[0] = !hinted.mortality\n        ? { period: 64, blockNumber: atBlock.number }\n        : hinted.mortality.mortal\n          ? { period: hinted.mortality.period, blockNumber: atBlock.number }\n          : undefined // immortal\n\n      return combineLatest(\n        ctx.metadata.extrinsic.signedExtensions.map(\n          ({ identifier, type, additionalSigned }) => {\n            if (identifier === \"CheckMortality\")\n              return CheckMortality(mortality, signedExtensionsCtx)\n\n            if (identifier === \"ChargeTransactionPayment\")\n              return ChargeTransactionPayment(hinted.tip ?? 0n)\n\n            if (identifier === \"ChargeAssetTxPayment\")\n              return ChargeAssetTxPayment(hinted.tip ?? 0n, hinted.asset)\n\n            if (identifier === \"CheckNonce\" && \"nonce\" in hinted)\n              return chainSignedExtensions.getNonce(hinted.nonce!)\n\n            const fn = chainSignedExtensions[identifier as \"CheckGenesis\"]\n            if (!fn) {\n              if (\n                ctx.dynamicBuilder.buildDefinition(type) === _void &&\n                ctx.dynamicBuilder.buildDefinition(additionalSigned) === _void\n              )\n                return of({\n                  value: empty,\n                  additionalSigned: empty,\n                })\n\n              throw new Error(`Unsupported signed-extension: ${identifier}`)\n            }\n            return fn(signedExtensionsCtx)\n          },\n        ),\n      ).pipe(\n        mergeMap((signedExtensions) =>\n          signer.sign(\n            callData,\n            Object.fromEntries(\n              ctx.metadata.extrinsic.signedExtensions.map(\n                ({ identifier }, idx) => [\n                  identifier,\n                  { identifier, ...signedExtensions[idx] },\n                ],\n              ),\n            ),\n            ctx.metadataRaw,\n            atBlock.number,\n          ),\n        ),\n      )\n    }),\n  )\n","import { compactBn } from \"@polkadot-api/substrate-bindings\"\nimport { of } from \"rxjs\"\nimport { empty } from \"../utils\"\nimport { SignedExtension } from \"../internal-types\"\n\nexport const ChargeTransactionPayment = (tip: bigint): SignedExtension =>\n  of({\n    value: compactBn.enc(tip),\n    additionalSigned: empty,\n  })\n","import { map, noop, of } from \"rxjs\"\nimport {\n  V15,\n  Storage,\n  Twox64Concat,\n  u32,\n  V14,\n} from \"@polkadot-api/substrate-bindings\"\nimport { getDynamicBuilder, getLookupFn } from \"@polkadot-api/metadata-builders\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport type { ChainExtensionCtx } from \"./internal-types\"\n\nexport const empty = new Uint8Array()\n\nconst genesisHashStorageKey = Storage(\"System\")(\"BlockHash\", noop, [\n  u32,\n  Twox64Concat,\n]).enc(0)\n\nexport const genesisHashFromCtx = (ctx: ChainExtensionCtx) =>\n  ctx.chainHead\n    .storage$(ctx.at, \"value\", () => genesisHashStorageKey, null)\n    .pipe(map((result) => fromHex(result!)))\n\nexport const systemVersionProp$ = (propName: string, metadata: V14 | V15) => {\n  const lookupFn = getLookupFn(metadata.lookup)\n  const dynamicBuilder = getDynamicBuilder(metadata)\n\n  const constant = metadata.pallets\n    .find((x) => x.name === \"System\")!\n    .constants!.find((s) => s.name === \"Version\")!\n\n  const systemVersion = lookupFn(constant.type)\n  const systemVersionDec = dynamicBuilder.buildDefinition(constant.type).dec\n\n  if (systemVersion.type !== \"struct\") throw new Error(\"not a struct\")\n\n  const valueEnc = dynamicBuilder.buildDefinition(\n    systemVersion.value[propName].id,\n  ).enc\n\n  return of(valueEnc(systemVersionDec(constant.value)[propName]))\n}\n","import { map, of } from \"rxjs\"\nimport { Bytes, enhanceEncoder, u16 } from \"@polkadot-api/substrate-bindings\"\nimport { fromHex } from \"@polkadot-api/utils\"\nimport { genesisHashFromCtx } from \"../utils\"\nimport { ChainExtensionCtx, SignedExtension } from \"../internal-types\"\n\nfunction trailingZeroes(n: number) {\n  let i = 0\n  while (!(n & 1)) {\n    i++\n    n >>= 1\n  }\n  return i\n}\n\nconst mortal = enhanceEncoder(\n  Bytes(2).enc,\n  (value: { period: number; phase: number }) => {\n    const factor = Math.max(value.period >> 12, 1)\n    const left = Math.min(Math.max(trailingZeroes(value.period) - 1, 1), 15)\n    const right = (value.phase / factor) << 4\n    return u16.enc(left | right)\n  },\n)\n\nconst zero = new Uint8Array([0])\nexport const CheckMortality = (\n  input: { period: number; blockNumber: number } | undefined,\n  ctx: ChainExtensionCtx,\n): SignedExtension => {\n  if (!input)\n    return genesisHashFromCtx(ctx).pipe(\n      map((additionalSigned) => ({\n        additionalSigned,\n        value: zero,\n      })),\n    )\n\n  const { period, blockNumber } = input\n  return of({\n    additionalSigned: fromHex(ctx.at),\n    value: mortal({\n      period,\n      phase: blockNumber % period,\n    }),\n  })\n}\n","import { of } from \"rxjs\"\nimport {\n  Bytes,\n  Option,\n  Struct,\n  compact,\n} from \"@polkadot-api/substrate-bindings\"\nimport { empty } from \"../utils\"\nimport { SignedExtension } from \"../internal-types\"\n\nconst encoder = Struct({\n  tip: compact,\n  asset: Option(Bytes(Infinity)),\n}).enc\n\nexport const ChargeAssetTxPayment = (\n  tip: number | bigint,\n  asset: Uint8Array | undefined,\n): SignedExtension =>\n  of({\n    value: encoder({\n      tip,\n      asset,\n    }),\n    additionalSigned: empty,\n  })\n","export * from \"./CheckGenesis\"\nexport * from \"./CheckMetadataHash\"\nexport * from \"./CheckNonce\"\nexport * from \"./CheckSpecVersion\"\nexport * from \"./CheckTxVersion\"\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, genesisHashFromCtx } from \"../utils\"\n\nexport const CheckGenesis: GetChainSignedExtension = (ctx) =>\n  genesisHashFromCtx(ctx).pipe(\n    map((additionalSigned) => ({ value: empty, additionalSigned })),\n  )\n","import { of } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\n\nexport const CheckMetadataHash: GetChainSignedExtension = () =>\n  of({\n    value: Uint8Array.from([0]),\n    additionalSigned: Uint8Array.from([0]),\n  })\n","import { mergeMap, of } from \"rxjs\"\nimport { compact, u16, u32, u64, u8 } from \"@polkadot-api/substrate-bindings\"\nimport type {\n  GetChainSignedExtension,\n  SignedExtension,\n} from \"../internal-types\"\nimport { empty } from \"../utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\nconst NONCE_RUNTIME_CALL = \"AccountNonceApi_account_nonce\"\nconst lenToDecoder = {\n  1: u8.dec,\n  2: u16.dec,\n  4: u32.dec,\n  8: u64.dec,\n}\n\nexport const getNonce = (input: number | bigint): SignedExtension =>\n  of({ value: compact.enc(input), additionalSigned: empty })\n\nexport const CheckNonce: GetChainSignedExtension = (ctx) =>\n  ctx.chainHead.call$(ctx.at, NONCE_RUNTIME_CALL, toHex(ctx.from)).pipe(\n    mergeMap((result) => {\n      const bytes = fromHex(result)\n      const decoder = lenToDecoder[bytes.length as 2 | 4 | 8]\n      if (!decoder)\n        throw new Error(`${NONCE_RUNTIME_CALL} retrieved wrong data`)\n      return getNonce(decoder(bytes))\n    }),\n  )\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, systemVersionProp$ } from \"../utils\"\n\nexport const CheckSpecVersion: GetChainSignedExtension = ({ metadata }) =>\n  systemVersionProp$(\"spec_version\", metadata).pipe(\n    map((additionalSigned) => ({ additionalSigned, value: empty })),\n  )\n","import { map } from \"rxjs\"\nimport type { GetChainSignedExtension } from \"../internal-types\"\nimport { empty, systemVersionProp$ } from \"../utils\"\n\nexport const CheckTxVersion: GetChainSignedExtension = ({ metadata }) =>\n  systemVersionProp$(\"transaction_version\", metadata).pipe(\n    map((additionalSigned) => ({ additionalSigned, value: empty })),\n  )\n","import { Blake2256, HexString } from \"@polkadot-api/substrate-bindings\"\nimport {\n  EMPTY,\n  Observable,\n  concat,\n  distinctUntilChanged,\n  filter,\n  lastValueFrom,\n  map,\n  mergeMap,\n  of,\n  take,\n} from \"rxjs\"\nimport {\n  ChainHead$,\n  PinnedBlocks,\n  SystemEvent,\n} from \"@polkadot-api/observable-client\"\nimport { AnalyzedBlock } from \"@polkadot-api/observable-client\"\nimport { TxEvent, TxEventsPayload, TxFinalizedPayload } from \"./types\"\nimport { continueWith } from \"@/utils\"\nimport { fromHex, toHex } from \"@polkadot-api/utils\"\n\n// TODO: make it dynamic based on the tx-function of the client\nconst hashFromTx = (tx: HexString) => toHex(Blake2256(fromHex(tx)))\n\nconst computeState = (\n  analized$: Observable<AnalyzedBlock>,\n  blocks$: Observable<PinnedBlocks>,\n) =>\n  new Observable<\n    | {\n        hash: string\n        index: number\n        events: any\n      }\n    | boolean\n  >((observer) => {\n    const analyzedBlocks = new Map<string, AnalyzedBlock>()\n    let pinnedBlocks: PinnedBlocks\n    let latestState:\n      | {\n          hash: string\n          index: number\n          events: any\n        }\n      | boolean\n\n    const computeNextState = () => {\n      let current: string = pinnedBlocks.best\n      let analyzed: AnalyzedBlock | undefined = analyzedBlocks.get(current)\n\n      while (!analyzed) {\n        const block = pinnedBlocks.blocks.get(current)\n        if (!block) break\n        analyzed = analyzedBlocks.get((current = block.parent))\n      }\n\n      if (!analyzed) return // this shouldn't happen, though\n\n      const isFinalized =\n        pinnedBlocks.blocks.get(analyzed.hash)!.number <=\n        pinnedBlocks.blocks.get(pinnedBlocks.finalized)!.number\n\n      const found = analyzed.found.type\n      if (\n        found &&\n        typeof latestState === \"object\" &&\n        latestState.hash === analyzed.hash\n      ) {\n        if (isFinalized) observer.complete()\n        return\n      }\n\n      observer.next(\n        (latestState = found\n          ? {\n              hash: analyzed.hash,\n              ...analyzed.found,\n            }\n          : analyzed.found.isValid),\n      )\n\n      if (isFinalized) {\n        if (found) observer.complete()\n        else if (!analyzed.found.isValid) observer.error(new Error(\"Invalid\"))\n      }\n    }\n\n    const subscription = blocks$\n      .pipe(\n        distinctUntilChanged(\n          (a, b) => a.finalized === b.finalized && a.best === b.best,\n        ),\n      )\n      .subscribe({\n        next: (pinned: PinnedBlocks) => {\n          pinnedBlocks = pinned\n          if (analyzedBlocks.size === 0) return\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      })\n\n    subscription.add(\n      analized$.subscribe({\n        next: (block) => {\n          analyzedBlocks.set(block.hash, block)\n          computeNextState()\n        },\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n\n    return subscription\n  }).pipe(distinctUntilChanged((a, b) => a === b))\n\nconst getTxSuccessFromSystemEvents = (\n  systemEvents: Array<SystemEvent>,\n  txIdx: number,\n): Omit<TxEventsPayload, \"block\"> => {\n  const events = systemEvents\n    .filter((x) => x.phase.type === \"ApplyExtrinsic\" && x.phase.value === txIdx)\n    .map((x) => x.event)\n\n  const lastEvent = events[events.length - 1]\n  const ok =\n    lastEvent.type === \"System\" && lastEvent.value.type === \"ExtrinsicSuccess\"\n\n  return { ok, events }\n}\n\nexport const submit$ = (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  tx: HexString,\n  at?: HexString,\n  emitSign = false,\n): Observable<TxEvent> => {\n  const txHash = hashFromTx(tx)\n  const getTxEvent = <\n    Type extends TxEvent[\"type\"],\n    Rest extends Omit<TxEvent & { type: Type }, \"type\" | \"txHash\">,\n  >(\n    type: Type,\n    rest: Rest,\n  ): TxEvent & { type: Type } =>\n    ({\n      type,\n      txHash,\n      ...rest,\n    }) as any\n\n  const at$ = chainHead.pinnedBlocks$.pipe(\n    take(1),\n    map((blocks) => blocks.blocks.get(at!)?.hash ?? blocks.finalized),\n  )\n\n  const validate$: Observable<never> = at$.pipe(\n    mergeMap((at) =>\n      chainHead.validateTx$(at, tx).pipe(\n        filter((x) => !x),\n        map(() => {\n          throw new Error(\"Invalid\")\n        }),\n      ),\n    ),\n  )\n\n  const track$ = new Observable<AnalyzedBlock>((observer) => {\n    const subscription = chainHead.trackTx$(tx).subscribe(observer)\n    subscription.add(\n      broadcastTx$(tx).subscribe({\n        error(e) {\n          observer.error(e)\n        },\n      }),\n    )\n    return subscription\n  })\n\n  const bestBlockState$ = computeState(track$, chainHead.pinnedBlocks$).pipe(\n    map((x) => {\n      if (x === true || x === false)\n        return getTxEvent(\"txBestBlocksState\", {\n          found: false,\n          isValid: x,\n        })\n\n      return getTxEvent(\"txBestBlocksState\", {\n        found: true,\n        block: {\n          index: x.index,\n          hash: x.hash,\n        },\n        ...getTxSuccessFromSystemEvents(x.events, x.index),\n      })\n    }),\n  )\n\n  return concat(\n    emitSign ? of(getTxEvent(\"signed\", {})) : EMPTY,\n    validate$,\n    of(getTxEvent(\"broadcasted\", {})),\n    bestBlockState$.pipe(\n      continueWith(({ found, type, ...rest }) =>\n        found ? of(getTxEvent(\"finalized\", rest as any)) : EMPTY,\n      ),\n    ),\n  )\n}\n\nexport const submit = async (\n  chainHead: ChainHead$,\n  broadcastTx$: (tx: string) => Observable<never>,\n  transaction: HexString,\n  at?: HexString,\n): Promise<TxFinalizedPayload> =>\n  lastValueFrom(submit$(chainHead, broadcastTx$, transaction, at)).then((x) => {\n    if (x.type !== \"finalized\") throw null\n    const result: TxFinalizedPayload = { ...x }\n    delete (result as any).type\n    return result\n  })\n","export type {\n  Codec,\n  SS58String,\n  HexString,\n  GetEnum,\n  ResultPayload,\n} from \"@polkadot-api/substrate-bindings\"\nexport {\n  AccountId,\n  Binary,\n  FixedSizeBinary,\n  Enum,\n  type EnumVariant,\n  _Enum,\n} from \"@polkadot-api/substrate-bindings\"\n"],"mappings":"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","names":["import_observable_client","import_rxjs","compatibilityHelper","import_rxjs","import_rxjs","import_rxjs","import_rxjs","import_rxjs","value","import_rxjs","compatibilityHelper","filter","import_rxjs","checksums","descriptors","isCompatible","import_utils","import_rxjs","compatibilityHelper","import_rxjs","isOptionalArg","compatibilityHelper","isCompatible","import_substrate_bindings","import_utils","import_rxjs","import_rxjs","import_substrate_bindings","import_rxjs","import_rxjs","import_utils","import_rxjs","import_substrate_bindings","import_utils","import_rxjs","import_substrate_bindings","import_rxjs","import_rxjs","import_rxjs","import_substrate_bindings","import_utils","import_rxjs","import_rxjs","import_substrate_bindings","import_substrate_bindings","import_rxjs","import_utils","at","compatibilityHelper","arg","createRawClient","import_substrate_bindings"]}